
# python
import ctypes
from typing import (Any, Final, Generator, Generic, List, overload, Tuple,
                    TypeVar, Union)

T = TypeVar('T')
C = TypeVar('C')

class _Vec1(Generic[T, C]):

    x: T

    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, x: T, /) -> None: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> T: ...
    def __setitem__(self, index: int, value: T) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[T, None, None]: ...

    def __add__(self, other: Union[float, _Vec1[T, C]]) -> _Vec1[T, C]: ...
    def __sub__(self, other: Union[float, _Vec1[T, C]]) -> _Vec1[T, C]: ...
    def __mul__(self, other: Union[float, _Vec1[T, C]]) -> _Vec1[T, C]: ...
    def __mod__(self, other: Union[float, _Vec1[T, C]]) -> _Vec1[T, C]: ...
    def __divmod__(self, other: Union[float, _Vec1[T, C]]) -> _Vec1[T, C]: ...
    def __pow__(self, other: Union[float, _Vec1[T, C]]) -> _Vec1[T, C]: ...

    def __neg__(self) -> _Vec1[T, C]: ...
    def __pos__(self) -> _Vec1[T, C]: ...
    def __abs__(self) -> _Vec1[T, C]: ...

    def __iadd__(self, other: Union[float, _Vec1[T, C]]) -> None: ...
    def __isub__(self, other: Union[float, _Vec1[T, C]]) -> None: ...
    def __imul__(self, other: Union[float, _Vec1[T, C]]) -> None: ...
    def __imod__(self, other: Union[float, _Vec1[T, C]]) -> None: ...
    def __ipow__(self, other: Union[float, _Vec1[T, C]]) -> None: ...

    def __floordiv__(self, other: Union[float, _Vec1[T, C]]) -> _Vec1[T, C]: ...
    def __div__(self, other: Union[float, _Vec1[T, C]]) -> _Vec1[T, C]: ...
    def __ifloordiv__(self, other: Union[float, _Vec1[T, C]]) -> None: ...
    def __idiv__(self, other: Union[float, _Vec1[T, C]]) -> None: ...

    def __matmul__(self, other: Union[float, _Vec1[T, C]]) -> _Vec1[T, C]: ...
    def __imatmul__(self, other: Union[float, _Vec1[T, C]]) -> None: ...

    def to_list(self) -> List[T]: ...
    def to_tuple(self) -> Tuple[T]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> _Vec1[T, C]: ...


class _Vec2(Generic[T, C]):

    x: T
    y: T

    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, _: T, /) -> None: ...

    @overload
    def __init__(self, x: T, y: T, /) -> None: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> T: ...
    def __setitem__(self, index: int, value: T) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[T, None, None]: ...

    def __add__(self, other: Union[float, _Vec2[T, C]]) -> _Vec2[T, C]: ...
    def __sub__(self, other: Union[float, _Vec2[T, C]]) -> _Vec2[T, C]: ...
    def __mul__(self, other: Union[float, _Vec2[T, C]]) -> _Vec2[T, C]: ...
    def __mod__(self, other: Union[float, _Vec2[T, C]]) -> _Vec2[T, C]: ...
    def __divmod__(self, other: Union[float, _Vec2[T, C]]) -> _Vec2[T, C]: ...
    def __pow__(self, other: Union[float, _Vec2[T, C]]) -> _Vec2[T, C]: ...

    def __neg__(self) -> _Vec2[T, C]: ...
    def __pos__(self) -> _Vec2[T, C]: ...
    def __abs__(self) -> _Vec2[T, C]: ...

    def __iadd__(self, other: Union[float, _Vec2[T, C]]) -> None: ...
    def __isub__(self, other: Union[float, _Vec2[T, C]]) -> None: ...
    def __imul__(self, other: Union[float, _Vec2[T, C]]) -> None: ...
    def __imod__(self, other: Union[float, _Vec2[T, C]]) -> None: ...
    def __ipow__(self, other: Union[float, _Vec2[T, C]]) -> None: ...

    def __floordiv__(self, other: Union[float, _Vec2[T, C]]) -> _Vec2[T, C]: ...
    def __div__(self, other: Union[float, _Vec2[T, C]]) -> _Vec2[T, C]: ...
    def __ifloordiv__(self, other: Union[float, _Vec2[T, C]]) -> None: ...
    def __idiv__(self, other: Union[float, _Vec2[T, C]]) -> None: ...

    def __matmul__(self, other: Union[float, _Vec2[T, C]]) -> _Vec2[T, C]: ...
    def __imatmul__(self, other: Union[float, _Vec2[T, C]]) -> None: ...

    def to_list(self) -> List[T]: ...
    def to_tuple(self) -> Tuple[T, T]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> _Vec2[T, C]: ...


class _Vec3(Generic[T, C]):

    x: T
    y: T
    z: T

    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, _: T, /) -> None: ...

    @overload
    def __init__(self, x: T, y: T, z: T, /) -> None: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> T: ...
    def __setitem__(self, index: int, value: T) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[T, None, None]: ...

    def __add__(self, other: Union[float, _Vec3[T, C]]) -> _Vec3[T, C]: ...
    def __sub__(self, other: Union[float, _Vec3[T, C]]) -> _Vec3[T, C]: ...
    def __mul__(self, other: Union[float, _Vec3[T, C]]) -> _Vec3[T, C]: ...
    def __mod__(self, other: Union[float, _Vec3[T, C]]) -> _Vec3[T, C]: ...
    def __divmod__(self, other: Union[float, _Vec3[T, C]]) -> _Vec3[T, C]: ...
    def __pow__(self, other: Union[float, _Vec3[T, C]]) -> _Vec3[T, C]: ...

    def __neg__(self) -> _Vec3[T, C]: ...
    def __pos__(self) -> _Vec3[T, C]: ...
    def __abs__(self) -> _Vec3[T, C]: ...

    def __iadd__(self, other: Union[float, _Vec3[T, C]]) -> None: ...
    def __isub__(self, other: Union[float, _Vec3[T, C]]) -> None: ...
    def __imul__(self, other: Union[float, _Vec3[T, C]]) -> None: ...
    def __imod__(self, other: Union[float, _Vec3[T, C]]) -> None: ...
    def __ipow__(self, other: Union[float, _Vec3[T, C]]) -> None: ...

    def __floordiv__(self, other: Union[float, _Vec3[T, C]]) -> _Vec3[T, C]: ...
    def __div__(self, other: Union[float, _Vec3[T, C]]) -> _Vec3[T, C]: ...
    def __ifloordiv__(self, other: Union[float, _Vec3[T, C]]) -> None: ...
    def __idiv__(self, other: Union[float, _Vec3[T, C]]) -> None: ...

    def __matmul__(self, other: Union[float, _Vec3[T, C]]) -> _Vec3[T, C]: ...
    def __imatmul__(self, other: Union[float, _Vec3[T, C]]) -> None: ...

    def to_list(self) -> List[T]: ...
    def to_tuple(self) -> Tuple[T, T, T]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> _Vec3[T, C]: ...


class _Vec4(Generic[T, C]):

    x: T
    y: T
    z: T
    w: T

    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, _: T, /) -> None: ...

    @overload
    def __init__(self, x: T, y: T, z: T, w: T, /) -> None: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> T: ...
    def __setitem__(self, index: int, value: T) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[T, None, None]: ...

    def __add__(self, other: Union[float, _Vec4[T, C]]) -> _Vec4[T, C]: ...
    def __sub__(self, other: Union[float, _Vec4[T, C]]) -> _Vec4[T, C]: ...
    def __mul__(self, other: Union[float, _Vec4[T, C]]) -> _Vec4[T, C]: ...
    def __mod__(self, other: Union[float, _Vec4[T, C]]) -> _Vec4[T, C]: ...
    def __divmod__(self, other: Union[float, _Vec4[T, C]]) -> _Vec4[T, C]: ...
    def __pow__(self, other: Union[float, _Vec4[T, C]]) -> _Vec4[T, C]: ...

    def __neg__(self) -> _Vec4[T, C]: ...
    def __pos__(self) -> _Vec4[T, C]: ...
    def __abs__(self) -> _Vec4[T, C]: ...

    def __iadd__(self, other: Union[float, _Vec4[T, C]]) -> None: ...
    def __isub__(self, other: Union[float, _Vec4[T, C]]) -> None: ...
    def __imul__(self, other: Union[float, _Vec4[T, C]]) -> None: ...
    def __imod__(self, other: Union[float, _Vec4[T, C]]) -> None: ...
    def __ipow__(self, other: Union[float, _Vec4[T, C]]) -> None: ...

    def __floordiv__(self, other: Union[float, _Vec4[T, C]]) -> _Vec4[T, C]: ...
    def __div__(self, other: Union[float, _Vec4[T, C]]) -> _Vec4[T, C]: ...
    def __ifloordiv__(self, other: Union[float, _Vec4[T, C]]) -> None: ...
    def __idiv__(self, other: Union[float, _Vec4[T, C]]) -> None: ...

    def __matmul__(self, other: Union[float, _Vec4[T, C]]) -> _Vec4[T, C]: ...
    def __imatmul__(self, other: Union[float, _Vec4[T, C]]) -> None: ...

    def to_list(self) -> List[T]: ...
    def to_tuple(self) -> Tuple[T, T, T, T]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> _Vec4[T, C]: ...


# float
c_float = ctypes.c_float
float_ = ctypes.c_float
float32 = ctypes.c_float

# double
c_double = ctypes.c_double
double = ctypes.c_double
float64 = ctypes.c_double

# int64
c_int64 = ctypes.c_int64
int64 = ctypes.c_int64

# int32
c_int32 = ctypes.c_int32
int32 = ctypes.c_int32

# int16
c_int16 = ctypes.c_int16
int16 = ctypes.c_int16

# int8
c_int8 = ctypes.c_int8
int8 = ctypes.c_int8

# uint64
c_uint64 = ctypes.c_uint64
uint64 = ctypes.c_uint64

# uint32
c_uint32 = ctypes.c_uint32
uint32 = ctypes.c_uint32

# uint16
c_uint16 = ctypes.c_uint16
uint16 = ctypes.c_uint16

# uint8
c_uint8 = ctypes.c_uint8
uint8 = ctypes.c_uint8

c_bool = ctypes.c_bool
bool_ = ctypes.c_bool

class vec1(_Vec1[float, ctypes.c_float]): ...
class vec2(_Vec2[float, ctypes.c_float]): ...
class vec3(_Vec3[float, ctypes.c_float]): ...
class vec4(_Vec4[float, ctypes.c_float]): ...

fvec1 = f32vec1 = vec1
fvec2 = f32vec2 = vec2
fvec3 = f32vec3 = vec3
fvec4 = f32vec4 = vec4

class dvec1(_Vec1[float, c_double]): ...
class dvec2(_Vec2[float, c_double]): ...
class dvec3(_Vec3[float, c_double]): ...
class dvec4(_Vec4[float, c_double]): ...

f64vec1 = dvec1
f64vec2 = dvec2
f64vec3 = dvec3
f64vec4 = dvec4

class i8vec1(_Vec1[int, c_int8]): ...
class i8vec2(_Vec2[int, c_int8]): ...
class i8vec3(_Vec3[int, c_int8]): ...
class i8vec4(_Vec4[int, c_int8]): ...

class i16vec1(_Vec1[int, c_int16]): ...
class i16vec2(_Vec2[int, c_int16]): ...
class i16vec3(_Vec3[int, c_int16]): ...
class i16vec4(_Vec4[int, c_int16]): ...

class ivec1(_Vec1[int, c_int32]): ...
class ivec2(_Vec2[int, c_int32]): ...
class ivec3(_Vec3[int, c_int32]): ...
class ivec4(_Vec4[int, c_int32]): ...

i32vec1 = ivec1
i32vec2 = ivec2
i32vec3 = ivec3
i32vec4 = ivec4

class i64vec1(_Vec1[int, c_int64]): ...
class i64vec2(_Vec2[int, c_int64]): ...
class i64vec3(_Vec3[int, c_int64]): ...
class i64vec4(_Vec4[int, c_int64]): ...

class u8vec1(_Vec1[int, c_uint8]): ...
class u8vec2(_Vec2[int, c_uint8]): ...
class u8vec3(_Vec3[int, c_uint8]): ...
class u8vec4(_Vec4[int, c_uint8]): ...

class u16vec1(_Vec1[int, c_uint16]): ...
class u16vec2(_Vec2[int, c_uint16]): ...
class u16vec3(_Vec3[int, c_uint16]): ...
class u16vec4(_Vec4[int, c_uint16]): ...

class uvec1(_Vec1[int, c_uint32]): ...
class uvec2(_Vec2[int, c_uint32]): ...
class uvec3(_Vec3[int, c_uint32]): ...
class uvec4(_Vec4[int, c_uint32]): ...

u32vec1 = uvec1
u32vec2 = uvec2
u32vec3 = uvec3
u32vec4 = uvec4

class u64vec1(_Vec1[int, c_uint64]): ...
class u64vec2(_Vec2[int, c_uint64]): ...
class u64vec3(_Vec3[int, c_uint64]): ...
class u64vec4(_Vec4[int, c_uint64]): ...

class bvec1(_Vec1[bool, c_bool]): ...
class bvec2(_Vec2[bool, c_bool]): ...
class bvec3(_Vec3[bool, c_bool]): ...
class bvec4(_Vec4[bool, c_bool]): ...

class mvec1(_Vec1[float, c_float]): ...
class mvec2(_Vec2[float, c_float]): ...
class mvec3(_Vec3[float, c_float]): ...
class mvec4(_Vec4[float, c_float]): ...

class dmvec1(_Vec1[float, c_double]): ...
class dmvec2(_Vec2[float, c_double]): ...
class dmvec3(_Vec3[float, c_double]): ...
class dmvec4(_Vec4[float, c_double]): ...

class imvec1(_Vec1[float, c_int32]): ...
class imvec2(_Vec2[float, c_int32]): ...
class imvec3(_Vec3[float, c_int32]): ...
class imvec4(_Vec4[float, c_int32]): ...

class umvec1(_Vec1[float, c_uint32]): ...
class umvec2(_Vec2[float, c_uint32]): ...
class umvec3(_Vec3[float, c_uint32]): ...
class umvec4(_Vec4[float, c_uint32]): ...

version: Final[str]
license: Final[str]
