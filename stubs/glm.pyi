
from typing import Any, Callable, Generator, Generic, List, Literal, NewType, Optional, overload, Iterable, SupportsFloat, SupportsInt, Tuple, Type, TypeVar, Union
import ctypes

_Number = Union[SupportsFloat, SupportsInt]
_CTYPES = Union[ctypes.c_bool, ctypes.c_byte, ctypes.c_int8, ctypes.c_ubyte, ctypes.c_uint8, ctypes.c_short, ctypes.c_int16, ctypes.c_ushort, ctypes.c_uint16, ctypes.c_int, ctypes.c_int32, ctypes.c_uint, ctypes.c_uint32, ctypes.c_long, ctypes.c_int64, ctypes.c_ulong, ctypes.c_uint64, ctypes.c_longlong, ctypes.c_ulonglong, ctypes.c_size_t, ctypes.c_ssize_t, ctypes.c_float, ctypes.c_double, ctypes.c_longdouble]
_GLM_TYPES = Union[bvec1, bvec2, bvec3, bvec4, dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, dmvec2, dmvec3, dmvec4, dquat, dvec1, dvec2, dvec3, dvec4, i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, mvec2, mvec3, mvec4, quat, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4, vec1, vec2, vec3, vec4]
_VECTOR = Union[bvec1, bvec2, bvec3, bvec4, dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, mvec2, mvec3, mvec4, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4, vec1, vec2, vec3, vec4]
_VECTOR_1 = Union[bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, uvec1, vec1]
_VECTOR_2 = Union[bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]
_VECTOR_3 = Union[bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]
_VECTOR_4 = Union[bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]
_FLOAT_VECTOR = Union[dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, mvec2, mvec3, mvec4, vec1, vec2, vec3, vec4]
_FLOAT_VECTOR_3 = Union[dmvec3, dvec3, mvec3, vec3]
_BOOL_VECTOR = Union[bvec1, bvec2, bvec3, bvec4]
_INT_VECTOR = Union[i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4]
_I_VECTOR = Union[imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4]
_U_VECTOR = Union[umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4]
_QUAT = Union[quat, dquat]
_MATRIX = Union[dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]
_FLOAT_MATRIX = Union[dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4]
_SQUARE_FLOAT_MATRIX = Union[dmat2x2, dmat3x3, dmat4x4, mat2x2, mat3x3, mat4x4]
_MAT_2_N = Union[dmat2x2, dmat2x3, dmat2x4, imat2x2, imat2x3, imat2x4, mat2x2, mat2x3, mat2x4, umat2x2, umat2x3, umat2x4]
_MAT_3_N = Union[dmat3x2, dmat3x3, dmat3x4, imat3x2, imat3x3, imat3x4, mat3x2, mat3x3, mat3x4, umat3x2, umat3x3, umat3x4]
_MAT_4_N = Union[dmat4x2, dmat4x3, dmat4x4, imat4x2, imat4x3, imat4x4, mat4x2, mat4x3, mat4x4, umat4x2, umat4x3, umat4x4]


T = TypeVar('T')
_VT = TypeVar('_VT', bound=_VECTOR)
_V1T = TypeVar('_V1T', bound=_VECTOR_1)
_V2T = TypeVar('_V2T', bound=_VECTOR_2)
_V3T = TypeVar('_V3T', bound=_VECTOR_3)
_V4T = TypeVar('_V4T', bound=_VECTOR_4)
_FVT = TypeVar('_FVT', bound=_FLOAT_VECTOR)
_FV3T = TypeVar('_FV3T', bound=_FLOAT_VECTOR_3)
_IVT = TypeVar('_IVT', bound=_INT_VECTOR)
_iVT = TypeVar('_iVT', bound=_I_VECTOR)
_uVT = TypeVar('_uVT', bound=_U_VECTOR)
_QT = TypeVar('_QT', bound=_QUAT)
_MT = TypeVar('_MT', bound=_MATRIX)
_FMT = TypeVar('_FMT', bound=_FLOAT_MATRIX)
_SFMT = TypeVar('_SFMT', bound=_SQUARE_FLOAT_MATRIX)
_M2NT = TypeVar('_M2NT', bound=_MAT_2_N)
_M3NT = TypeVar('_M3NT', bound=_MAT_3_N)
_M4NT = TypeVar('_M4NT', bound=_MAT_4_N)


# func_common

@overload
def abs(x: _Number, /) -> float: ...
@overload
def abs(x: _VT, /) -> _VT: ...

@overload
def ceil(x: _Number, /) -> float: ...
@overload
def ceil(x: _VT, /) -> _VT: ...

@overload
def clamp(x: _Number, min: _Number, max: _Number, /) -> _Number: ...
@overload
def clamp(x: _VT, min: _Number, max: _Number, /) -> _VT: ...
@overload
def clamp(x: _VT, min: _VT, max: _VT, /) -> _VT: ...

@overload
def floatBitsToInt(x: float, /) -> int: ...
@overload
def floatBitsToInt(x: dmvec2, /) -> ivec2: ...
@overload
def floatBitsToInt(x: dmvec3, /) -> ivec3: ...
@overload
def floatBitsToInt(x: dmvec4, /) -> ivec4: ...
@overload
def floatBitsToInt(x: dvec1, /) -> ivec1: ...
@overload
def floatBitsToInt(x: dvec2, /) -> ivec2: ...
@overload
def floatBitsToInt(x: dvec3, /) -> ivec3: ...
@overload
def floatBitsToInt(x: dvec4, /) -> ivec4: ...
@overload
def floatBitsToInt(x: mvec2, /) -> ivec2: ...
@overload
def floatBitsToInt(x: mvec3, /) -> ivec3: ...
@overload
def floatBitsToInt(x: mvec4, /) -> ivec4: ...
@overload
def floatBitsToInt(x: vec1, /) -> ivec1: ...
@overload
def floatBitsToInt(x: vec2, /) -> ivec2: ...
@overload
def floatBitsToInt(x: vec3, /) -> ivec3: ...
@overload
def floatBitsToInt(x: vec4, /) -> ivec4: ...

@overload
def floatBitsToUint(x: float, /) -> int: ...
@overload
def floatBitsToUint(x: dmvec2, /) -> uvec2: ...
@overload
def floatBitsToUint(x: dmvec3, /) -> uvec3: ...
@overload
def floatBitsToUint(x: dmvec4, /) -> uvec4: ...
@overload
def floatBitsToUint(x: dvec1, /) -> uvec1: ...
@overload
def floatBitsToUint(x: dvec2, /) -> uvec2: ...
@overload
def floatBitsToUint(x: dvec3, /) -> uvec3: ...
@overload
def floatBitsToUint(x: dvec4, /) -> uvec4: ...
@overload
def floatBitsToUint(x: mvec2, /) -> uvec2: ...
@overload
def floatBitsToUint(x: mvec3, /) -> uvec3: ...
@overload
def floatBitsToUint(x: mvec4, /) -> uvec4: ...
@overload
def floatBitsToUint(x: vec1, /) -> uvec1: ...
@overload
def floatBitsToUint(x: vec2, /) -> uvec2: ...
@overload
def floatBitsToUint(x: vec3, /) -> uvec3: ...
@overload
def floatBitsToUint(x: vec4, /) -> uvec4: ...

@overload
def floor(x: _Number, /) -> float: ...
@overload
def floor(x: _VT, /) -> _VT: ...

def fma(a: _Number, b: _Number, c: _Number, /) -> float: ...

@overload
def fmax(x: _Number, y: _Number, /) -> float: ...
@overload
def fmax(a: _Number, b: _Number, c: _Number, /) -> float: ...
@overload
def fmax(a: _Number, b: _Number, c: _Number, d: _Number, /) -> float: ...
@overload
def fmax(x: _VT, y: _Number, /) -> _VT: ...
@overload
def fmax(x: _VT, y: _VT, /) -> _VT: ...
@overload
def fmax(a: _VT, b: _VT, c: _VT, /) -> _VT: ...
@overload
def fmax(a: _VT, b: _VT, c: _VT, d: _VT, /) -> _VT: ...

@overload
def fmin(x: _Number, y: _Number, /) -> float: ...
@overload
def fmin(a: _Number, b: _Number, c: _Number, /) -> float: ...
@overload
def fmin(a: _Number, b: _Number, c: _Number, d: _Number, /) -> float: ...
@overload
def fmin(x: _VT, y: _Number, /) -> _VT: ...
@overload
def fmin(x: _VT, y: _VT, /) -> _VT: ...
@overload
def fmin(a: _VT, b: _VT, c: _VT, /) -> _VT: ...
@overload
def fmin(a: _VT, b: _VT, c: _VT, d: _VT, /) -> _VT: ...

@overload
def fract(x: _Number, /) -> float: ...
@overload
def fract(x: _VT, /) -> _VT: ...

@overload
def frexp(x: _Number, /) -> Tuple[float, int]: ...
@overload
def frexp(x: dmvec2, exp: ivec2, /) -> dmvec2: ...
@overload
def frexp(x: dmvec3, exp: ivec3, /) -> dmvec3: ...
@overload
def frexp(x: dmvec4, exp: ivec4, /) -> dmvec4: ...
@overload
def frexp(x: dvec1, exp: ivec1, /) -> dvec1: ...
@overload
def frexp(x: dvec2, exp: ivec2, /) -> dvec2: ...
@overload
def frexp(x: dvec3, exp: ivec3, /) -> dvec3: ...
@overload
def frexp(x: dvec4, exp: ivec4, /) -> dvec4: ...
@overload
def frexp(x: mvec2, exp: ivec2, /) -> mvec2: ...
@overload
def frexp(x: mvec3, exp: ivec3, /) -> mvec3: ...
@overload
def frexp(x: mvec4, exp: ivec4, /) -> mvec4: ...
@overload
def frexp(x: vec1, exp: ivec1, /) -> vec1: ...
@overload
def frexp(x: vec2, exp: ivec2, /) -> vec2: ...
@overload
def frexp(x: vec3, exp: ivec3, /) -> vec3: ...
@overload
def frexp(x: vec4, exp: ivec4, /) -> vec4: ...

@overload
def intBitsToFloat(x: int, /) -> float: ...
@overload
def intBitsToFloat(x: imvec2, /) -> vec2: ...
@overload
def intBitsToFloat(x: imvec3, /) -> vec3: ...
@overload
def intBitsToFloat(x: imvec4, /) -> vec4: ...
@overload
def intBitsToFloat(x: ivec1, /) -> vec1: ...
@overload
def intBitsToFloat(x: ivec2, /) -> vec2: ...
@overload
def intBitsToFloat(x: ivec3, /) -> vec3: ...
@overload
def intBitsToFloat(x: ivec4, /) -> vec4: ...

@overload
def isinf(x: _Number, /) -> bool: ...
@overload
def isinf(x: dmvec2, /) -> bvec2: ...
@overload
def isinf(x: dmvec3, /) -> bvec3: ...
@overload
def isinf(x: dmvec4, /) -> bvec4: ...
@overload
def isinf(x: dvec1, /) -> bvec1: ...
@overload
def isinf(x: dvec2, /) -> bvec2: ...
@overload
def isinf(x: dvec3, /) -> bvec3: ...
@overload
def isinf(x: dvec4, /) -> bvec4: ...
@overload
def isinf(x: mvec2, /) -> bvec2: ...
@overload
def isinf(x: mvec3, /) -> bvec3: ...
@overload
def isinf(x: mvec4, /) -> bvec4: ...
@overload
def isinf(x: vec1, /) -> bvec1: ...
@overload
def isinf(x: vec2, /) -> bvec2: ...
@overload
def isinf(x: vec3, /) -> bvec3: ...
@overload
def isinf(x: vec4, /) -> bvec4: ...
@overload
def isinf(x: _QUAT, /) -> bvec4: ...

@overload
def isnan(x: _Number, /) -> bool: ...
@overload
def isnan(x: dmvec2, /) -> bvec2: ...
@overload
def isnan(x: dmvec3, /) -> bvec3: ...
@overload
def isnan(x: dmvec4, /) -> bvec4: ...
@overload
def isnan(x: dvec1, /) -> bvec1: ...
@overload
def isnan(x: dvec2, /) -> bvec2: ...
@overload
def isnan(x: dvec3, /) -> bvec3: ...
@overload
def isnan(x: dvec4, /) -> bvec4: ...
@overload
def isnan(x: mvec2, /) -> bvec2: ...
@overload
def isnan(x: mvec3, /) -> bvec3: ...
@overload
def isnan(x: mvec4, /) -> bvec4: ...
@overload
def isnan(x: vec1, /) -> bvec1: ...
@overload
def isnan(x: vec2, /) -> bvec2: ...
@overload
def isnan(x: vec3, /) -> bvec3: ...
@overload
def isnan(x: vec4, /) -> bvec4: ...
@overload
def isnan(x: _QUAT, /) -> bvec4: ...

@overload
def ldexp(x: _Number, exp: _Number, /) -> float: ...
@overload
def ldexp(x: dmvec2, exp: ivec2, /) -> dmvec2: ...
@overload
def ldexp(x: dmvec3, exp: ivec3, /) -> dmvec3: ...
@overload
def ldexp(x: dmvec4, exp: ivec4, /) -> dmvec4: ...
@overload
def ldexp(x: dvec1, exp: ivec1, /) -> dvec1: ...
@overload
def ldexp(x: dvec2, exp: ivec2, /) -> dvec2: ...
@overload
def ldexp(x: dvec3, exp: ivec3, /) -> dvec3: ...
@overload
def ldexp(x: dvec4, exp: ivec4, /) -> dvec4: ...
@overload
def ldexp(x: mvec2, exp: ivec2, /) -> mvec2: ...
@overload
def ldexp(x: mvec3, exp: ivec3, /) -> mvec3: ...
@overload
def ldexp(x: mvec4, exp: ivec4, /) -> mvec4: ...
@overload
def ldexp(x: vec1, exp: ivec1, /) -> vec1: ...
@overload
def ldexp(x: vec2, exp: ivec2, /) -> vec2: ...
@overload
def ldexp(x: vec3, exp: ivec3, /) -> vec3: ...
@overload
def ldexp(x: vec4, exp: ivec4, /) -> vec4: ...

@overload
def max(x: _Number, y: _Number, /) -> float: ...
@overload
def max(a: _Number, b: _Number, c: _Number, /) -> float: ...
@overload
def max(a: _Number, b: _Number, c: _Number, d: _Number, /) -> float: ...
@overload
def max(x: _VT, y: _Number, /) -> _VT: ...
@overload
def max(x: _VT, y: _VT, /) -> _VT: ...
@overload
def max(a: _VT, b: _VT, c: _VT, /) -> _VT: ...
@overload
def max(a: _VT, b: _VT, c: _VT, d: _VT, /) -> _VT: ...
@overload
def max(_: Iterable[T], /) -> T: ...

@overload
def min(x: _Number, y: _Number, /) -> float: ...
@overload
def min(a: _Number, b: _Number, c: _Number, /) -> float: ...
@overload
def min(a: _Number, b: _Number, c: _Number, d: _Number, /) -> float: ...
@overload
def min(x: _VT, y: _Number, /) -> _VT: ...
@overload
def min(x: _VT, y: _VT, /) -> _VT: ...
@overload
def min(a: _VT, b: _VT, c: _VT, /) -> _VT: ...
@overload
def min(a: _VT, b: _VT, c: _VT, d: _VT, /) -> _VT: ...
@overload
def min(_: Iterable[T], /) -> T: ...

@overload
def mix(x: _Number, y: _Number, a: _Number, /) -> float: ...
@overload
def mix(x: bvec1, y: bvec1, a: Union[vec1, bvec1], /) -> bvec1: ...
@overload
def mix(x: bvec2, y: bvec2, a: Union[vec2, bvec2], /) -> bvec2: ...
@overload
def mix(x: bvec3, y: bvec3, a: Union[vec3, bvec3], /) -> bvec3: ...
@overload
def mix(x: bvec4, y: bvec4, a: Union[vec4, bvec4], /) -> bvec4: ...
@overload
def mix(x: dmvec2, y: dmvec2, a: Union[vec2, bvec2], /) -> dmvec2: ...
@overload
def mix(x: dmvec3, y: dmvec3, a: Union[vec3, bvec3], /) -> dmvec3: ...
@overload
def mix(x: dmvec4, y: dmvec4, a: Union[vec4, bvec4], /) -> dmvec4: ...
@overload
def mix(x: dvec1, y: dvec1, a: Union[vec1, bvec1], /) -> dvec1: ...
@overload
def mix(x: dvec2, y: dvec2, a: Union[vec2, bvec2], /) -> dvec2: ...
@overload
def mix(x: dvec3, y: dvec3, a: Union[vec3, bvec3], /) -> dvec3: ...
@overload
def mix(x: dvec4, y: dvec4, a: Union[vec4, bvec4], /) -> dvec4: ...
@overload
def mix(x: i16vec1, y: i16vec1, a: Union[vec1, bvec1], /) -> i16vec1: ...
@overload
def mix(x: i16vec2, y: i16vec2, a: Union[vec2, bvec2], /) -> i16vec2: ...
@overload
def mix(x: i16vec3, y: i16vec3, a: Union[vec3, bvec3], /) -> i16vec3: ...
@overload
def mix(x: i16vec4, y: i16vec4, a: Union[vec4, bvec4], /) -> i16vec4: ...
@overload
def mix(x: i64vec1, y: i64vec1, a: Union[vec1, bvec1], /) -> i64vec1: ...
@overload
def mix(x: i64vec2, y: i64vec2, a: Union[vec2, bvec2], /) -> i64vec2: ...
@overload
def mix(x: i64vec3, y: i64vec3, a: Union[vec3, bvec3], /) -> i64vec3: ...
@overload
def mix(x: i64vec4, y: i64vec4, a: Union[vec4, bvec4], /) -> i64vec4: ...
@overload
def mix(x: i8vec1, y: i8vec1, a: Union[vec1, bvec1], /) -> i8vec1: ...
@overload
def mix(x: i8vec2, y: i8vec2, a: Union[vec2, bvec2], /) -> i8vec2: ...
@overload
def mix(x: i8vec3, y: i8vec3, a: Union[vec3, bvec3], /) -> i8vec3: ...
@overload
def mix(x: i8vec4, y: i8vec4, a: Union[vec4, bvec4], /) -> i8vec4: ...
@overload
def mix(x: imvec2, y: imvec2, a: Union[vec2, bvec2], /) -> imvec2: ...
@overload
def mix(x: imvec3, y: imvec3, a: Union[vec3, bvec3], /) -> imvec3: ...
@overload
def mix(x: imvec4, y: imvec4, a: Union[vec4, bvec4], /) -> imvec4: ...
@overload
def mix(x: ivec1, y: ivec1, a: Union[vec1, bvec1], /) -> ivec1: ...
@overload
def mix(x: ivec2, y: ivec2, a: Union[vec2, bvec2], /) -> ivec2: ...
@overload
def mix(x: ivec3, y: ivec3, a: Union[vec3, bvec3], /) -> ivec3: ...
@overload
def mix(x: ivec4, y: ivec4, a: Union[vec4, bvec4], /) -> ivec4: ...
@overload
def mix(x: mvec2, y: mvec2, a: Union[vec2, bvec2], /) -> mvec2: ...
@overload
def mix(x: mvec3, y: mvec3, a: Union[vec3, bvec3], /) -> mvec3: ...
@overload
def mix(x: mvec4, y: mvec4, a: Union[vec4, bvec4], /) -> mvec4: ...
@overload
def mix(x: u16vec1, y: u16vec1, a: Union[vec1, bvec1], /) -> u16vec1: ...
@overload
def mix(x: u16vec2, y: u16vec2, a: Union[vec2, bvec2], /) -> u16vec2: ...
@overload
def mix(x: u16vec3, y: u16vec3, a: Union[vec3, bvec3], /) -> u16vec3: ...
@overload
def mix(x: u16vec4, y: u16vec4, a: Union[vec4, bvec4], /) -> u16vec4: ...
@overload
def mix(x: u64vec1, y: u64vec1, a: Union[vec1, bvec1], /) -> u64vec1: ...
@overload
def mix(x: u64vec2, y: u64vec2, a: Union[vec2, bvec2], /) -> u64vec2: ...
@overload
def mix(x: u64vec3, y: u64vec3, a: Union[vec3, bvec3], /) -> u64vec3: ...
@overload
def mix(x: u64vec4, y: u64vec4, a: Union[vec4, bvec4], /) -> u64vec4: ...
@overload
def mix(x: u8vec1, y: u8vec1, a: Union[vec1, bvec1], /) -> u8vec1: ...
@overload
def mix(x: u8vec2, y: u8vec2, a: Union[vec2, bvec2], /) -> u8vec2: ...
@overload
def mix(x: u8vec3, y: u8vec3, a: Union[vec3, bvec3], /) -> u8vec3: ...
@overload
def mix(x: u8vec4, y: u8vec4, a: Union[vec4, bvec4], /) -> u8vec4: ...
@overload
def mix(x: umvec2, y: umvec2, a: Union[vec2, bvec2], /) -> umvec2: ...
@overload
def mix(x: umvec3, y: umvec3, a: Union[vec3, bvec3], /) -> umvec3: ...
@overload
def mix(x: umvec4, y: umvec4, a: Union[vec4, bvec4], /) -> umvec4: ...
@overload
def mix(x: uvec1, y: uvec1, a: Union[vec1, bvec1], /) -> uvec1: ...
@overload
def mix(x: uvec2, y: uvec2, a: Union[vec2, bvec2], /) -> uvec2: ...
@overload
def mix(x: uvec3, y: uvec3, a: Union[vec3, bvec3], /) -> uvec3: ...
@overload
def mix(x: uvec4, y: uvec4, a: Union[vec4, bvec4], /) -> uvec4: ...
@overload
def mix(x: vec1, y: vec1, a: Union[vec1, bvec1], /) -> vec1: ...
@overload
def mix(x: vec2, y: vec2, a: Union[vec2, bvec2], /) -> vec2: ...
@overload
def mix(x: vec3, y: vec3, a: Union[vec3, bvec3], /) -> vec3: ...
@overload
def mix(x: vec4, y: vec4, a: Union[vec4, bvec4], /) -> vec4: ...
@overload
def mix(x: dmat2x2, y: dmat2x2, a: Union[mat2x2, _Number], /) -> dmat2x2: ...
@overload
def mix(x: dmat2x3, y: dmat2x3, a: Union[mat2x3, _Number], /) -> dmat2x3: ...
@overload
def mix(x: dmat2x4, y: dmat2x4, a: Union[mat2x4, _Number], /) -> dmat2x4: ...
@overload
def mix(x: dmat3x2, y: dmat3x2, a: Union[mat3x2, _Number], /) -> dmat3x2: ...
@overload
def mix(x: dmat3x3, y: dmat3x3, a: Union[mat3x3, _Number], /) -> dmat3x3: ...
@overload
def mix(x: dmat3x4, y: dmat3x4, a: Union[mat3x4, _Number], /) -> dmat3x4: ...
@overload
def mix(x: dmat4x2, y: dmat4x2, a: Union[mat4x2, _Number], /) -> dmat4x2: ...
@overload
def mix(x: dmat4x3, y: dmat4x3, a: Union[mat4x3, _Number], /) -> dmat4x3: ...
@overload
def mix(x: dmat4x4, y: dmat4x4, a: Union[mat4x4, _Number], /) -> dmat4x4: ...
@overload
def mix(x: imat2x2, y: imat2x2, a: Union[mat2x2, _Number], /) -> imat2x2: ...
@overload
def mix(x: imat2x3, y: imat2x3, a: Union[mat2x3, _Number], /) -> imat2x3: ...
@overload
def mix(x: imat2x4, y: imat2x4, a: Union[mat2x4, _Number], /) -> imat2x4: ...
@overload
def mix(x: imat3x2, y: imat3x2, a: Union[mat3x2, _Number], /) -> imat3x2: ...
@overload
def mix(x: imat3x3, y: imat3x3, a: Union[mat3x3, _Number], /) -> imat3x3: ...
@overload
def mix(x: imat3x4, y: imat3x4, a: Union[mat3x4, _Number], /) -> imat3x4: ...
@overload
def mix(x: imat4x2, y: imat4x2, a: Union[mat4x2, _Number], /) -> imat4x2: ...
@overload
def mix(x: imat4x3, y: imat4x3, a: Union[mat4x3, _Number], /) -> imat4x3: ...
@overload
def mix(x: imat4x4, y: imat4x4, a: Union[mat4x4, _Number], /) -> imat4x4: ...
@overload
def mix(x: mat2x2, y: mat2x2, a: Union[mat2x2, _Number], /) -> mat2x2: ...
@overload
def mix(x: mat2x3, y: mat2x3, a: Union[mat2x3, _Number], /) -> mat2x3: ...
@overload
def mix(x: mat2x4, y: mat2x4, a: Union[mat2x4, _Number], /) -> mat2x4: ...
@overload
def mix(x: mat3x2, y: mat3x2, a: Union[mat3x2, _Number], /) -> mat3x2: ...
@overload
def mix(x: mat3x3, y: mat3x3, a: Union[mat3x3, _Number], /) -> mat3x3: ...
@overload
def mix(x: mat3x4, y: mat3x4, a: Union[mat3x4, _Number], /) -> mat3x4: ...
@overload
def mix(x: mat4x2, y: mat4x2, a: Union[mat4x2, _Number], /) -> mat4x2: ...
@overload
def mix(x: mat4x3, y: mat4x3, a: Union[mat4x3, _Number], /) -> mat4x3: ...
@overload
def mix(x: mat4x4, y: mat4x4, a: Union[mat4x4, _Number], /) -> mat4x4: ...
@overload
def mix(x: umat2x2, y: umat2x2, a: Union[mat2x2, _Number], /) -> umat2x2: ...
@overload
def mix(x: umat2x3, y: umat2x3, a: Union[mat2x3, _Number], /) -> umat2x3: ...
@overload
def mix(x: umat2x4, y: umat2x4, a: Union[mat2x4, _Number], /) -> umat2x4: ...
@overload
def mix(x: umat3x2, y: umat3x2, a: Union[mat3x2, _Number], /) -> umat3x2: ...
@overload
def mix(x: umat3x3, y: umat3x3, a: Union[mat3x3, _Number], /) -> umat3x3: ...
@overload
def mix(x: umat3x4, y: umat3x4, a: Union[mat3x4, _Number], /) -> umat3x4: ...
@overload
def mix(x: umat4x2, y: umat4x2, a: Union[mat4x2, _Number], /) -> umat4x2: ...
@overload
def mix(x: umat4x3, y: umat4x3, a: Union[mat4x3, _Number], /) -> umat4x3: ...
@overload
def mix(x: umat4x4, y: umat4x4, a: Union[mat4x4, _Number], /) -> umat4x4: ...
@overload
def mix(x: _QT, y: _QT, a: _Number, /) -> _QT: ...

@overload
def modf(x: _Number, /) -> Tuple[float, float]: ...
@overload
def modf(x: _FVT, i: _FVT, /) -> _FVT: ...

@overload
def round(x: _Number, /) -> float: ...
@overload
def round(x: _FVT, i: _FVT, /) -> _FVT: ...

@overload
def roundEven(x: _Number, /) -> float: ...
@overload
def roundEven(x: _FVT, i: _FVT, /) -> _FVT: ...

@overload
def sign(x: _Number, /) -> float: ...
@overload
def sign(x: _FVT, i: _FVT, /) -> _FVT: ...

@overload
def smoothstep(edge0: _Number, edge1: _Number, x: _Number, /) -> float: ...
@overload
def smoothstep(edge0: _Number, edge1: _Number, x: _FVT, /) -> _FVT: ...
@overload
def smoothstep(edge0: _FVT, edge1: _FVT, x: _FVT, /) -> _FVT: ...

@overload
def step(edge: _Number, x: _Number, /) -> float: ...
@overload
def step(edge: _Number, x: _VT, /) -> _VT: ...
@overload
def step(edge: _VT, x: _VT, /) -> _VT: ...

@overload
def trunc(x: _Number, /) -> float: ...
@overload
def trunc(x: _FVT, /) -> _FVT: ...

@overload
def uintBitsToFloat(x: int, /) -> float: ...
@overload
def uintBitsToFloat(x: umvec2, /) -> vec2: ...
@overload
def uintBitsToFloat(x: umvec3, /) -> vec3: ...
@overload
def uintBitsToFloat(x: umvec4, /) -> vec4: ...
@overload
def uintBitsToFloat(x: uvec1, /) -> vec1: ...
@overload
def uintBitsToFloat(x: uvec2, /) -> vec2: ...
@overload
def uintBitsToFloat(x: uvec3, /) -> vec3: ...
@overload
def uintBitsToFloat(x: uvec4, /) -> vec4: ...


# func_exponential

@overload
def exp(x: _Number, /) -> float: ...
@overload
def exp(x: _FVT, /) -> _FVT: ...
@overload
def exp(x: _QT, /) -> _QT: ...

@overload
def exp2(x: _Number, /) -> float: ...
@overload
def exp2(x: _FVT, /) -> _FVT: ...

@overload
def inversesqrt(x: _Number, /) -> float: ...
@overload
def inversesqrt(x: _FVT, /) -> _FVT: ...

@overload
def log(x: _Number, /) -> float: ...
@overload
def log(x: _FVT, /) -> _FVT: ...
@overload
def log(x: _QT, /) -> _QT: ...

@overload
def log2(x: _Number, /) -> float: ...
@overload
def log2(x: _FVT, /) -> _FVT: ...

@overload
def pow(base: _Number, exponent: _Number, /) -> float: ...
@overload
def pow(base: _FVT, exponent: _FVT, /) -> _FVT: ...
@overload
def pow(base: _QT, exponent: _QT, /) -> _QT: ...

@overload
def sqrt(x: _Number, /) -> float: ...
@overload
def sqrt(x: _FVT, /) -> _FVT: ...
@overload
def sqrt(x: _QT, /) -> _QT: ...


# func_geometric

@overload
def cross(x: _FV3T, y: _FV3T, /) -> _FV3T: ...
@overload
def cross(x: _QT, y: _QT, /) -> _QT: ...

@overload
def distance(p0: _Number, p1: _Number, /) -> float: ...
@overload
def distance(p0: _FVT, p1: _FVT, /) -> _FVT: ...

@overload
def dot(x: _Number, y: _Number, /) -> float: ...
@overload
def dot(x: _FVT, y: _FVT, /) -> float: ...
@overload
def dot(x: _QT, y: _QT, /) -> float: ...

@overload
def faceforward(N: _Number, I: _Number, Nref: float, /) -> float: ...
@overload
def faceforward(N: _FVT, I: _FVT, Nref: _FVT, /) -> _FVT: ...

@overload
def length(x: _Number, /) -> float: ...
@overload
def length(x: _FVT, /) -> float: ...
@overload
def length(x: _QT, /) -> float: ...

@overload
def normalize(x: _FVT, /) -> _FVT: ...
@overload
def normalize(x: _QT, /) -> _QT: ...

@overload
def reflect(I: _Number, N: _Number, /) -> float: ...
@overload
def reflect(I: _FVT, N: _FVT, /) -> _FVT: ...

@overload
def refract(I: _Number, N: _Number, eta: float, /) -> float: ...
@overload
def refract(I: _FVT, N: _FVT, eta: float, /) -> _FVT: ...


# func_integer

@overload
def bitCount(v: int, /) -> int: ...
@overload
def bitCount(v: i16vec1, /) -> ivec1: ...
@overload
def bitCount(v: i16vec2, /) -> ivec2: ...
@overload
def bitCount(v: i16vec3, /) -> ivec3: ...
@overload
def bitCount(v: i16vec4, /) -> ivec4: ...
@overload
def bitCount(v: i64vec1, /) -> ivec1: ...
@overload
def bitCount(v: i64vec2, /) -> ivec2: ...
@overload
def bitCount(v: i64vec3, /) -> ivec3: ...
@overload
def bitCount(v: i64vec4, /) -> ivec4: ...
@overload
def bitCount(v: i8vec1, /) -> ivec1: ...
@overload
def bitCount(v: i8vec2, /) -> ivec2: ...
@overload
def bitCount(v: i8vec3, /) -> ivec3: ...
@overload
def bitCount(v: i8vec4, /) -> ivec4: ...
@overload
def bitCount(v: imvec2, /) -> ivec2: ...
@overload
def bitCount(v: imvec3, /) -> ivec3: ...
@overload
def bitCount(v: imvec4, /) -> ivec4: ...
@overload
def bitCount(v: ivec1, /) -> ivec1: ...
@overload
def bitCount(v: ivec2, /) -> ivec2: ...
@overload
def bitCount(v: ivec3, /) -> ivec3: ...
@overload
def bitCount(v: ivec4, /) -> ivec4: ...
@overload
def bitCount(v: u16vec1, /) -> ivec1: ...
@overload
def bitCount(v: u16vec2, /) -> ivec2: ...
@overload
def bitCount(v: u16vec3, /) -> ivec3: ...
@overload
def bitCount(v: u16vec4, /) -> ivec4: ...
@overload
def bitCount(v: u64vec1, /) -> ivec1: ...
@overload
def bitCount(v: u64vec2, /) -> ivec2: ...
@overload
def bitCount(v: u64vec3, /) -> ivec3: ...
@overload
def bitCount(v: u64vec4, /) -> ivec4: ...
@overload
def bitCount(v: u8vec1, /) -> ivec1: ...
@overload
def bitCount(v: u8vec2, /) -> ivec2: ...
@overload
def bitCount(v: u8vec3, /) -> ivec3: ...
@overload
def bitCount(v: u8vec4, /) -> ivec4: ...
@overload
def bitCount(v: umvec2, /) -> ivec2: ...
@overload
def bitCount(v: umvec3, /) -> ivec3: ...
@overload
def bitCount(v: umvec4, /) -> ivec4: ...
@overload
def bitCount(v: uvec1, /) -> ivec1: ...
@overload
def bitCount(v: uvec2, /) -> ivec2: ...
@overload
def bitCount(v: uvec3, /) -> ivec3: ...
@overload
def bitCount(v: uvec4, /) -> ivec4: ...

@overload
def bitfieldExtract(value: int, offset: int, bits: int, /) -> int: ...
@overload
def bitfieldExtract(value: _IVT, offset: int, bits: int, /) -> _IVT: ...

@overload
def bitfieldInsert(base: int, insert: int, offset: int, bits: int, /) -> int: ...
@overload
def bitfieldInsert(base: _IVT, insert: _IVT, offset: int, bits: int, /) -> _IVT: ...

@overload
def bitfieldReverse(value: int, /) -> int: ...
@overload
def bitfieldReverse(value: _IVT, /) -> _IVT: ...

@overload
def findLSB(value: int, /) -> int: ...
@overload
def findLSB(value: _IVT, /) -> _IVT: ...

@overload
def findMSB(value: int, /) -> int: ...
@overload
def findMSB(value: _IVT, /) -> _IVT: ...

def imulExtended(x: _iVT, y: _iVT, msb: _iVT, lsb: _iVT, /) -> None: ...

def uaddCarry(x: _uVT, y: _uVT, carry: _uVT, /) -> _uVT: ...

def umulExtended(x: _uVT, y: _uVT, msb: _uVT, lsb: _uVT, /) -> None: ...

def usubBorrow(x: _uVT, y: _uVT, borrow: _uVT, /) -> _uVT: ...


# func_matrix

def determinant(m: _SQUARE_FLOAT_MATRIX, /) -> float: ...

@overload
def inverse(m: _SFMT, /) -> _SFMT: ...
@overload
def inverse(q: _QT, /) -> _QT: ...

def matrixCompMult(x: _FMT, y: _FMT) -> _FMT: ...

@overload
def outerProduct(c: vec2, r: vec2, /) -> mat2x2: ...
@overload
def outerProduct(c: vec2, r: vec3, /) -> mat3x2: ...
@overload
def outerProduct(c: vec2, r: vec4, /) -> mat4x2: ...
@overload
def outerProduct(c: vec3, r: vec2, /) -> mat2x3: ...
@overload
def outerProduct(c: vec3, r: vec3, /) -> mat3x3: ...
@overload
def outerProduct(c: vec3, r: vec4, /) -> mat4x3: ...
@overload
def outerProduct(c: vec4, r: vec2, /) -> mat2x4: ...
@overload
def outerProduct(c: vec4, r: vec3, /) -> mat3x4: ...
@overload
def outerProduct(c: vec4, r: vec4, /) -> mat4x4: ...
@overload
def outerProduct(c: dvec2, r: dvec2, /) -> dmat2x2: ...
@overload
def outerProduct(c: dvec2, r: dvec3, /) -> dmat3x2: ...
@overload
def outerProduct(c: dvec2, r: dvec4, /) -> dmat4x2: ...
@overload
def outerProduct(c: dvec3, r: dvec2, /) -> dmat2x3: ...
@overload
def outerProduct(c: dvec3, r: dvec3, /) -> dmat3x3: ...
@overload
def outerProduct(c: dvec3, r: dvec4, /) -> dmat4x3: ...
@overload
def outerProduct(c: dvec4, r: dvec2, /) -> dmat2x4: ...
@overload
def outerProduct(c: dvec4, r: dvec3, /) -> dmat3x4: ...
@overload
def outerProduct(c: dvec4, r: dvec4, /) -> dmat4x4: ...

@overload
def transpose(x: dmat2x2, /) -> dmat2x2: ...
@overload
def transpose(x: dmat2x3, /) -> dmat3x2: ...
@overload
def transpose(x: dmat2x4, /) -> dmat4x2: ...
@overload
def transpose(x: dmat3x2, /) -> dmat2x3: ...
@overload
def transpose(x: dmat3x3, /) -> dmat3x3: ...
@overload
def transpose(x: dmat3x4, /) -> dmat4x3: ...
@overload
def transpose(x: dmat4x2, /) -> dmat2x4: ...
@overload
def transpose(x: dmat4x3, /) -> dmat3x4: ...
@overload
def transpose(x: dmat4x4, /) -> dmat4x4: ...
@overload
def transpose(x: imat2x2, /) -> imat2x2: ...
@overload
def transpose(x: imat2x3, /) -> imat3x2: ...
@overload
def transpose(x: imat2x4, /) -> imat4x2: ...
@overload
def transpose(x: imat3x2, /) -> imat2x3: ...
@overload
def transpose(x: imat3x3, /) -> imat3x3: ...
@overload
def transpose(x: imat3x4, /) -> imat4x3: ...
@overload
def transpose(x: imat4x2, /) -> imat2x4: ...
@overload
def transpose(x: imat4x3, /) -> imat3x4: ...
@overload
def transpose(x: imat4x4, /) -> imat4x4: ...
@overload
def transpose(x: mat2x2, /) -> mat2x2: ...
@overload
def transpose(x: mat2x3, /) -> mat3x2: ...
@overload
def transpose(x: mat2x4, /) -> mat4x2: ...
@overload
def transpose(x: mat3x2, /) -> mat2x3: ...
@overload
def transpose(x: mat3x3, /) -> mat3x3: ...
@overload
def transpose(x: mat3x4, /) -> mat4x3: ...
@overload
def transpose(x: mat4x2, /) -> mat2x4: ...
@overload
def transpose(x: mat4x3, /) -> mat3x4: ...
@overload
def transpose(x: mat4x4, /) -> mat4x4: ...
@overload
def transpose(x: umat2x2, /) -> umat2x2: ...
@overload
def transpose(x: umat2x3, /) -> umat3x2: ...
@overload
def transpose(x: umat2x4, /) -> umat4x2: ...
@overload
def transpose(x: umat3x2, /) -> umat2x3: ...
@overload
def transpose(x: umat3x3, /) -> umat3x3: ...
@overload
def transpose(x: umat3x4, /) -> umat4x3: ...
@overload
def transpose(x: umat4x2, /) -> umat2x4: ...
@overload
def transpose(x: umat4x3, /) -> umat3x4: ...
@overload
def transpose(x: umat4x4, /) -> umat4x4: ...


# func_packing

def packDouble2x32(v: uvec2, /) -> float: ...

def packHalf2x16(v: vec2, /) -> int: ...

def packSnorm2x16(v: vec2, /) -> int: ...

def packSnorm4x8(v: vec4, /) -> int: ...

def packUnorm2x16(v: vec2, /) -> int: ...

def packUnorm4x8(v: vec4, /) -> int: ...

def unpackDouble2x32(v: float, /) -> uvec2: ...

def unpackHalf2x16(v: int, /) -> vec2: ...

def unpackSnorm2x16(p: int, /) -> vec2: ...

def unpackSnorm4x8(p: int, /) -> vec4: ...

def unpackUnorm2x16(p: int, /) -> vec2: ...

def unpackUnorm4x8(p: int, /) -> vec4: ...


# func_trigonometric

@overload
def acos(x: _Number, /) -> float: ...
@overload
def acos(x: _FVT, /) -> _FVT: ...

@overload
def acosh(x: _Number, /) -> float: ...
@overload
def acosh(x: _FVT, /) -> _FVT: ...

@overload
def asin(x: _Number, /) -> float: ...
@overload
def asin(x: _FVT, /) -> _FVT: ...

@overload
def asinh(x: _Number, /) -> float: ...
@overload
def asinh(x: _FVT, /) -> _FVT: ...

@overload
def atan(y_over_x: _Number, /) -> float: ...
@overload
def atan(y_over_x: _FVT, /) -> _FVT: ...
@overload
def atan(y: _Number, x: _Number, /) -> float: ...
@overload
def atan(y: _FVT, x: _FVT, /) -> _FVT: ...

@overload
def atanh(x: _Number, /) -> float: ...
@overload
def atanh(x: _FVT, /) -> _FVT: ...

@overload
def cos(angle: _Number, /) -> float: ...
@overload
def cos(angle: _FVT, /) -> _FVT: ...

@overload
def cosh(angle: _Number, /) -> float: ...
@overload
def cosh(angle: _FVT, /) -> _FVT: ...

@overload
def degrees(angle: _Number, /) -> float: ...
@overload
def degrees(angle: _FVT, /) -> _FVT: ...

@overload
def radians(angle: _Number, /) -> float: ...
@overload
def radians(angle: _FVT, /) -> _FVT: ...

@overload
def sin(x: _Number, /) -> float: ...
@overload
def sin(x: _FVT, /) -> _FVT: ...

@overload
def sinh(x: _Number, /) -> float: ...
@overload
def sinh(x: _FVT, /) -> _FVT: ...

@overload
def tan(x: _Number, /) -> float: ...
@overload
def tan(x: _FVT, /) -> _FVT: ...

@overload
def tanh(x: _Number, /) -> float: ...
@overload
def tanh(x: _FVT, /) -> _FVT: ...


# func_vector_relational

def all(v: _BOOL_VECTOR, /) -> bool: ...

def any(v: _BOOL_VECTOR, /) -> bool: ...

@overload
def equal(x: _V1T, y: _V1T, /) -> bvec1: ...
@overload
def equal(x: _V2T, y: _V2T, /) -> bvec2: ...
@overload
def equal(x: _V3T, y: _V3T, /) -> bvec3: ...
@overload
def equal(x: _V4T, y: _V4T, /) -> bvec4: ...
@overload
def equal(x: _QT, y: _QT, /) -> bvec4: ...
@overload
def equal(x: _M2NT, y: _M2NT, /) -> bvec2: ...
@overload
def equal(x: _M3NT, y: _M3NT, /) -> bvec3: ...
@overload
def equal(x: _M4NT, y: _M4NT, /) -> bvec4: ...
@overload
def equal(x: _Number, y: _Number, ULPs: int, /) -> int: ...
@overload
def equal(x: _V1T, y: _V1T, ULPs: _Number, /) -> bvec1: ...
@overload
def equal(x: _V2T, y: _V2T, ULPs: _Number, /) -> bvec2: ...
@overload
def equal(x: _V3T, y: _V3T, ULPs: _Number, /) -> bvec3: ...
@overload
def equal(x: _V4T, y: _V4T, ULPs: _Number, /) -> bvec4: ...
@overload
def equal(x: _M2NT, y: _M2NT, ULPs: _Number, /) -> bvec2: ...
@overload
def equal(x: _M3NT, y: _M3NT, ULPs: _Number, /) -> bvec3: ...
@overload
def equal(x: _M4NT, y: _M4NT, ULPs: _Number, /) -> bvec4: ...
@overload
def equal(x: _V1T, y: _V1T, ULPs: ivec1, /) -> bvec1: ...
@overload
def equal(x: _V2T, y: _V2T, ULPs: ivec2, /) -> bvec2: ...
@overload
def equal(x: _V3T, y: _V3T, ULPs: ivec3, /) -> bvec3: ...
@overload
def equal(x: _V4T, y: _V4T, ULPs: ivec4, /) -> bvec4: ...
@overload
def equal(x: _M2NT, y: _M2NT, ULPs: ivec2, /) -> bvec2: ...
@overload
def equal(x: _M3NT, y: _M3NT, ULPs: ivec3, /) -> bvec3: ...
@overload
def equal(x: _M4NT, y: _M4NT, ULPs: ivec4, /) -> bvec4: ...
@overload
def equal(x: _V1T, y: _V1T, epsilon: vec1, /) -> bvec1: ...
@overload
def equal(x: _V2T, y: _V2T, epsilon: vec2, /) -> bvec2: ...
@overload
def equal(x: _V3T, y: _V3T, epsilon: vec3, /) -> bvec3: ...
@overload
def equal(x: _V4T, y: _V4T, epsilon: vec4, /) -> bvec4: ...
@overload
def equal(x: _M2NT, y: _M2NT, epsilon: vec2, /) -> bvec2: ...
@overload
def equal(x: _M3NT, y: _M3NT, epsilon: vec3, /) -> bvec3: ...
@overload
def equal(x: _M4NT, y: _M4NT, epsilon: vec4, /) -> bvec4: ...

@overload
def greaterThan(x: _V1T, y: _V1T, /) -> bvec1: ...
@overload
def greaterThan(x: _V2T, y: _V2T, /) -> bvec2: ...
@overload
def greaterThan(x: _V3T, y: _V3T, /) -> bvec3: ...
@overload
def greaterThan(x: _V4T, y: _V4T, /) -> bvec4: ...
@overload
def greaterThan(x: _QT, y: _QT, /) -> bvec4: ...

@overload
def greaterThanEqual(x: _V1T, y: _V1T, /) -> bvec1: ...
@overload
def greaterThanEqual(x: _V2T, y: _V2T, /) -> bvec2: ...
@overload
def greaterThanEqual(x: _V3T, y: _V3T, /) -> bvec3: ...
@overload
def greaterThanEqual(x: _V4T, y: _V4T, /) -> bvec4: ...
@overload
def greaterThanEqual(x: _QT, y: _QT, /) -> bvec4: ...

@overload
def lessThan(x: _V1T, y: _V1T, /) -> bvec1: ...
@overload
def lessThan(x: _V2T, y: _V2T, /) -> bvec2: ...
@overload
def lessThan(x: _V3T, y: _V3T, /) -> bvec3: ...
@overload
def lessThan(x: _V4T, y: _V4T, /) -> bvec4: ...
@overload
def lessThan(x: _QT, y: _QT, /) -> bvec4: ...

@overload
def lessThanEqual(x: _V1T, y: _V1T, /) -> bvec1: ...
@overload
def lessThanEqual(x: _V2T, y: _V2T, /) -> bvec2: ...
@overload
def lessThanEqual(x: _V3T, y: _V3T, /) -> bvec3: ...
@overload
def lessThanEqual(x: _V4T, y: _V4T, /) -> bvec4: ...
@overload
def lessThanEqual(x: _QT, y: _QT, /) -> bvec4: ...

@overload
def notEqual(x: _V1T, y: _V1T, /) -> bvec1: ...
@overload
def notEqual(x: _V2T, y: _V2T, /) -> bvec2: ...
@overload
def notEqual(x: _V3T, y: _V3T, /) -> bvec3: ...
@overload
def notEqual(x: _V4T, y: _V4T, /) -> bvec4: ...
@overload
def notEqual(x: _QT, y: _QT, /) -> bvec4: ...

def not_(v: _BOOL_VECTOR, /) -> bool: ...


# other

def add(a: Any, b: Any, /) -> Any: ...
def and_(a: Any, b: Any, /) -> Any: ...
def cmp(a: Any, b: Any, /) -> Any: ...
def div(a: Any, b: Any, /) -> Any: ...
def floordiv(a: Any, b: Any, /) -> Any: ...
def if_else(b: Any, x: Any, y: Any, /) -> Any: ...
def inv(a: Any, /) -> Any: ...
def lshift(a: Any, b: Any, /) -> Any: ...
def mul(a: Any, b: Any, /) -> Any: ...
def neg(a: Any, /) -> Any: ...
def or_(a: Any, b: Any, /) -> Any: ...
def pos(a: Any, /) -> Any: ...
def rshift(a: Any, b: Any, /) -> Any: ...
def sub(a: Any, b: Any, /) -> Any: ...
def xor(a: Any, b: Any, /) -> Any: ...


# color_space

@overload
def convertLinearToSRGB(ColorLinear: _FVT) -> _FVT: ...
@overload
def convertLinearToSRGB(ColorLinear: _FVT, Gamma: _Number) -> _FVT: ...

@overload
def convertSRGBToLinear(ColorLinear: _FVT) -> _FVT: ...
@overload
def convertSRGBToLinear(ColorLinear: _FVT, Gamma: _Number) -> _FVT: ...


# constants

def e() -> float: ...
def epsilon() -> float: ...
def euler() -> float: ...
def four_over_pi() -> float: ...
def golden_ratio() -> float: ...
def half_pi() -> float: ...
def ln_ln_two() -> float: ...
def ln_ten() -> float: ...
def ln_two() -> float: ...
def one() -> float: ...
def one_over_pi() -> float: ...
def one_over_root_two() -> float: ...
def one_over_two_pi() -> float: ...
def pi() -> float: ...
def quarter_pi() -> float: ...
def root_five() -> float: ...
def root_half_pi() -> float: ...
def root_ln_four() -> float: ...
def root_pi() -> float: ...
def root_three() -> float: ...
def root_two() -> float: ...
def root_two_pi() -> float: ...
def third() -> float: ...
def three_over_two_pi() -> float: ...
def two_over_pi() -> float: ...
def two_over_root_pi() -> float: ...
def two_pi() -> float: ...
def two_thirds() -> float: ...
def zero() -> float: ...


# epsilon

@overload
def epsilonEqual(x: _Number, y: _Number, epsilon: _Number, /) -> bool: ...
@overload
def epsilonEqual(x: dmvec2, y: dmvec2, epsilon: _Number, /) -> bvec2: ...
@overload
def epsilonEqual(x: dmvec3, y: dmvec3, epsilon: _Number, /) -> bvec3: ...
@overload
def epsilonEqual(x: dmvec4, y: dmvec4, epsilon: _Number, /) -> bvec4: ...
@overload
def epsilonEqual(x: dvec1, y: dvec1, epsilon: _Number, /) -> bvec1: ...
@overload
def epsilonEqual(x: dvec2, y: dvec2, epsilon: _Number, /) -> bvec2: ...
@overload
def epsilonEqual(x: dvec3, y: dvec3, epsilon: _Number, /) -> bvec3: ...
@overload
def epsilonEqual(x: dvec4, y: dvec4, epsilon: _Number, /) -> bvec4: ...
@overload
def epsilonEqual(x: mvec2, y: mvec2, epsilon: _Number, /) -> bvec2: ...
@overload
def epsilonEqual(x: mvec3, y: mvec3, epsilon: _Number, /) -> bvec3: ...
@overload
def epsilonEqual(x: mvec4, y: mvec4, epsilon: _Number, /) -> bvec4: ...
@overload
def epsilonEqual(x: vec1, y: vec1, epsilon: _Number, /) -> bvec1: ...
@overload
def epsilonEqual(x: vec2, y: vec2, epsilon: _Number, /) -> bvec2: ...
@overload
def epsilonEqual(x: vec3, y: vec3, epsilon: _Number, /) -> bvec3: ...
@overload
def epsilonEqual(x: vec4, y: vec4, epsilon: _Number, /) -> bvec4: ...

@overload
def epsilonNotEqual(x: _Number, y: _Number, epsilon: _Number) -> bool: ...
@overload
def epsilonNotEqual(x: dmvec2, y: dmvec2, epsilon: _Number, /) -> bvec2: ...
@overload
def epsilonNotEqual(x: dmvec3, y: dmvec3, epsilon: _Number, /) -> bvec3: ...
@overload
def epsilonNotEqual(x: dmvec4, y: dmvec4, epsilon: _Number, /) -> bvec4: ...
@overload
def epsilonNotEqual(x: dvec1, y: dvec1, epsilon: _Number, /) -> bvec1: ...
@overload
def epsilonNotEqual(x: dvec2, y: dvec2, epsilon: _Number, /) -> bvec2: ...
@overload
def epsilonNotEqual(x: dvec3, y: dvec3, epsilon: _Number, /) -> bvec3: ...
@overload
def epsilonNotEqual(x: dvec4, y: dvec4, epsilon: _Number, /) -> bvec4: ...
@overload
def epsilonNotEqual(x: mvec2, y: mvec2, epsilon: _Number, /) -> bvec2: ...
@overload
def epsilonNotEqual(x: mvec3, y: mvec3, epsilon: _Number, /) -> bvec3: ...
@overload
def epsilonNotEqual(x: mvec4, y: mvec4, epsilon: _Number, /) -> bvec4: ...
@overload
def epsilonNotEqual(x: vec1, y: vec1, epsilon: _Number, /) -> bvec1: ...
@overload
def epsilonNotEqual(x: vec2, y: vec2, epsilon: _Number, /) -> bvec2: ...
@overload
def epsilonNotEqual(x: vec3, y: vec3, epsilon: _Number, /) -> bvec3: ...
@overload
def epsilonNotEqual(x: vec4, y: vec4, epsilon: _Number, /) -> bvec4: ...


# integer

@overload
def iround(x: _Number, /) -> int: ...
@overload
def iround(x: dmvec2, /) -> ivec2: ...
@overload
def iround(x: dmvec3, /) -> ivec3: ...
@overload
def iround(x: dmvec4, /) -> ivec4: ...
@overload
def iround(x: dvec1, /) -> ivec1: ...
@overload
def iround(x: dvec2, /) -> ivec2: ...
@overload
def iround(x: dvec3, /) -> ivec3: ...
@overload
def iround(x: dvec4, /) -> ivec4: ...
@overload
def iround(x: mvec2, /) -> ivec2: ...
@overload
def iround(x: mvec3, /) -> ivec3: ...
@overload
def iround(x: mvec4, /) -> ivec4: ...
@overload
def iround(x: vec1, /) -> ivec1: ...
@overload
def iround(x: vec2, /) -> ivec2: ...
@overload
def iround(x: vec3, /) -> ivec3: ...
@overload
def iround(x: vec4, /) -> ivec4: ...

@overload
def uround(x: _Number, /) -> int: ...
@overload
def uround(x: dmvec2, /) -> uvec2: ...
@overload
def uround(x: dmvec3, /) -> uvec3: ...
@overload
def uround(x: dmvec4, /) -> uvec4: ...
@overload
def uround(x: dvec1, /) -> uvec1: ...
@overload
def uround(x: dvec2, /) -> uvec2: ...
@overload
def uround(x: dvec3, /) -> uvec3: ...
@overload
def uround(x: dvec4, /) -> uvec4: ...
@overload
def uround(x: mvec2, /) -> uvec2: ...
@overload
def uround(x: mvec3, /) -> uvec3: ...
@overload
def uround(x: mvec4, /) -> uvec4: ...
@overload
def uround(x: vec1, /) -> uvec1: ...
@overload
def uround(x: vec2, /) -> uvec2: ...
@overload
def uround(x: vec3, /) -> uvec3: ...
@overload
def uround(x: vec4, /) -> uvec4: ...


# matrix_access

@overload
def column(m: dmat2x2, index: int, /) -> dvec2: ...
@overload
def column(m: dmat2x3, index: int, /) -> dvec3: ...
@overload
def column(m: dmat2x4, index: int, /) -> dvec4: ...
@overload
def column(m: dmat3x2, index: int, /) -> dvec2: ...
@overload
def column(m: dmat3x3, index: int, /) -> dvec3: ...
@overload
def column(m: dmat3x4, index: int, /) -> dvec4: ...
@overload
def column(m: dmat4x2, index: int, /) -> dvec2: ...
@overload
def column(m: dmat4x3, index: int, /) -> dvec3: ...
@overload
def column(m: dmat4x4, index: int, /) -> dvec4: ...
@overload
def column(m: imat2x2, index: int, /) -> ivec2: ...
@overload
def column(m: imat2x3, index: int, /) -> ivec3: ...
@overload
def column(m: imat2x4, index: int, /) -> ivec4: ...
@overload
def column(m: imat3x2, index: int, /) -> ivec2: ...
@overload
def column(m: imat3x3, index: int, /) -> ivec3: ...
@overload
def column(m: imat3x4, index: int, /) -> ivec4: ...
@overload
def column(m: imat4x2, index: int, /) -> ivec2: ...
@overload
def column(m: imat4x3, index: int, /) -> ivec3: ...
@overload
def column(m: imat4x4, index: int, /) -> ivec4: ...
@overload
def column(m: mat2x2, index: int, /) -> vec2: ...
@overload
def column(m: mat2x3, index: int, /) -> vec3: ...
@overload
def column(m: mat2x4, index: int, /) -> vec4: ...
@overload
def column(m: mat3x2, index: int, /) -> vec2: ...
@overload
def column(m: mat3x3, index: int, /) -> vec3: ...
@overload
def column(m: mat3x4, index: int, /) -> vec4: ...
@overload
def column(m: mat4x2, index: int, /) -> vec2: ...
@overload
def column(m: mat4x3, index: int, /) -> vec3: ...
@overload
def column(m: mat4x4, index: int, /) -> vec4: ...
@overload
def column(m: umat2x2, index: int, /) -> uvec2: ...
@overload
def column(m: umat2x3, index: int, /) -> uvec3: ...
@overload
def column(m: umat2x4, index: int, /) -> uvec4: ...
@overload
def column(m: umat3x2, index: int, /) -> uvec2: ...
@overload
def column(m: umat3x3, index: int, /) -> uvec3: ...
@overload
def column(m: umat3x4, index: int, /) -> uvec4: ...
@overload
def column(m: umat4x2, index: int, /) -> uvec2: ...
@overload
def column(m: umat4x3, index: int, /) -> uvec3: ...
@overload
def column(m: umat4x4, index: int, /) -> uvec4: ...
@overload
def column(m: dmat2x2, index: int, x: dvec2, /) -> dmat2x2: ...
@overload
def column(m: dmat2x3, index: int, x: dvec3, /) -> dmat2x3: ...
@overload
def column(m: dmat2x4, index: int, x: dvec4, /) -> dmat2x4: ...
@overload
def column(m: dmat3x2, index: int, x: dvec2, /) -> dmat3x2: ...
@overload
def column(m: dmat3x3, index: int, x: dvec3, /) -> dmat3x3: ...
@overload
def column(m: dmat3x4, index: int, x: dvec4, /) -> dmat3x4: ...
@overload
def column(m: dmat4x2, index: int, x: dvec2, /) -> dmat4x2: ...
@overload
def column(m: dmat4x3, index: int, x: dvec3, /) -> dmat4x3: ...
@overload
def column(m: dmat4x4, index: int, x: dvec4, /) -> dmat4x4: ...
@overload
def column(m: imat2x2, index: int, x: ivec2, /) -> imat2x2: ...
@overload
def column(m: imat2x3, index: int, x: ivec3, /) -> imat2x3: ...
@overload
def column(m: imat2x4, index: int, x: ivec4, /) -> imat2x4: ...
@overload
def column(m: imat3x2, index: int, x: ivec2, /) -> imat3x2: ...
@overload
def column(m: imat3x3, index: int, x: ivec3, /) -> imat3x3: ...
@overload
def column(m: imat3x4, index: int, x: ivec4, /) -> imat3x4: ...
@overload
def column(m: imat4x2, index: int, x: ivec2, /) -> imat4x2: ...
@overload
def column(m: imat4x3, index: int, x: ivec3, /) -> imat4x3: ...
@overload
def column(m: imat4x4, index: int, x: ivec4, /) -> imat4x4: ...
@overload
def column(m: mat2x2, index: int, x: vec2, /) -> mat2x2: ...
@overload
def column(m: mat2x3, index: int, x: vec3, /) -> mat2x3: ...
@overload
def column(m: mat2x4, index: int, x: vec4, /) -> mat2x4: ...
@overload
def column(m: mat3x2, index: int, x: vec2, /) -> mat3x2: ...
@overload
def column(m: mat3x3, index: int, x: vec3, /) -> mat3x3: ...
@overload
def column(m: mat3x4, index: int, x: vec4, /) -> mat3x4: ...
@overload
def column(m: mat4x2, index: int, x: vec2, /) -> mat4x2: ...
@overload
def column(m: mat4x3, index: int, x: vec3, /) -> mat4x3: ...
@overload
def column(m: mat4x4, index: int, x: vec4, /) -> mat4x4: ...
@overload
def column(m: umat2x2, index: int, x: uvec2, /) -> umat2x2: ...
@overload
def column(m: umat2x3, index: int, x: uvec3, /) -> umat2x3: ...
@overload
def column(m: umat2x4, index: int, x: uvec4, /) -> umat2x4: ...
@overload
def column(m: umat3x2, index: int, x: uvec2, /) -> umat3x2: ...
@overload
def column(m: umat3x3, index: int, x: uvec3, /) -> umat3x3: ...
@overload
def column(m: umat3x4, index: int, x: uvec4, /) -> umat3x4: ...
@overload
def column(m: umat4x2, index: int, x: uvec2, /) -> umat4x2: ...
@overload
def column(m: umat4x3, index: int, x: uvec3, /) -> umat4x3: ...
@overload
def column(m: umat4x4, index: int, x: uvec4, /) -> umat4x4: ...


@overload
def row(m: dmat2x2, index: int, /) -> dvec2: ...
@overload
def row(m: dmat2x3, index: int, /) -> dvec2: ...
@overload
def row(m: dmat2x4, index: int, /) -> dvec2: ...
@overload
def row(m: dmat3x2, index: int, /) -> dvec3: ...
@overload
def row(m: dmat3x3, index: int, /) -> dvec3: ...
@overload
def row(m: dmat3x4, index: int, /) -> dvec3: ...
@overload
def row(m: dmat4x2, index: int, /) -> dvec4: ...
@overload
def row(m: dmat4x3, index: int, /) -> dvec4: ...
@overload
def row(m: dmat4x4, index: int, /) -> dvec4: ...
@overload
def row(m: imat2x2, index: int, /) -> ivec2: ...
@overload
def row(m: imat2x3, index: int, /) -> ivec2: ...
@overload
def row(m: imat2x4, index: int, /) -> ivec2: ...
@overload
def row(m: imat3x2, index: int, /) -> ivec3: ...
@overload
def row(m: imat3x3, index: int, /) -> ivec3: ...
@overload
def row(m: imat3x4, index: int, /) -> ivec3: ...
@overload
def row(m: imat4x2, index: int, /) -> ivec4: ...
@overload
def row(m: imat4x3, index: int, /) -> ivec4: ...
@overload
def row(m: imat4x4, index: int, /) -> ivec4: ...
@overload
def row(m: mat2x2, index: int, /) -> vec2: ...
@overload
def row(m: mat2x3, index: int, /) -> vec2: ...
@overload
def row(m: mat2x4, index: int, /) -> vec2: ...
@overload
def row(m: mat3x2, index: int, /) -> vec3: ...
@overload
def row(m: mat3x3, index: int, /) -> vec3: ...
@overload
def row(m: mat3x4, index: int, /) -> vec3: ...
@overload
def row(m: mat4x2, index: int, /) -> vec4: ...
@overload
def row(m: mat4x3, index: int, /) -> vec4: ...
@overload
def row(m: mat4x4, index: int, /) -> vec4: ...
@overload
def row(m: umat2x2, index: int, /) -> uvec2: ...
@overload
def row(m: umat2x3, index: int, /) -> uvec2: ...
@overload
def row(m: umat2x4, index: int, /) -> uvec2: ...
@overload
def row(m: umat3x2, index: int, /) -> uvec3: ...
@overload
def row(m: umat3x3, index: int, /) -> uvec3: ...
@overload
def row(m: umat3x4, index: int, /) -> uvec3: ...
@overload
def row(m: umat4x2, index: int, /) -> uvec4: ...
@overload
def row(m: umat4x3, index: int, /) -> uvec4: ...
@overload
def row(m: umat4x4, index: int, /) -> uvec4: ...
@overload
def row(m: dmat2x2, index: int, x: dvec2, /) -> dmat2x2: ...
@overload
def row(m: dmat2x3, index: int, x: dvec2, /) -> dmat2x3: ...
@overload
def row(m: dmat2x4, index: int, x: dvec2, /) -> dmat2x4: ...
@overload
def row(m: dmat3x2, index: int, x: dvec3, /) -> dmat3x2: ...
@overload
def row(m: dmat3x3, index: int, x: dvec3, /) -> dmat3x3: ...
@overload
def row(m: dmat3x4, index: int, x: dvec3, /) -> dmat3x4: ...
@overload
def row(m: dmat4x2, index: int, x: dvec4, /) -> dmat4x2: ...
@overload
def row(m: dmat4x3, index: int, x: dvec4, /) -> dmat4x3: ...
@overload
def row(m: dmat4x4, index: int, x: dvec4, /) -> dmat4x4: ...
@overload
def row(m: imat2x2, index: int, x: ivec2, /) -> imat2x2: ...
@overload
def row(m: imat2x3, index: int, x: ivec2, /) -> imat2x3: ...
@overload
def row(m: imat2x4, index: int, x: ivec2, /) -> imat2x4: ...
@overload
def row(m: imat3x2, index: int, x: ivec3, /) -> imat3x2: ...
@overload
def row(m: imat3x3, index: int, x: ivec3, /) -> imat3x3: ...
@overload
def row(m: imat3x4, index: int, x: ivec3, /) -> imat3x4: ...
@overload
def row(m: imat4x2, index: int, x: ivec4, /) -> imat4x2: ...
@overload
def row(m: imat4x3, index: int, x: ivec4, /) -> imat4x3: ...
@overload
def row(m: imat4x4, index: int, x: ivec4, /) -> imat4x4: ...
@overload
def row(m: mat2x2, index: int, x: vec2, /) -> mat2x2: ...
@overload
def row(m: mat2x3, index: int, x: vec2, /) -> mat2x3: ...
@overload
def row(m: mat2x4, index: int, x: vec2, /) -> mat2x4: ...
@overload
def row(m: mat3x2, index: int, x: vec3, /) -> mat3x2: ...
@overload
def row(m: mat3x3, index: int, x: vec3, /) -> mat3x3: ...
@overload
def row(m: mat3x4, index: int, x: vec3, /) -> mat3x4: ...
@overload
def row(m: mat4x2, index: int, x: vec4, /) -> mat4x2: ...
@overload
def row(m: mat4x3, index: int, x: vec4, /) -> mat4x3: ...
@overload
def row(m: mat4x4, index: int, x: vec4, /) -> mat4x4: ...
@overload
def row(m: umat2x2, index: int, x: uvec2, /) -> umat2x2: ...
@overload
def row(m: umat2x3, index: int, x: uvec2, /) -> umat2x3: ...
@overload
def row(m: umat2x4, index: int, x: uvec2, /) -> umat2x4: ...
@overload
def row(m: umat3x2, index: int, x: uvec3, /) -> umat3x2: ...
@overload
def row(m: umat3x3, index: int, x: uvec3, /) -> umat3x3: ...
@overload
def row(m: umat3x4, index: int, x: uvec3, /) -> umat3x4: ...
@overload
def row(m: umat4x2, index: int, x: uvec4, /) -> umat4x2: ...
@overload
def row(m: umat4x3, index: int, x: uvec4, /) -> umat4x3: ...
@overload
def row(m: umat4x4, index: int, x: uvec4, /) -> umat4x4: ...


# matrix_inverse

@overload
def affineInverse(m: mat3x3, /) -> mat3x3: ...
@overload
def affineInverse(m: dmat3x3, /) -> dmat3x3: ...
@overload
def affineInverse(m: mat4x4, /) -> mat4x4: ...
@overload
def affineInverse(m: dmat4x4, /) -> dmat4x4: ...

@overload
def inverseTranspose(m: mat2x2, /) -> mat2x2: ...
@overload
def inverseTranspose(m: dmat2x2, /) -> dmat2x2: ...
@overload
def inverseTranspose(m: mat3x3, /) -> mat3x3: ...
@overload
def inverseTranspose(m: dmat3x3, /) -> dmat3x3: ...
@overload
def inverseTranspose(m: mat4x4, /) -> mat4x4: ...
@overload
def inverseTranspose(m: dmat4x4, /) -> dmat4x4: ...


# noise

@overload
def perlin(p: _FLOAT_VECTOR, /) -> float: ...
@overload
def perlin(p: _FLOAT_VECTOR, rep: _FLOAT_VECTOR, /) -> float: ...

def simplex(p: _FLOAT_VECTOR, /) -> float: ...


# packing

def packF2x11_1x10(v: vec3, /) -> int: ...

def packF3x9_E1x5(v: vec3, /) -> int: ...

@overload
def packHalf(v: vec1, /) -> u16vec1: ...
@overload
def packHalf(v: vec2, /) -> u16vec2: ...
@overload
def packHalf(v: vec3, /) -> u16vec3: ...
@overload
def packHalf(v: vec4, /) -> u16vec4: ...

def packHalf1x16(v: float, /) -> int: ...

def packHalf4x16(v: vec4, /) -> int: ...

def packI3x10_1x2(v: ivec4, /) -> int: ...

def packInt2x16(v: i16vec2, /) -> int: ...

def packInt2x32(v: i32vec2, /) -> int: ...

def packInt2x8(v: i8vec2, /) -> int: ...

def packInt4x16(v: i16vec4, /) -> int: ...

def packInt4x8(v: i8vec4, /) -> int: ...

def packRGBM(v: vec3, /) -> vec4: ...


@overload
def packSnorm(t: ctypes.c_byte, v: dmvec2, /) -> i8vec2: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: dmvec2, /) -> u8vec2: ...
@overload
def packSnorm(t: ctypes.c_short, v: dmvec2, /) -> i16vec2: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: dmvec2, /) -> u16vec2: ...
@overload
def packSnorm(t: ctypes.c_long, v: dmvec2, /) -> i32vec2: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: dmvec2, /) -> u32vec2: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: dmvec2, /) -> i64vec2: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: dmvec2, /) -> u64vec2: ...
@overload
def packSnorm(t: ctypes.c_byte, v: dmvec3, /) -> i8vec3: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: dmvec3, /) -> u8vec3: ...
@overload
def packSnorm(t: ctypes.c_short, v: dmvec3, /) -> i16vec3: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: dmvec3, /) -> u16vec3: ...
@overload
def packSnorm(t: ctypes.c_long, v: dmvec3, /) -> i32vec3: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: dmvec3, /) -> u32vec3: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: dmvec3, /) -> i64vec3: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: dmvec3, /) -> u64vec3: ...
@overload
def packSnorm(t: ctypes.c_byte, v: dmvec4, /) -> i8vec4: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: dmvec4, /) -> u8vec4: ...
@overload
def packSnorm(t: ctypes.c_short, v: dmvec4, /) -> i16vec4: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: dmvec4, /) -> u16vec4: ...
@overload
def packSnorm(t: ctypes.c_long, v: dmvec4, /) -> i32vec4: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: dmvec4, /) -> u32vec4: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: dmvec4, /) -> i64vec4: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: dmvec4, /) -> u64vec4: ...
@overload
def packSnorm(t: ctypes.c_byte, v: dvec1, /) -> i8vec1: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: dvec1, /) -> u8vec1: ...
@overload
def packSnorm(t: ctypes.c_short, v: dvec1, /) -> i16vec1: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: dvec1, /) -> u16vec1: ...
@overload
def packSnorm(t: ctypes.c_long, v: dvec1, /) -> i32vec1: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: dvec1, /) -> u32vec1: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: dvec1, /) -> i64vec1: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: dvec1, /) -> u64vec1: ...
@overload
def packSnorm(t: ctypes.c_byte, v: dvec2, /) -> i8vec2: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: dvec2, /) -> u8vec2: ...
@overload
def packSnorm(t: ctypes.c_short, v: dvec2, /) -> i16vec2: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: dvec2, /) -> u16vec2: ...
@overload
def packSnorm(t: ctypes.c_long, v: dvec2, /) -> i32vec2: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: dvec2, /) -> u32vec2: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: dvec2, /) -> i64vec2: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: dvec2, /) -> u64vec2: ...
@overload
def packSnorm(t: ctypes.c_byte, v: dvec3, /) -> i8vec3: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: dvec3, /) -> u8vec3: ...
@overload
def packSnorm(t: ctypes.c_short, v: dvec3, /) -> i16vec3: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: dvec3, /) -> u16vec3: ...
@overload
def packSnorm(t: ctypes.c_long, v: dvec3, /) -> i32vec3: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: dvec3, /) -> u32vec3: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: dvec3, /) -> i64vec3: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: dvec3, /) -> u64vec3: ...
@overload
def packSnorm(t: ctypes.c_byte, v: dvec4, /) -> i8vec4: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: dvec4, /) -> u8vec4: ...
@overload
def packSnorm(t: ctypes.c_short, v: dvec4, /) -> i16vec4: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: dvec4, /) -> u16vec4: ...
@overload
def packSnorm(t: ctypes.c_long, v: dvec4, /) -> i32vec4: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: dvec4, /) -> u32vec4: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: dvec4, /) -> i64vec4: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: dvec4, /) -> u64vec4: ...
@overload
def packSnorm(t: ctypes.c_byte, v: mvec2, /) -> i8vec2: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: mvec2, /) -> u8vec2: ...
@overload
def packSnorm(t: ctypes.c_short, v: mvec2, /) -> i16vec2: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: mvec2, /) -> u16vec2: ...
@overload
def packSnorm(t: ctypes.c_long, v: mvec2, /) -> i32vec2: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: mvec2, /) -> u32vec2: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: mvec2, /) -> i64vec2: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: mvec2, /) -> u64vec2: ...
@overload
def packSnorm(t: ctypes.c_byte, v: mvec3, /) -> i8vec3: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: mvec3, /) -> u8vec3: ...
@overload
def packSnorm(t: ctypes.c_short, v: mvec3, /) -> i16vec3: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: mvec3, /) -> u16vec3: ...
@overload
def packSnorm(t: ctypes.c_long, v: mvec3, /) -> i32vec3: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: mvec3, /) -> u32vec3: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: mvec3, /) -> i64vec3: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: mvec3, /) -> u64vec3: ...
@overload
def packSnorm(t: ctypes.c_byte, v: mvec4, /) -> i8vec4: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: mvec4, /) -> u8vec4: ...
@overload
def packSnorm(t: ctypes.c_short, v: mvec4, /) -> i16vec4: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: mvec4, /) -> u16vec4: ...
@overload
def packSnorm(t: ctypes.c_long, v: mvec4, /) -> i32vec4: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: mvec4, /) -> u32vec4: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: mvec4, /) -> i64vec4: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: mvec4, /) -> u64vec4: ...
@overload
def packSnorm(t: ctypes.c_byte, v: vec1, /) -> i8vec1: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: vec1, /) -> u8vec1: ...
@overload
def packSnorm(t: ctypes.c_short, v: vec1, /) -> i16vec1: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: vec1, /) -> u16vec1: ...
@overload
def packSnorm(t: ctypes.c_long, v: vec1, /) -> i32vec1: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: vec1, /) -> u32vec1: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: vec1, /) -> i64vec1: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: vec1, /) -> u64vec1: ...
@overload
def packSnorm(t: ctypes.c_byte, v: vec2, /) -> i8vec2: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: vec2, /) -> u8vec2: ...
@overload
def packSnorm(t: ctypes.c_short, v: vec2, /) -> i16vec2: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: vec2, /) -> u16vec2: ...
@overload
def packSnorm(t: ctypes.c_long, v: vec2, /) -> i32vec2: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: vec2, /) -> u32vec2: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: vec2, /) -> i64vec2: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: vec2, /) -> u64vec2: ...
@overload
def packSnorm(t: ctypes.c_byte, v: vec3, /) -> i8vec3: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: vec3, /) -> u8vec3: ...
@overload
def packSnorm(t: ctypes.c_short, v: vec3, /) -> i16vec3: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: vec3, /) -> u16vec3: ...
@overload
def packSnorm(t: ctypes.c_long, v: vec3, /) -> i32vec3: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: vec3, /) -> u32vec3: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: vec3, /) -> i64vec3: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: vec3, /) -> u64vec3: ...
@overload
def packSnorm(t: ctypes.c_byte, v: vec4, /) -> i8vec4: ...
@overload
def packSnorm(t: ctypes.c_ubyte, v: vec4, /) -> u8vec4: ...
@overload
def packSnorm(t: ctypes.c_short, v: vec4, /) -> i16vec4: ...
@overload
def packSnorm(t: ctypes.c_ushort, v: vec4, /) -> u16vec4: ...
@overload
def packSnorm(t: ctypes.c_long, v: vec4, /) -> i32vec4: ...
@overload
def packSnorm(t: ctypes.c_ulong, v: vec4, /) -> u32vec4: ...
@overload
def packSnorm(t: ctypes.c_longlong, v: vec4, /) -> i64vec4: ...
@overload
def packSnorm(t: ctypes.c_ulonglong, v: vec4, /) -> u64vec4: ...

def packSnorm1x16(v: float, /) -> int: ...

def packSnorm1x8(v: float, /) -> int: ...

def packSnorm2x8(v: vec2, /) -> int: ...

def packSnorm3x10_1x2(v: vec4, /) -> int: ...

def packSnorm4x16(v: vec4, /) -> int: ...

def packU3x10_1x2(v: uvec4, /) -> int: ...

def packUint2x16(v: u16vec2, /) -> int: ...

def packUint2x32(v: u32vec2, /) -> int: ...

def packUint2x8(v: u8vec2, /) -> int: ...

def packUint4x16(v: u16vec4, /) -> int: ...

def packUint4x8(v: u16vec4, /) -> int: ...

@overload
def packUnorm(t: ctypes.c_ubyte, v: dmvec2, /) -> u8vec2: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: dmvec2, /) -> u16vec2: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: dmvec2, /) -> u32vec2: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: dmvec2, /) -> u64vec2: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: dmvec3, /) -> u8vec3: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: dmvec3, /) -> u16vec3: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: dmvec3, /) -> u32vec3: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: dmvec3, /) -> u64vec3: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: dmvec4, /) -> u8vec4: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: dmvec4, /) -> u16vec4: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: dmvec4, /) -> u32vec4: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: dmvec4, /) -> u64vec4: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: dvec1, /) -> u8vec1: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: dvec1, /) -> u16vec1: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: dvec1, /) -> u32vec1: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: dvec1, /) -> u64vec1: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: dvec2, /) -> u8vec2: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: dvec2, /) -> u16vec2: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: dvec2, /) -> u32vec2: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: dvec2, /) -> u64vec2: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: dvec3, /) -> u8vec3: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: dvec3, /) -> u16vec3: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: dvec3, /) -> u32vec3: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: dvec3, /) -> u64vec3: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: dvec4, /) -> u8vec4: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: dvec4, /) -> u16vec4: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: dvec4, /) -> u32vec4: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: dvec4, /) -> u64vec4: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: mvec2, /) -> u8vec2: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: mvec2, /) -> u16vec2: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: mvec2, /) -> u32vec2: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: mvec2, /) -> u64vec2: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: mvec3, /) -> u8vec3: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: mvec3, /) -> u16vec3: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: mvec3, /) -> u32vec3: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: mvec3, /) -> u64vec3: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: mvec4, /) -> u8vec4: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: mvec4, /) -> u16vec4: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: mvec4, /) -> u32vec4: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: mvec4, /) -> u64vec4: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: vec1, /) -> u8vec1: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: vec1, /) -> u16vec1: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: vec1, /) -> u32vec1: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: vec1, /) -> u64vec1: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: vec2, /) -> u8vec2: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: vec2, /) -> u16vec2: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: vec2, /) -> u32vec2: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: vec2, /) -> u64vec2: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: vec3, /) -> u8vec3: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: vec3, /) -> u16vec3: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: vec3, /) -> u32vec3: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: vec3, /) -> u64vec3: ...
@overload
def packUnorm(t: ctypes.c_ubyte, v: vec4, /) -> u8vec4: ...
@overload
def packUnorm(t: ctypes.c_ushort, v: vec4, /) -> u16vec4: ...
@overload
def packUnorm(t: ctypes.c_ulong, v: vec4, /) -> u32vec4: ...
@overload
def packUnorm(t: ctypes.c_ulonglong, v: vec4, /) -> u64vec4: ...

def packUnorm1x16(v: float, /) -> int: ...

def packUnorm1x5_1x6_1x5(v: vec3, /) -> int: ...

def packUnorm2x4(v: vec2, /) -> int: ...

def packUnorm2x8(v: vec2, /) -> int: ...

def packUnorm3x10_1x2(v: vec4, /) -> int: ...

def packUnorm4x16(v: vec4, /) -> int: ...

def packUnorm4x4(v: vec4, /) -> int: ...

def unpackF2x11_1x10(p: int, /) -> vec3: ...

def unpackF3x9_E1x5(p: int, /) -> vec3: ...

@overload
def unpackHalf(p: u16vec1, /) -> vec1: ...
@overload
def unpackHalf(p: u16vec2, /) -> vec2: ...
@overload
def unpackHalf(p: u16vec3, /) -> vec3: ...
@overload
def unpackHalf(p: u16vec4, /) -> vec4: ...

def unpackHalf1x16(p: int, /) -> float: ...

def unpackI3x10_1x2(p: int, /) -> ivec4: ...

def unpackInt2x16(p: int, /) -> i16vec2: ...

def unpackInt2x32(p: int, /) -> i32vec2: ...

def unpackInt2x8(p: int, /) -> i8vec2: ...

def unpackInt4x16(p: int, /) -> i16vec4: ...

def unpackInt4x8(p: int, /) -> i8vec4: ...

def unpackRGBM(p: vec4, /) -> vec3: ...

@overload
def unpackSnorm(t: ctypes.c_float, v: i16vec1, /) -> vec1: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i16vec1, /) -> dvec1: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: i16vec2, /) -> vec2: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i16vec2, /) -> dvec2: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: i16vec3, /) -> vec3: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i16vec3, /) -> dvec3: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: i16vec4, /) -> vec4: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i16vec4, /) -> dvec4: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: i64vec1, /) -> vec1: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i64vec1, /) -> dvec1: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: i64vec2, /) -> vec2: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i64vec2, /) -> dvec2: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: i64vec3, /) -> vec3: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i64vec3, /) -> dvec3: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: i64vec4, /) -> vec4: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i64vec4, /) -> dvec4: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: i8vec1, /) -> vec1: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i8vec1, /) -> dvec1: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: i8vec2, /) -> vec2: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i8vec2, /) -> dvec2: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: i8vec3, /) -> vec3: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i8vec3, /) -> dvec3: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: i8vec4, /) -> vec4: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: i8vec4, /) -> dvec4: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: imvec2, /) -> vec2: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: imvec2, /) -> dvec2: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: imvec3, /) -> vec3: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: imvec3, /) -> dvec3: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: imvec4, /) -> vec4: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: imvec4, /) -> dvec4: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: ivec1, /) -> vec1: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: ivec1, /) -> dvec1: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: ivec2, /) -> vec2: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: ivec2, /) -> dvec2: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: ivec3, /) -> vec3: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: ivec3, /) -> dvec3: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: ivec4, /) -> vec4: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: ivec4, /) -> dvec4: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u16vec1, /) -> vec1: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u16vec1, /) -> dvec1: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u16vec2, /) -> vec2: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u16vec2, /) -> dvec2: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u16vec3, /) -> vec3: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u16vec3, /) -> dvec3: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u16vec4, /) -> vec4: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u16vec4, /) -> dvec4: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u64vec1, /) -> vec1: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u64vec1, /) -> dvec1: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u64vec2, /) -> vec2: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u64vec2, /) -> dvec2: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u64vec3, /) -> vec3: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u64vec3, /) -> dvec3: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u64vec4, /) -> vec4: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u64vec4, /) -> dvec4: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u8vec1, /) -> vec1: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u8vec1, /) -> dvec1: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u8vec2, /) -> vec2: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u8vec2, /) -> dvec2: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u8vec3, /) -> vec3: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u8vec3, /) -> dvec3: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: u8vec4, /) -> vec4: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: u8vec4, /) -> dvec4: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: umvec2, /) -> vec2: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: umvec2, /) -> dvec2: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: umvec3, /) -> vec3: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: umvec3, /) -> dvec3: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: umvec4, /) -> vec4: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: umvec4, /) -> dvec4: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: uvec1, /) -> vec1: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: uvec1, /) -> dvec1: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: uvec2, /) -> vec2: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: uvec2, /) -> dvec2: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: uvec3, /) -> vec3: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: uvec3, /) -> dvec3: ...
@overload
def unpackSnorm(t: ctypes.c_float, v: uvec4, /) -> vec4: ...
@overload
def unpackSnorm(t: ctypes.c_double, v: uvec4, /) -> dvec4: ...

def unpackSnorm1x16(p: int, /) -> float: ...

def unpackSnorm1x8(p: int, /) -> float: ...

def unpackSnorm2x8(p: int, /) -> vec2: ...

def unpackSnorm3x10_1x2(p: int, /) -> vec4: ...

def unpackSnorm4x16(p: int, /) -> vec4: ...

def unpackU3x10_1x2(p: int, /) -> uvec4: ...

def unpackUint2x16(p: int, /) -> u16vec2: ...

def unpackUint2x32(p: int, /) -> u32vec2: ...

def unpackUint2x8(p: int, /) -> u8vec2: ...

def unpackUint4x16(p: int, /) -> u16vec4: ...

def unpackUint4x8(p: int, /) -> u8vec4: ...

@overload
def unpackUnorm(t: ctypes.c_float, v: umvec2, /) -> vec2: ...
@overload
def unpackUnorm(t: ctypes.c_double, v: umvec2, /) -> dvec2: ...
@overload
def unpackUnorm(t: ctypes.c_float, v: umvec3, /) -> vec3: ...
@overload
def unpackUnorm(t: ctypes.c_double, v: umvec3, /) -> dvec3: ...
@overload
def unpackUnorm(t: ctypes.c_float, v: umvec4, /) -> vec4: ...
@overload
def unpackUnorm(t: ctypes.c_double, v: umvec4, /) -> dvec4: ...
@overload
def unpackUnorm(t: ctypes.c_float, v: uvec1, /) -> vec1: ...
@overload
def unpackUnorm(t: ctypes.c_double, v: uvec1, /) -> dvec1: ...
@overload
def unpackUnorm(t: ctypes.c_float, v: uvec2, /) -> vec2: ...
@overload
def unpackUnorm(t: ctypes.c_double, v: uvec2, /) -> dvec2: ...
@overload
def unpackUnorm(t: ctypes.c_float, v: uvec3, /) -> vec3: ...
@overload
def unpackUnorm(t: ctypes.c_double, v: uvec3, /) -> dvec3: ...
@overload
def unpackUnorm(t: ctypes.c_float, v: uvec4, /) -> vec4: ...
@overload
def unpackUnorm(t: ctypes.c_double, v: uvec4, /) -> dvec4: ...

def unpackUnorm1x16(p: int, /) -> float: ...

def unpackUnorm1x5_1x6_1x5(p: int, /) -> vec3: ...

def unpackUnorm1x8(p: int, /) -> float: ...

def unpackUnorm2x3_1x2(p: int, /) -> vec3: ...

def unpackUnorm2x4(p: int, /) -> vec2: ...

def unpackUnorm2x8(p: int, /) -> vec2: ...

def unpackUnorm3x10_1x2(p: int, /) -> vec4: ...

def unpackUnorm3x5_1x1(p: int, /) -> vec4: ...

def unpackUnorm4x16(p: int, /) -> vec4: ...

def unpackUnorm4x4(p: int, /) -> vec4: ...


# quaternion

def eulerAngles(x: _QUAT, /) -> vec3: ...

def mat3_cast(x: _QUAT, /) -> mat3: ...

def mat4_cast(x: _QUAT, /) -> mat4: ...

def pitch(x: _QUAT, /) -> float: ...

def quatLookAtLH(direction: vec3, up: vec3, /) -> quat: ...

def quatLookAtRH(direction: vec3, up: vec3, /) -> quat: ...

quatLookAt = quatLookAtRH

def quat_cast(x: Union[mat3, mat4], /) -> quat: ...

def roll(x: _QUAT, /) -> float: ...

def yaw(x: _QUAT, /) -> float: ...


# random

def ballRand(Radius: _Number, /) -> vec3: ...

def circularRand(Radius: _Number, /) -> vec2: ...

def diskRand(Radius: _Number, /) -> vec2: ...

@overload
def gaussRand(Mean: _Number, Deviation: _Number, /) -> float: ...
@overload
def gaussRand(Mean: _VT, Deviation: _VT, /) -> _VT: ...

@overload
def linearRand(Min: _Number, Max: _Number, /) -> float: ...
@overload
def linearRand(Min: _VT, Max: _VT, /) -> _VT: ...

def setSeed(seed: SupportsInt, /) -> None: ...

def sphericalRand(Radius: _Number, /) -> vec3: ...


# reciprocal

def acot(x: _Number, /) -> float: ...

def acoth(x: _Number, /) -> float: ...

def acsc(x: _Number, /) -> float: ...

def acsch(x: _Number, /) -> float: ...

def asec(x: _Number, /) -> float: ...

def asech(x: _Number, /) -> float: ...

def cot(x: _Number, /) -> float: ...

def coth(x: _Number, /) -> float: ...

def csc(x: _Number, /) -> float: ...

def csch(x: _Number, /) -> float: ...

def sec(x: _Number, /) -> float: ...

def sech(x: _Number, /) -> float: ...


# round

@overload
def ceilMultiple(v: _Number, Multiple: _Number, /) -> int: ...
@overload
def ceilMultiple(v: _iVT, Multiple: _iVT, /) -> _iVT: ...

@overload
def ceilPowerOfTwo(v: _Number, Multiple: _Number, /) -> int: ...
@overload
def ceilPowerOfTwo(v: _iVT, Multiple: _iVT, /) -> _iVT: ...

@overload
def floorMultiple(v: _Number, Multiple: _Number, /) -> int: ...
@overload
def floorMultiple(v: _iVT, Multiple: _iVT, /) -> _iVT: ...

@overload
def floorPowerOfTwo(v: _Number, Multiple: _Number, /) -> int: ...
@overload
def floorPowerOfTwo(v: _iVT, Multiple: _iVT, /) -> _iVT: ...

@overload
def roundMultiple(v: _Number, Multiple: _Number, /) -> int: ...
@overload
def roundMultiple(v: _iVT, Multiple: _iVT, /) -> _iVT: ...

@overload
def roundPowerOfTwo(v: _Number, Multiple: _Number, /) -> int: ...
@overload
def roundPowerOfTwo(v: _iVT, Multiple: _iVT, /) -> _iVT: ...


# type_ptr

def make_mat2x2(x: ctypes.c_void_p) -> mat2x2: ...

def make_mat2x3(x: ctypes.c_void_p) -> mat2x3: ...

def make_mat2x4(x: ctypes.c_void_p) -> mat2x4: ...

def make_mat3x2(x: ctypes.c_void_p) -> mat3x2: ...

def make_mat3x3(x: ctypes.c_void_p) -> mat3x3: ...

def make_mat3x4(x: ctypes.c_void_p) -> mat3x4: ...

def make_mat4x2(x: ctypes.c_void_p) -> mat4x2: ...

def make_mat4x3(x: ctypes.c_void_p) -> mat4x3: ...

def make_mat4x4(x: ctypes.c_void_p) -> mat4x4: ...

make_mat2 = make_mat2x2
make_mat3 = make_mat3x3
make_mat4 = make_mat4x4

def make_quat(x: ctypes.c_void_p) -> quat: ...

def make_vec2(x: ctypes.c_void_p) -> vec2: ...

def make_vec3(x: ctypes.c_void_p) -> vec3: ...

def make_vec4(x: ctypes.c_void_p) -> vec4: ...

def sizeof(x: Type[Union[_GLM_TYPES, _CTYPES]]) -> int: ...

def value_ptr(x: Union[_GLM_TYPES, _CTYPES]) -> ctypes.c_void_p: ...


# ulp

@overload
def float_distance(x: _Number, y: _Number) -> float: ...
@overload
def float_distance(x: mvec2, y: mvec2, /) -> ivec2: ...
@overload
def float_distance(x: mvec3, y: mvec3, /) -> ivec3: ...
@overload
def float_distance(x: mvec4, y: mvec4, /) -> ivec4: ...
@overload
def float_distance(x: vec1, y: vec1, /) -> ivec1: ...
@overload
def float_distance(x: vec2, y: vec2, /) -> ivec2: ...
@overload
def float_distance(x: vec3, y: vec3, /) -> ivec3: ...
@overload
def float_distance(x: vec4, y: vec4, /) -> ivec4: ...
@overload
def float_distance(x: dmvec2, y: dmvec2, /) -> i64vec2: ...
@overload
def float_distance(x: dmvec3, y: dmvec3, /) -> i64vec3: ...
@overload
def float_distance(x: dmvec4, y: dmvec4, /) -> i64vec4: ...
@overload
def float_distance(x: dvec1, y: dvec1, /) -> i64vec1: ...
@overload
def float_distance(x: dvec2, y: dvec2, /) -> i64vec2: ...
@overload
def float_distance(x: dvec3, y: dvec3, /) -> i64vec3: ...
@overload
def float_distance(x: dvec4, y: dvec4, /) -> i64vec4: ...

@overload
def next_float(x: _Number) -> float: ...
@overload
def next_float(x: _FVT) -> _FVT: ...
@overload
def next_float(x: _Number, ULPs: _Number) -> float: ...
@overload
def next_float(x: _FVT, ULPs: _Number) -> _FVT: ...
@overload
def next_float(x: dmvec2, ULPs: ivec2, /) -> float: ...
@overload
def next_float(x: dmvec3, ULPs: ivec3, /) -> float: ...
@overload
def next_float(x: dmvec4, ULPs: ivec4, /) -> float: ...
@overload
def next_float(x: dvec1, ULPs: ivec1, /) -> float: ...
@overload
def next_float(x: dvec2, ULPs: ivec2, /) -> float: ...
@overload
def next_float(x: dvec3, ULPs: ivec3, /) -> float: ...
@overload
def next_float(x: dvec4, ULPs: ivec4, /) -> float: ...
@overload
def next_float(x: mvec2, ULPs: ivec2, /) -> float: ...
@overload
def next_float(x: mvec3, ULPs: ivec3, /) -> float: ...
@overload
def next_float(x: mvec4, ULPs: ivec4, /) -> float: ...
@overload
def next_float(x: vec1, ULPs: ivec1, /) -> float: ...
@overload
def next_float(x: vec2, ULPs: ivec2, /) -> float: ...
@overload
def next_float(x: vec3, ULPs: ivec3, /) -> float: ...
@overload
def next_float(x: vec4, ULPs: ivec4, /) -> float: ...

@overload
def prev_float(x: _Number) -> float: ...
@overload
def prev_float(x: _FVT) -> _FVT: ...
@overload
def prev_float(x: _Number, ULPs: _Number) -> float: ...
@overload
def prev_float(x: _FVT, ULPs: _Number) -> _FVT: ...
@overload
def prev_float(x: dmvec2, ULPs: ivec2, /) -> float: ...
@overload
def prev_float(x: dmvec3, ULPs: ivec3, /) -> float: ...
@overload
def prev_float(x: dmvec4, ULPs: ivec4, /) -> float: ...
@overload
def prev_float(x: dvec1, ULPs: ivec1, /) -> float: ...
@overload
def prev_float(x: dvec2, ULPs: ivec2, /) -> float: ...
@overload
def prev_float(x: dvec3, ULPs: ivec3, /) -> float: ...
@overload
def prev_float(x: dvec4, ULPs: ivec4, /) -> float: ...
@overload
def prev_float(x: mvec2, ULPs: ivec2, /) -> float: ...
@overload
def prev_float(x: mvec3, ULPs: ivec3, /) -> float: ...
@overload
def prev_float(x: mvec4, ULPs: ivec4, /) -> float: ...
@overload
def prev_float(x: vec1, ULPs: ivec1, /) -> float: ...
@overload
def prev_float(x: vec2, ULPs: ivec2, /) -> float: ...
@overload
def prev_float(x: vec3, ULPs: ivec3, /) -> float: ...
@overload
def prev_float(x: vec4, ULPs: ivec4, /) -> float: ...


# matrix_clip_space

def frustumLH_NO(left: _Number, right: _Number, bottom: _Number, top: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

def frustumLH_ZO(left: _Number, right: _Number, bottom: _Number, top: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

def frustumRH_NO(left: _Number, right: _Number, bottom: _Number, top: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

def frustumRH_ZO(left: _Number, right: _Number, bottom: _Number, top: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

frustum = frustumRH_NO
frustumNO = frustumRH_NO
frustumRH = frustumRH_NO
frustumLH = frustumLH_NO
frustumZO = frustumRH_ZO

def infinitePerspectiveLH(fovy: _Number, aspect: _Number, near: _Number, /) -> mat4x4: ...

def infinitePerspectiveRH(fovy: _Number, aspect: _Number, near: _Number, /) -> mat4x4: ...

infinitePerspective = infinitePerspectiveRH

def orthoLH_NO(left: _Number, right: _Number, bottom: _Number, top: _Number, zNear: _Number, zFar: _Number, /) -> mat4x4: ...

def orthoLH_ZO(left: _Number, right: _Number, bottom: _Number, top: _Number, zNear: _Number, zFar: _Number, /) -> mat4x4: ...

def orthoRH_NO(left: _Number, right: _Number, bottom: _Number, top: _Number, zNear: _Number, zFar: _Number, /) -> mat4x4: ...

def orthoRH_ZO(left: _Number, right: _Number, bottom: _Number, top: _Number, zNear: _Number, zFar: _Number, /) -> mat4x4: ...

ortho = orthoRH_NO
orthoLH = orthoLH_NO
orthoNO = orthoRH_NO
orthoRH = orthoRH_NO
orthoZO = orthoRH_ZO

def perspectiveLH_NO(fovy: _Number, aspect: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

def perspectiveLH_ZO(fovy: _Number, aspect: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

def perspectiveRH_NO(fovy: _Number, aspect: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

def perspectiveRH_ZO(fovy: _Number, aspect: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

perspective = perspectiveRH_NO
perspectiveLH = perspectiveLH_NO
perspectiveNO = perspectiveRH_NO
perspectiveRH = perspectiveRH_NO
perspectiveZO = perspectiveRH_ZO

def perspectiveFovLH_NO(fov: _Number, width: _Number, height: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

def perspectiveFovLH_ZO(fov: _Number, width: _Number, height: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

def perspectiveFovRH_NO(fov: _Number, width: _Number, height: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

def perspectiveFovRH_ZO(fov: _Number, width: _Number, height: _Number, near: _Number, far: _Number, /) -> mat4x4: ...

perspectiveFov = perspectiveFovRH_NO
perspectiveFovLH = perspectiveFovLH_NO
perspectiveFovNO = perspectiveFovRH_NO
perspectiveFovRH = perspectiveFovRH_NO
perspectiveFovZO = perspectiveFovRH_ZO

@overload
def tweakedInfinitePerspective(fovy: _Number, aspect: _Number, near: _Number, /) -> mat4x4: ...
@overload
def tweakedInfinitePerspective(fovy: _Number, aspect: _Number, near: _Number, epsilon: float, /) -> mat4x4: ...


# matrix_projection

@overload
def pickMatrix(center: vec2, delta: vec2, viewport: vec4, /) -> mat4x4: ...
@overload
def pickMatrix(center: dvec2, delta: dvec2, viewport: dvec4, /) -> dmat4x4: ...

@overload
def projectNO(obj: vec3, model: mat4x4, proj: mat4x4, viewport: vec4, /) -> vec3: ...
@overload
def projectNO(obj: dvec3, model: dmat4x4, proj: dmat4x4, viewport: dvec4, /) -> dvec3: ...

project = projectNO

@overload
def projectZO(obj: vec3, model: mat4x4, proj: mat4x4, viewport: vec4, /) -> vec3: ...
@overload
def projectZO(obj: dvec3, model: dmat4x4, proj: dmat4x4, viewport: dvec4, /) -> dvec3: ...

@overload
def unProjectNO(win: vec3, model: mat4x4, proj: mat4x4, viewport: vec4, /) -> vec3: ...
@overload
def unProjectNO(win: dvec3, model: dmat4x4, proj: dmat4x4, viewport: dvec4, /) -> dvec3: ...

unProject = unProjectNO

@overload
def unProjectZO(win: vec3, model: mat4x4, proj: mat4x4, viewport: vec4, /) -> vec3: ...
@overload
def unProjectZO(win: dvec3, model: dmat4x4, proj: dmat4x4, viewport: dvec4, /) -> dvec3: ...


# matrix_transform

def identity(matrix_type: Type[_MT], /) -> _MT: ...

@overload
def lookAtLH(eye: vec3, center: vec3, up: vec3, /) -> mat4x4: ...
@overload
def lookAtLH(eye: dvec3, center: dvec3, up: dvec3, /) -> dmat4x4: ...

@overload
def lookAtRH(eye: vec3, center: vec3, up: vec3, /) -> mat4x4: ...
@overload
def lookAtRH(eye: dvec3, center: dvec3, up: dvec3, /) -> dmat4x4: ...

lookAt = lookAtRH

@overload
def rotate(angle: _Number, axis: vec3, /) -> mat4x4: ...
@overload
def rotate(angle: _Number, axis: dvec3, /) -> dmat4x4: ...
@overload
def rotate(angle: _Number, /) -> mat3x3: ...
@overload
def rotate(m: mat4x4, angle: _Number, axis: vec3, /) -> mat4x4: ...
@overload
def rotate(m: dmat4x4, angle: _Number, axis: dvec3, /) -> mat4x4: ...
@overload
def rotate(m: mat3x3, angle: _Number, /) -> mat3x3: ...
@overload
def rotate(m: dmat3x3, angle: _Number, /) -> dmat3x3: ...
@overload
def rotate(v: vec2, angle: _Number, /) -> vec2: ...
@overload
def rotate(v: dvec2, angle: _Number, /) -> dvec2: ...
@overload
def rotate(v: vec3, angle: _Number, normal: vec3, /) -> vec3: ...
@overload
def rotate(v: dvec3, angle: _Number, normal: dvec3, /) -> dvec3: ...
@overload
def rotate(v: dvec4, angle: _Number, normal: dvec3, /) -> dvec4: ...
@overload
def rotate(v: quat, angle: _Number, normal: vec3, /) -> quat: ...
@overload
def rotate(v: dquat, angle: _Number, normal: dvec3, /) -> dquat: ...

@overload
def rotate_slow(m: mat4x4, angle: _Number, axis: vec3, /) -> mat4x4: ...
@overload
def rotate_slow(m: dmat4x4, angle: _Number, axis: dvec3, /) -> dmat4x4: ...

@overload
def scale(v: vec3, /) -> mat4x4: ...
@overload
def scale(v: dvec3, /) -> dmat4x4: ...
@overload
def scale(v: vec2, /) -> mat3x3: ...
@overload
def scale(v: dvec2, /) -> mat3x3: ...
@overload
def scale(m: mat4x4, v: vec3, /) -> mat4x4: ...
@overload
def scale(m: dmat4x4, v: dvec3, /) -> dmat4x4: ...
@overload
def scale(m: mat3x3, v: vec2, /) -> mat3x3: ...
@overload
def scale(m: dmat3x3, v: dvec2, /) -> dmat3x3: ...

@overload
def scale_slow(m: mat4x4, v: vec3, /) -> mat4x4: ...
@overload
def scale_slow(m: dmat4x4, v: dvec3, /) -> dmat4x4: ...

@overload
def translate(v: vec3, /) -> mat4x4: ...
@overload
def translate(v: dvec3, /) -> dmat4x4: ...
@overload
def translate(v: vec2, /) -> mat3x3: ...
@overload
def translate(v: dvec2, /) -> dmat3x3: ...
@overload
def translate(m: mat4x4, v: vec3, /) -> mat4x4: ...
@overload
def translate(m: dmat4x4, v: dvec3, /) -> dmat4x4: ...
@overload
def translate(m: mat3x3, v: vec2, /) -> mat3x3: ...
@overload
def translate(m: dmat3x3, v: dvec2, /) -> dmat3x3: ...


# quaternion_common

def conjugate(q: _QT, /) -> _QT: ...

def lerp(x: _QT, y: _QT, a: _Number, /) -> _QT: ...

@overload
def slerp(x: _QT, y: _QT, a: _Number, /) -> _QT: ...
@overload
def slerp(x: vec3, y: vec3, a: _Number, /) -> vec3: ...
@overload
def slerp(x: dvec3, y: dvec3, a: _Number, /) -> dvec3: ...


# quaternion_trigonometric

def angle(x: _QT, /) -> float: ...

@overload
def angleAxis(angle: _Number, axis: vec3, /) -> quat: ...
@overload
def angleAxis(angle: _Number, axis: dvec3, /) -> dquat: ...

@overload
def axis(x: quat, /) -> vec3: ...
@overload
def axis(x: dquat, /) -> dvec3: ...


# decompose

@overload
def decompose(modelMatrix: mat4x4, scale: vec3, orientation: quat, translation: vec3, skew: vec3, perspective: vec4, /) -> bool: ...
@overload
def decompose(modelMatrix: dmat4x4, scale: dvec3, orientation: dquat, translation: dvec3, skew: dvec3, perspective: dvec4, /) -> bool: ...


# matrix_transform_2d

@overload
def shearX(m: mat3x3, y: _Number, /) -> mat3x3: ...
@overload
def shearX(m: dmat3x3, y: _Number, /) -> dmat3x3: ...

@overload
def shearY(m: mat3x3, y: _Number, /) -> mat3x3: ...
@overload
def shearY(m: dmat3x3, y: _Number, /) -> dmat3x3: ...


# norm

def distance2(p0: _FVT, p1: _FVT, /) -> float: ...

@overload
def l1Norm(v: Union[vec3, dvec3], /) -> float: ...
@overload
def l1Norm(x: vec3, y: vec3, /) -> float: ...
@overload
def l1Norm(x: dvec3, y: dvec3, /) -> float: ...

@overload
def l2Norm(v: Union[vec3, dvec3], /) -> float: ...
@overload
def l2Norm(x: vec3, y: vec3, /) -> float: ...
@overload
def l2Norm(x: dvec3, y: dvec3, /) -> float: ...

@overload
def lMaxNorm(v: Union[vec3, dvec3], /) -> float: ...
@overload
def lMaxNorm(x: vec3, y: vec3, /) -> float: ...
@overload
def lMaxNorm(x: dvec3, y: dvec3, /) -> float: ...

def length2(p0: _FVT, p1: _FVT, /) -> float: ...

@overload
def lxNorm(v: Union[vec3, dvec3], Depth: int, /) -> float: ...
@overload
def lxNorm(x: vec3, y: vec3, Depth: int, /) -> float: ...
@overload
def lxNorm(x: dvec3, y: dvec3, Depth: int, /) -> float: ...


# polar_coordinates

@overload
def euclidean(polar: vec2, /) -> vec3: ...
@overload
def euclidean(polar: dvec2, /) -> dvec3: ...

@overload
def poldar(euclidean: vec3, /) -> vec3: ...
@overload
def poldar(euclidean: dvec3, /) -> dvec3: ...


# rotate_vector

@overload
def orientation(Normal: vec3, Up: vec3, /) -> mat4x4: ...
@overload
def orientation(Normal: dvec3, Up: dvec3, /) -> dmat4x4: ...

@overload
def rotateX(v: vec3, angle: _Number) -> vec3: ...
@overload
def rotateX(v: dvec3, angle: _Number) -> dvec3: ...
@overload
def rotateX(v: vec4, angle: _Number) -> vec4: ...
@overload
def rotateX(v: dvec4, angle: _Number) -> dvec4: ...

@overload
def rotateY(v: vec3, angle: _Number) -> vec3: ...
@overload
def rotateY(v: dvec3, angle: _Number) -> dvec3: ...
@overload
def rotateY(v: vec4, angle: _Number) -> vec4: ...
@overload
def rotateY(v: dvec4, angle: _Number) -> dvec4: ...

@overload
def rotateZ(v: vec3, angle: _Number) -> vec3: ...
@overload
def rotateZ(v: dvec3, angle: _Number) -> dvec3: ...
@overload
def rotateZ(v: vec4, angle: _Number) -> vec4: ...
@overload
def rotateZ(v: dvec4, angle: _Number) -> dvec4: ...




_ARRAY_TYPES = Union[_CTYPES, _GLM_TYPES]

_AT = TypeVar('_AT', bound=_ARRAY_TYPES)
_AT2 = TypeVar('_AT2', bound=_ARRAY_TYPES)
_GT = TypeVar('_GT', bound=_GLM_TYPES)
_ACT = TypeVar('_ACT', bound=_CTYPES)
class array(Generic[_AT]):

    nbytes: int
    typecode: str
    element_type: Type[_AT]
    itemsize: int
    dt_size: int
    address: int
    length: int
    readonly: bool
    reference: Union[_ARRAY_TYPES, array]

    @property
    def ptr(self) -> ctypes.c_void_p: ...

    # todo: can make this more precise by overloading on `self: array[...]`
    @property
    def dtype(self) -> str: ...

    # todo: can make this more precise by overloading on `self: array[...]`
    @property
    def ctype(self) -> _CTYPES: ...

    @overload
    def __init__(self, _1: _AT, /, *_: _AT) -> None: ...
    @overload
    def __init__(self, _: array[_AT], /) -> None: ...
    @overload
    def __init__(self, _: Iterable[_AT], /) -> None: ...

    def __len__(self) -> int: ...
    def __contains__(self, value: Any) -> bool: ...

    @overload
    def __iter__(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]]) -> Generator[float, None, None]: ...
    @overload
    def __iter__(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]]) -> Generator[int, None, None]: ...
    @overload
    def __iter__(self: array[_GT]) -> Generator[_GT, None, None]: ...

    @overload
    def __getitem__(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]], index: int) -> float: ...
    @overload
    def __getitem__(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]], index: int) -> int: ...
    @overload
    def __getitem__(self: array[_GT], index: int) -> _GT: ...
    @overload
    def __getitem__(self, index: slice) -> array[_AT]: ...

    @overload
    def __setitem__(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]], index: int, value: float) -> None: ...
    @overload
    def __setitem__(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]], index: int, value: int) -> None: ...
    @overload
    def __setitem__(self: array[_GT], index: int, value: _AT) -> None: ...
    @overload
    def __setitem__(self, index: slice, value: array[_AT]) -> None: ...

    @staticmethod
    def from_bytes(bytes: bytes, type: Type[_AT], /) -> array[_AT]: ...
    @staticmethod
    def from_numbers(type: Type[_ACT], /, *numbers: _Number) -> array[_ACT]: ...
    @staticmethod
    def zeros(type: Type[_AT], length: int, /) -> array[_AT]: ...

    def to_bytes(self) -> bytes: ...

    @overload
    def to_list(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]]) -> List[float]: ...
    @overload
    def to_list(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]]) -> List[int]: ...
    @overload
    def to_list(self: array[_GT]) -> List[_GT]: ...

    @overload
    def to_tuple(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]]) -> Tuple[float]: ...
    @overload
    def to_tuple(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]]) -> Tuple[int]: ...
    @overload
    def to_tuple(self: array[_GT]) -> Tuple[_GT]: ...

    # todo: can make this more precise by overloading on `self: array[...]`
    def split_components(self) -> Tuple[array[Any]]: ...

    def reduce(self, func: Callable[[_AT, _AT], _AT], init: Optional[_AT] = None, /) -> _AT: ...
    def filter(self, _: Callable[[_AT], Any], /) -> array[_AT]: ...
    def map(self, _: Callable[[_AT], _AT2], /) -> array[_AT2]: ...
    def sort(self, _: Callable[[_AT], SupportsInt], /) -> array[_AT]: ...
    def concat(self, other: array[_AT], /) -> array[_AT]: ...
    def iconcat(self, other: array[_AT], /) -> None: ...
    def repeat(self, count: int, /) -> array[_AT]: ...
    def irepeat(self, count: int, /) -> None: ...

    @overload
    @staticmethod
    def as_reference(array: array[_AT2], /) -> array[_AT2]: ...
    @overload
    @staticmethod
    def as_reference(obj: _GT, /) -> array[_GT]: ...

    def reinterpret_cast(self, type: Type[_AT2], /) -> array[_AT2]: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def __add__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __iadd__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __sub__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __isub__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __mul__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __imul__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __mod__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __imod__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __pow__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ipow__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __lshift__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ilshift__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __rshift__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __irshift__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __and__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __iand__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __xor__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ixor__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __or__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ior__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __truediv__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __itruediv__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...

    def __neg__(self) -> array[_AT]: ...
    def __pos__(self) -> array[_AT]: ...
    def __abs__(self) -> array[_AT]: ...
    def __inv__(self) -> array[_AT]: ...


class bvec1:

    x: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, bvec2, bvec3, bvec4, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec1: ...
    def __pos__(self) -> bvec1: ...
    def __abs__(self) -> bvec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, bvec1]) -> bvec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, bvec1]) -> bvec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, bvec1]) -> bvec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, bvec1]) -> bvec1: ...


class bvec2:

    x: bool
    y: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, bvec3, bvec4, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec2: ...
    def __pos__(self) -> bvec2: ...
    def __abs__(self) -> bvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool, bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, bvec2]) -> bvec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, bvec2]) -> bvec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, bvec2]) -> bvec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, bvec2]) -> bvec2: ...


class bvec3:

    x: bool
    y: bool
    z: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, bvec4, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec3: ...
    def __pos__(self) -> bvec3: ...
    def __abs__(self) -> bvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool, bool, bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, bvec3]) -> bvec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, bvec3]) -> bvec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, bvec3]) -> bvec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, bvec3]) -> bvec3: ...


class bvec4:

    x: bool
    y: bool
    z: bool
    w: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec4: ...
    def __pos__(self) -> bvec4: ...
    def __abs__(self) -> bvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool, bool, bool, bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, bvec4]) -> bvec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, bvec4]) -> bvec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, bvec4]) -> bvec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, bvec4]) -> bvec4: ...


class dmat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat2x2, mat2x2, umat2x2]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec2, dmvec2]) -> None: ...

    def __neg__(self) -> dmat2x2: ...
    def __pos__(self) -> dmat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat2x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number], dvec1]) -> dvec1: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number], dvec1]) -> dvec1: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number], dvec1]) -> dvec1: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number], dvec1]) -> dvec1: ...


class dmat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat2x3, mat2x3, umat2x3]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec3, dmvec3]) -> None: ...

    def __neg__(self) -> dmat2x3: ...
    def __pos__(self) -> dmat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat2x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat2x3]) -> dmat2x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat2x3]) -> dmat2x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat2x3]) -> dmat2x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat2x3]) -> dmat2x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec3: ...


class dmat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat2x4, mat2x4, umat2x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec4, dmvec4]) -> None: ...

    def __neg__(self) -> dmat2x4: ...
    def __pos__(self) -> dmat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat2x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat2x4]) -> dmat2x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat2x4]) -> dmat2x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat2x4]) -> dmat2x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat2x4]) -> dmat2x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec4: ...


class dmat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat3x2, mat3x2, umat3x2]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec2, dmvec2]) -> None: ...

    def __neg__(self) -> dmat3x2: ...
    def __pos__(self) -> dmat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat3x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat3x2]) -> dmat3x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat3x2]) -> dmat3x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat3x2]) -> dmat3x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat3x2]) -> dmat3x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec2: ...


class dmat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, dquat, imat3x3, mat3x3, umat3x3]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec3, dmvec3]) -> None: ...

    def __neg__(self) -> dmat3x3: ...
    def __pos__(self) -> dmat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat3x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...


class dmat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat3x4, mat3x4, umat3x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec4, dmvec4]) -> None: ...

    def __neg__(self) -> dmat3x4: ...
    def __pos__(self) -> dmat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat3x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat3x4]) -> dmat3x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat3x4]) -> dmat3x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat3x4]) -> dmat3x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat3x4]) -> dmat3x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec4: ...


class dmat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat4x2, mat4x2, umat4x2]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec2, dmvec2]) -> None: ...

    def __neg__(self) -> dmat4x2: ...
    def __pos__(self) -> dmat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat4x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat4x2]) -> dmat4x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat4x2]) -> dmat4x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat4x2]) -> dmat4x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat4x2]) -> dmat4x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec2: ...


class dmat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat4x3, mat4x3, umat4x3]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec3, dmvec3]) -> None: ...

    def __neg__(self) -> dmat4x3: ...
    def __pos__(self) -> dmat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat4x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat4x3]) -> dmat4x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat4x3]) -> dmat4x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat4x3]) -> dmat4x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat4x3]) -> dmat4x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec3: ...


class dmat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, _12: _Number, _13: _Number, _14: _Number, _15: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, dquat, imat4x4, mat4x4, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec4, dmvec4]) -> None: ...

    def __neg__(self) -> dmat4x4: ...
    def __pos__(self) -> dmat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat4x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...


class dmvec2:

    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], dvec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dmvec2: ...
    def __pos__(self) -> dmvec2: ...
    def __abs__(self) -> dmvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmvec2: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __add__(self, other: _Number) -> dmvec2: ...
    @overload
    def __add__(self, other: dvec2) -> dvec2: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __iadd__(self, other: _Number) -> dmvec2: ...
    @overload
    def __iadd__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __sub__(self, other: _Number) -> dmvec2: ...
    @overload
    def __sub__(self, other: dvec2) -> dvec2: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __isub__(self, other: _Number) -> dmvec2: ...
    @overload
    def __isub__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __mul__(self, other: _Number) -> dmvec2: ...
    @overload
    def __mul__(self, other: dmat2x2) -> dvec2: ...
    @overload
    def __mul__(self, other: dmat3x2) -> dvec3: ...
    @overload
    def __mul__(self, other: dmat4x2) -> dvec4: ...
    @overload
    def __mul__(self, other: dvec2) -> dvec2: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __imul__(self, other: _Number) -> dmvec2: ...
    @overload
    def __imul__(self, other: dmat2x2) -> dvec2: ...
    @overload
    def __imul__(self, other: dmat3x2) -> dvec3: ...
    @overload
    def __imul__(self, other: dmat4x2) -> dvec4: ...
    @overload
    def __imul__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __mod__(self, other: _Number) -> dmvec2: ...
    @overload
    def __mod__(self, other: dvec2) -> dvec2: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __imod__(self, other: _Number) -> dmvec2: ...
    @overload
    def __imod__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __pow__(self, other: _Number) -> dmvec2: ...
    @overload
    def __pow__(self, other: dvec2) -> dvec2: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __ipow__(self, other: _Number) -> dmvec2: ...
    @overload
    def __ipow__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __floordiv__(self, other: _Number) -> dmvec2: ...
    @overload
    def __floordiv__(self, other: dvec2) -> dvec2: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> dmvec2: ...
    @overload
    def __ifloordiv__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec2: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __truediv__(self, other: _Number) -> dmvec2: ...
    @overload
    def __truediv__(self, other: dmat2x2) -> dvec2: ...
    @overload
    def __truediv__(self, other: dvec2) -> dvec2: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec2: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __itruediv__(self, other: _Number) -> dmvec2: ...
    @overload
    def __itruediv__(self, other: dmat2x2) -> dvec2: ...
    @overload
    def __itruediv__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __matmul__(self, other: _Number) -> dmvec2: ...
    @overload
    def __matmul__(self, other: dmat2x2) -> dvec2: ...
    @overload
    def __matmul__(self, other: dmat3x2) -> dvec3: ...
    @overload
    def __matmul__(self, other: dmat4x2) -> dvec4: ...
    @overload
    def __matmul__(self, other: dvec2) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dmvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __imatmul__(self, other: _Number) -> dmvec2: ...
    @overload
    def __imatmul__(self, other: dmat2x2) -> dmvec2: ...
    @overload
    def __imatmul__(self, other: dmat3x2) -> dvec3: ...
    @overload
    def __imatmul__(self, other: dmat4x2) -> dvec4: ...
    @overload
    def __imatmul__(self, other: dvec2) -> dmvec2: ...

    def __divmod__(self, other: dvec2) -> Tuple[dvec2, dvec2]: ...


class dmvec3:

    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], dvec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dmvec3: ...
    def __pos__(self) -> dmvec3: ...
    def __abs__(self) -> dmvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmvec3: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __add__(self, other: _Number) -> dmvec3: ...
    @overload
    def __add__(self, other: dvec3) -> dvec3: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __iadd__(self, other: _Number) -> dmvec3: ...
    @overload
    def __iadd__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __sub__(self, other: _Number) -> dmvec3: ...
    @overload
    def __sub__(self, other: dvec3) -> dvec3: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __isub__(self, other: _Number) -> dmvec3: ...
    @overload
    def __isub__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __mul__(self, other: _Number) -> dmvec3: ...
    @overload
    def __mul__(self, other: dmat2x3) -> dvec2: ...
    @overload
    def __mul__(self, other: dmat3x3) -> dvec3: ...
    @overload
    def __mul__(self, other: dmat4x3) -> dvec4: ...
    @overload
    def __mul__(self, other: dvec3) -> dvec3: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __imul__(self, other: _Number) -> dmvec3: ...
    @overload
    def __imul__(self, other: dmat2x3) -> dvec2: ...
    @overload
    def __imul__(self, other: dmat3x3) -> dvec3: ...
    @overload
    def __imul__(self, other: dmat4x3) -> dvec4: ...
    @overload
    def __imul__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __mod__(self, other: _Number) -> dmvec3: ...
    @overload
    def __mod__(self, other: dvec3) -> dvec3: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __imod__(self, other: _Number) -> dmvec3: ...
    @overload
    def __imod__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __pow__(self, other: _Number) -> dmvec3: ...
    @overload
    def __pow__(self, other: dvec3) -> dvec3: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __ipow__(self, other: _Number) -> dmvec3: ...
    @overload
    def __ipow__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __floordiv__(self, other: _Number) -> dmvec3: ...
    @overload
    def __floordiv__(self, other: dvec3) -> dvec3: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> dmvec3: ...
    @overload
    def __ifloordiv__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __truediv__(self, other: _Number) -> dmvec3: ...
    @overload
    def __truediv__(self, other: dmat3x3) -> dvec3: ...
    @overload
    def __truediv__(self, other: dvec3) -> dvec3: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __itruediv__(self, other: _Number) -> dmvec3: ...
    @overload
    def __itruediv__(self, other: dmat3x3) -> dvec3: ...
    @overload
    def __itruediv__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __matmul__(self, other: _Number) -> dmvec3: ...
    @overload
    def __matmul__(self, other: dmat2x3) -> dvec2: ...
    @overload
    def __matmul__(self, other: dmat3x3) -> dvec3: ...
    @overload
    def __matmul__(self, other: dmat4x3) -> dvec4: ...
    @overload
    def __matmul__(self, other: dvec3) -> dvec3: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dmvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __imatmul__(self, other: _Number) -> dmvec3: ...
    @overload
    def __imatmul__(self, other: dmat2x3) -> dvec2: ...
    @overload
    def __imatmul__(self, other: dmat3x3) -> dmvec3: ...
    @overload
    def __imatmul__(self, other: dmat4x3) -> dvec4: ...
    @overload
    def __imatmul__(self, other: dvec3) -> dmvec3: ...

    def __divmod__(self, other: dvec3) -> Tuple[dvec3, dvec3]: ...


class dmvec4:

    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dmvec4: ...
    def __pos__(self) -> dmvec4: ...
    def __abs__(self) -> dmvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmvec4: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __add__(self, other: _Number) -> dmvec4: ...
    @overload
    def __add__(self, other: dvec4) -> dvec4: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __iadd__(self, other: _Number) -> dmvec4: ...
    @overload
    def __iadd__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __sub__(self, other: _Number) -> dmvec4: ...
    @overload
    def __sub__(self, other: dvec4) -> dvec4: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __isub__(self, other: _Number) -> dmvec4: ...
    @overload
    def __isub__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __mul__(self, other: _Number) -> dmvec4: ...
    @overload
    def __mul__(self, other: dmat2x4) -> dvec2: ...
    @overload
    def __mul__(self, other: dmat3x4) -> dvec3: ...
    @overload
    def __mul__(self, other: dmat4x4) -> dvec4: ...
    @overload
    def __mul__(self, other: dvec4) -> dvec4: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __imul__(self, other: _Number) -> dmvec4: ...
    @overload
    def __imul__(self, other: dmat2x4) -> dvec2: ...
    @overload
    def __imul__(self, other: dmat3x4) -> dvec3: ...
    @overload
    def __imul__(self, other: dmat4x4) -> dvec4: ...
    @overload
    def __imul__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __mod__(self, other: _Number) -> dmvec4: ...
    @overload
    def __mod__(self, other: dvec4) -> dvec4: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __imod__(self, other: _Number) -> dmvec4: ...
    @overload
    def __imod__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __pow__(self, other: _Number) -> dmvec4: ...
    @overload
    def __pow__(self, other: dvec4) -> dvec4: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __ipow__(self, other: _Number) -> dmvec4: ...
    @overload
    def __ipow__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __floordiv__(self, other: _Number) -> dmvec4: ...
    @overload
    def __floordiv__(self, other: dvec4) -> dvec4: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> dmvec4: ...
    @overload
    def __ifloordiv__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __truediv__(self, other: _Number) -> dmvec4: ...
    @overload
    def __truediv__(self, other: dmat4x4) -> dvec4: ...
    @overload
    def __truediv__(self, other: dvec4) -> dvec4: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __itruediv__(self, other: _Number) -> dmvec4: ...
    @overload
    def __itruediv__(self, other: dmat4x4) -> dvec4: ...
    @overload
    def __itruediv__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __matmul__(self, other: _Number) -> dmvec4: ...
    @overload
    def __matmul__(self, other: dmat2x4) -> dvec2: ...
    @overload
    def __matmul__(self, other: dmat3x4) -> dvec3: ...
    @overload
    def __matmul__(self, other: dmat4x4) -> dvec4: ...
    @overload
    def __matmul__(self, other: dvec4) -> dvec4: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dmvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __imatmul__(self, other: _Number) -> dmvec4: ...
    @overload
    def __imatmul__(self, other: dmat2x4) -> dvec2: ...
    @overload
    def __imatmul__(self, other: dmat3x4) -> dvec3: ...
    @overload
    def __imatmul__(self, other: dmat4x4) -> dmvec4: ...
    @overload
    def __imatmul__(self, other: dvec4) -> dmvec4: ...

    def __divmod__(self, other: dvec4) -> Tuple[dvec4, dvec4]: ...


class dquat:

    x: float
    y: float
    w: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, w: _Number, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], dmat3x3, dmat4x4, dmvec3, dquat, dvec3, quat]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dquat: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...


    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __mul__(self, other: Union[_Number]) -> dquat: ...

    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __imul__(self, other: Union[_Number]) -> dquat: ...

    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Union[_Number]) -> dquat: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Union[_Number]) -> dquat: ...


class dvec1:

    x: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec1: ...
    def __pos__(self) -> dvec1: ...
    def __abs__(self) -> dvec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __pow__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __ipow__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __floordiv__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __divmod__(self, other: Union[dvec1]) -> Tuple[dvec1, dvec1]: ...


class dvec2:

    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dmvec3, dmvec4, dvec2, dvec3, dvec4, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec2: ...
    def __pos__(self) -> dvec2: ...
    def __abs__(self) -> dvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    def __divmod__(self, other: Union[dvec2]) -> Tuple[dvec2, dvec2]: ...


class dvec3:

    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dmvec4, dvec3, dvec4, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec3: ...
    def __pos__(self) -> dvec3: ...
    def __abs__(self) -> dvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dvec2: ...

    def __divmod__(self, other: Union[dvec3]) -> Tuple[dvec3, dvec3]: ...


class dvec4:

    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec4: ...
    def __pos__(self) -> dvec4: ...
    def __abs__(self) -> dvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dvec2: ...

    def __divmod__(self, other: Union[dvec4]) -> Tuple[dvec4, dvec4]: ...


class i16vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec1: ...
    def __pos__(self) -> i16vec1: ...
    def __abs__(self) -> i16vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...


class i16vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i16vec3, i16vec4, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec2: ...
    def __pos__(self) -> i16vec2: ...
    def __abs__(self) -> i16vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...


class i16vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i16vec4, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec3: ...
    def __pos__(self) -> i16vec3: ...
    def __abs__(self) -> i16vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...


class i16vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec4: ...
    def __pos__(self) -> i16vec4: ...
    def __abs__(self) -> i16vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...


class i64vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec1: ...
    def __pos__(self) -> i64vec1: ...
    def __abs__(self) -> i64vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...


class i64vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i64vec3, i64vec4, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec2: ...
    def __pos__(self) -> i64vec2: ...
    def __abs__(self) -> i64vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...


class i64vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i64vec4, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec3: ...
    def __pos__(self) -> i64vec3: ...
    def __abs__(self) -> i64vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...


class i64vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec4: ...
    def __pos__(self) -> i64vec4: ...
    def __abs__(self) -> i64vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...


class i8vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, i8vec2, i8vec3, i8vec4, ivec1, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec1: ...
    def __pos__(self) -> i8vec1: ...
    def __abs__(self) -> i8vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...


class i8vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, i8vec3, i8vec4, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec2: ...
    def __pos__(self) -> i8vec2: ...
    def __abs__(self) -> i8vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...


class i8vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, i8vec4, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec3: ...
    def __pos__(self) -> i8vec3: ...
    def __abs__(self) -> i8vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...


class i8vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec4: ...
    def __pos__(self) -> i8vec4: ...
    def __abs__(self) -> i8vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...


class imat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat2x2, umat2x2]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec2, imvec2]) -> None: ...

    def __neg__(self) -> imat2x2: ...
    def __pos__(self) -> imat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat2x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number], ivec1]) -> ivec1: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number], ivec1]) -> ivec1: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number], ivec1]) -> ivec1: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number], ivec1]) -> ivec1: ...


class imat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x3, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat2x3, umat2x3]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec3, imvec3]) -> None: ...

    def __neg__(self) -> imat2x3: ...
    def __pos__(self) -> imat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat2x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat2x3]) -> imat2x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat2x3]) -> imat2x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat2x3]) -> imat2x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat2x3]) -> imat2x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec3: ...


class imat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat2x4, umat2x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec4, imvec4]) -> None: ...

    def __neg__(self) -> imat2x4: ...
    def __pos__(self) -> imat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat2x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat2x4]) -> imat2x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat2x4]) -> imat2x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat2x4]) -> imat2x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat2x4]) -> imat2x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec4: ...


class imat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat3x2, umat3x2]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec2, imvec2]) -> None: ...

    def __neg__(self) -> imat3x2: ...
    def __pos__(self) -> imat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat3x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat3x2]) -> imat3x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat3x2]) -> imat3x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat3x2]) -> imat3x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat3x2]) -> imat3x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec2: ...


class imat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x3, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat3x3, umat3x3]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec3, imvec3]) -> None: ...

    def __neg__(self) -> imat3x3: ...
    def __pos__(self) -> imat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat3x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...


class imat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat3x4, umat3x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec4, imvec4]) -> None: ...

    def __neg__(self) -> imat3x4: ...
    def __pos__(self) -> imat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat3x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat3x4]) -> imat3x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat3x4]) -> imat3x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat3x4]) -> imat3x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat3x4]) -> imat3x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec4: ...


class imat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat4x2, umat4x2]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec2, imvec2]) -> None: ...

    def __neg__(self) -> imat4x2: ...
    def __pos__(self) -> imat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat4x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat4x2]) -> imat4x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat4x2]) -> imat4x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat4x2]) -> imat4x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat4x2]) -> imat4x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec2: ...


class imat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x3, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat4x3, umat4x3]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec3, imvec3]) -> None: ...

    def __neg__(self) -> imat4x3: ...
    def __pos__(self) -> imat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat4x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat4x3]) -> imat4x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat4x3]) -> imat4x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat4x3]) -> imat4x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat4x3]) -> imat4x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec3: ...


class imat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, _12: _Number, _13: _Number, _14: _Number, _15: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat4x4, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec4, imvec4]) -> None: ...

    def __neg__(self) -> imat4x4: ...
    def __pos__(self) -> imat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat4x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...


class imvec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], ivec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> imvec2: ...
    def __pos__(self) -> imvec2: ...
    def __abs__(self) -> imvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imvec2: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __add__(self, other: _Number) -> imvec2: ...
    @overload
    def __add__(self, other: ivec2) -> ivec2: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number]) -> imvec2: ...
    @overload
    def __iadd__(self, other: _Number) -> imvec2: ...
    @overload
    def __iadd__(self, other: ivec2) -> imvec2: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __sub__(self, other: _Number) -> imvec2: ...
    @overload
    def __sub__(self, other: ivec2) -> ivec2: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number]) -> imvec2: ...
    @overload
    def __isub__(self, other: _Number) -> imvec2: ...
    @overload
    def __isub__(self, other: ivec2) -> imvec2: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __mul__(self, other: _Number) -> imvec2: ...
    @overload
    def __mul__(self, other: imat2x2) -> ivec2: ...
    @overload
    def __mul__(self, other: imat3x2) -> ivec3: ...
    @overload
    def __mul__(self, other: imat4x2) -> ivec4: ...
    @overload
    def __mul__(self, other: ivec2) -> ivec2: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number]) -> imvec2: ...
    @overload
    def __imul__(self, other: _Number) -> imvec2: ...
    @overload
    def __imul__(self, other: imat2x2) -> ivec2: ...
    @overload
    def __imul__(self, other: imat3x2) -> ivec3: ...
    @overload
    def __imul__(self, other: imat4x2) -> ivec4: ...
    @overload
    def __imul__(self, other: ivec2) -> imvec2: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __mod__(self, other: _Number) -> imvec2: ...
    @overload
    def __mod__(self, other: ivec2) -> ivec2: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __imod__(self, other: _Number) -> imvec2: ...
    @overload
    def __imod__(self, other: ivec2) -> ivec2: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __truediv__(self, other: _Number) -> imvec2: ...
    @overload
    def __truediv__(self, other: ivec2) -> ivec2: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number]) -> imvec2: ...
    @overload
    def __itruediv__(self, other: _Number) -> imvec2: ...
    @overload
    def __itruediv__(self, other: ivec2) -> imvec2: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __matmul__(self, other: _Number) -> imvec2: ...
    @overload
    def __matmul__(self, other: imat2x2) -> ivec2: ...
    @overload
    def __matmul__(self, other: imat3x2) -> ivec3: ...
    @overload
    def __matmul__(self, other: imat4x2) -> ivec4: ...
    @overload
    def __matmul__(self, other: ivec2) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> imvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number]) -> imvec2: ...
    @overload
    def __imatmul__(self, other: _Number) -> imvec2: ...
    @overload
    def __imatmul__(self, other: imat2x2) -> imvec2: ...
    @overload
    def __imatmul__(self, other: imat3x2) -> ivec3: ...
    @overload
    def __imatmul__(self, other: imat4x2) -> ivec4: ...
    @overload
    def __imatmul__(self, other: ivec2) -> imvec2: ...


class imvec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], ivec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> imvec3: ...
    def __pos__(self) -> imvec3: ...
    def __abs__(self) -> imvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imvec3: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __add__(self, other: _Number) -> imvec3: ...
    @overload
    def __add__(self, other: ivec3) -> ivec3: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number]) -> imvec3: ...
    @overload
    def __iadd__(self, other: _Number) -> imvec3: ...
    @overload
    def __iadd__(self, other: ivec3) -> imvec3: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __sub__(self, other: _Number) -> imvec3: ...
    @overload
    def __sub__(self, other: ivec3) -> ivec3: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number]) -> imvec3: ...
    @overload
    def __isub__(self, other: _Number) -> imvec3: ...
    @overload
    def __isub__(self, other: ivec3) -> imvec3: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __mul__(self, other: _Number) -> imvec3: ...
    @overload
    def __mul__(self, other: imat2x3) -> ivec2: ...
    @overload
    def __mul__(self, other: imat3x3) -> ivec3: ...
    @overload
    def __mul__(self, other: imat4x3) -> ivec4: ...
    @overload
    def __mul__(self, other: ivec3) -> ivec3: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number]) -> imvec3: ...
    @overload
    def __imul__(self, other: _Number) -> imvec3: ...
    @overload
    def __imul__(self, other: imat2x3) -> ivec2: ...
    @overload
    def __imul__(self, other: imat3x3) -> ivec3: ...
    @overload
    def __imul__(self, other: imat4x3) -> ivec4: ...
    @overload
    def __imul__(self, other: ivec3) -> imvec3: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __mod__(self, other: _Number) -> imvec3: ...
    @overload
    def __mod__(self, other: ivec3) -> ivec3: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __imod__(self, other: _Number) -> imvec3: ...
    @overload
    def __imod__(self, other: ivec3) -> ivec3: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __truediv__(self, other: _Number) -> imvec3: ...
    @overload
    def __truediv__(self, other: ivec3) -> ivec3: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number]) -> imvec3: ...
    @overload
    def __itruediv__(self, other: _Number) -> imvec3: ...
    @overload
    def __itruediv__(self, other: ivec3) -> imvec3: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __matmul__(self, other: _Number) -> imvec3: ...
    @overload
    def __matmul__(self, other: imat2x3) -> ivec2: ...
    @overload
    def __matmul__(self, other: imat3x3) -> ivec3: ...
    @overload
    def __matmul__(self, other: imat4x3) -> ivec4: ...
    @overload
    def __matmul__(self, other: ivec3) -> ivec3: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> imvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number]) -> imvec3: ...
    @overload
    def __imatmul__(self, other: _Number) -> imvec3: ...
    @overload
    def __imatmul__(self, other: imat2x3) -> ivec2: ...
    @overload
    def __imatmul__(self, other: imat3x3) -> imvec3: ...
    @overload
    def __imatmul__(self, other: imat4x3) -> ivec4: ...
    @overload
    def __imatmul__(self, other: ivec3) -> imvec3: ...


class imvec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> imvec4: ...
    def __pos__(self) -> imvec4: ...
    def __abs__(self) -> imvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imvec4: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __add__(self, other: _Number) -> imvec4: ...
    @overload
    def __add__(self, other: ivec4) -> ivec4: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> imvec4: ...
    @overload
    def __iadd__(self, other: _Number) -> imvec4: ...
    @overload
    def __iadd__(self, other: ivec4) -> imvec4: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __sub__(self, other: _Number) -> imvec4: ...
    @overload
    def __sub__(self, other: ivec4) -> ivec4: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> imvec4: ...
    @overload
    def __isub__(self, other: _Number) -> imvec4: ...
    @overload
    def __isub__(self, other: ivec4) -> imvec4: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __mul__(self, other: _Number) -> imvec4: ...
    @overload
    def __mul__(self, other: imat2x4) -> ivec2: ...
    @overload
    def __mul__(self, other: imat3x4) -> ivec3: ...
    @overload
    def __mul__(self, other: imat4x4) -> ivec4: ...
    @overload
    def __mul__(self, other: ivec4) -> ivec4: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> imvec4: ...
    @overload
    def __imul__(self, other: _Number) -> imvec4: ...
    @overload
    def __imul__(self, other: imat2x4) -> ivec2: ...
    @overload
    def __imul__(self, other: imat3x4) -> ivec3: ...
    @overload
    def __imul__(self, other: imat4x4) -> ivec4: ...
    @overload
    def __imul__(self, other: ivec4) -> imvec4: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __mod__(self, other: _Number) -> imvec4: ...
    @overload
    def __mod__(self, other: ivec4) -> ivec4: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __imod__(self, other: _Number) -> imvec4: ...
    @overload
    def __imod__(self, other: ivec4) -> ivec4: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __truediv__(self, other: _Number) -> imvec4: ...
    @overload
    def __truediv__(self, other: ivec4) -> ivec4: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> imvec4: ...
    @overload
    def __itruediv__(self, other: _Number) -> imvec4: ...
    @overload
    def __itruediv__(self, other: ivec4) -> imvec4: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __matmul__(self, other: _Number) -> imvec4: ...
    @overload
    def __matmul__(self, other: imat2x4) -> ivec2: ...
    @overload
    def __matmul__(self, other: imat3x4) -> ivec3: ...
    @overload
    def __matmul__(self, other: imat4x4) -> ivec4: ...
    @overload
    def __matmul__(self, other: ivec4) -> ivec4: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> imvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> imvec4: ...
    @overload
    def __imatmul__(self, other: _Number) -> imvec4: ...
    @overload
    def __imatmul__(self, other: imat2x4) -> ivec2: ...
    @overload
    def __imatmul__(self, other: imat3x4) -> ivec3: ...
    @overload
    def __imatmul__(self, other: imat4x4) -> imvec4: ...
    @overload
    def __imatmul__(self, other: ivec4) -> imvec4: ...


class ivec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec1: ...
    def __pos__(self) -> ivec1: ...
    def __abs__(self) -> ivec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...


class ivec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, imvec3, imvec4, ivec2, ivec3, ivec4, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec2: ...
    def __pos__(self) -> ivec2: ...
    def __abs__(self) -> ivec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> ivec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> ivec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, imat2x2, ivec2]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> ivec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> ivec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, imat2x2, ivec2]) -> ivec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, imat2x2, ivec2]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, imat2x2, ivec2]) -> ivec2: ...


class ivec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, imvec4, ivec3, ivec4, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec3: ...
    def __pos__(self) -> ivec3: ...
    def __abs__(self) -> ivec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> ivec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, imat3x3, ivec3]) -> ivec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> ivec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, imat3x3, ivec3]) -> ivec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> ivec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, imat3x3, ivec3]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, imat3x3, ivec3]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> ivec2: ...


class ivec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec4: ...
    def __pos__(self) -> ivec4: ...
    def __abs__(self) -> ivec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, imat4x4, ivec4]) -> ivec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> ivec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, imat4x4, ivec4]) -> ivec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> ivec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> ivec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, imat4x4, ivec4]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, imat4x4, ivec4]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> ivec2: ...


class mat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, imat2x2, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat2x2]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec2, mvec2]) -> None: ...

    def __neg__(self) -> mat2x2: ...
    def __pos__(self) -> mat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat2x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number], vec1]) -> vec1: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number], vec1]) -> vec1: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number], vec1]) -> vec1: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number], vec1]) -> vec1: ...


class mat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x3, imat2x3, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat2x3]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec3, mvec3]) -> None: ...

    def __neg__(self) -> mat2x3: ...
    def __pos__(self) -> mat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat2x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat2x3]) -> mat2x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat2x3]) -> mat2x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat2x3]) -> mat2x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat2x3]) -> mat2x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec3: ...


class mat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x4, imat2x4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat2x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec4, mvec4]) -> None: ...

    def __neg__(self) -> mat2x4: ...
    def __pos__(self) -> mat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat2x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat2x4]) -> mat2x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat2x4]) -> mat2x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat2x4]) -> mat2x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat2x4]) -> mat2x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec4: ...


class mat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2, imat3x2, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat3x2]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec2, mvec2]) -> None: ...

    def __neg__(self) -> mat3x2: ...
    def __pos__(self) -> mat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat3x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat3x2]) -> mat3x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat3x2]) -> mat3x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat3x2]) -> mat3x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat3x2]) -> mat3x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec2: ...


class mat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x3, imat3x3, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, quat, umat3x3]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec3, mvec3]) -> None: ...

    def __neg__(self) -> mat3x3: ...
    def __pos__(self) -> mat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat3x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...


class mat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x4, imat3x4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat3x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec4, mvec4]) -> None: ...

    def __neg__(self) -> mat3x4: ...
    def __pos__(self) -> mat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat3x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat3x4]) -> mat3x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat3x4]) -> mat3x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat3x4]) -> mat3x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat3x4]) -> mat3x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec4: ...


class mat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2, imat4x2, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat4x2]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec2, mvec2]) -> None: ...

    def __neg__(self) -> mat4x2: ...
    def __pos__(self) -> mat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat4x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat4x2]) -> mat4x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat4x2]) -> mat4x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat4x2]) -> mat4x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat4x2]) -> mat4x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec2: ...


class mat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x3, imat4x3, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat4x3]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec3, mvec3]) -> None: ...

    def __neg__(self) -> mat4x3: ...
    def __pos__(self) -> mat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat4x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat4x3]) -> mat4x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat4x3]) -> mat4x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat4x3]) -> mat4x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat4x3]) -> mat4x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec3: ...


class mat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, _12: _Number, _13: _Number, _14: _Number, _15: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x4, imat4x4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, quat, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec4, mvec4]) -> None: ...

    def __neg__(self) -> mat4x4: ...
    def __pos__(self) -> mat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat4x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...


class mvec2:

    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> mvec2: ...
    def __pos__(self) -> mvec2: ...
    def __abs__(self) -> mvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mvec2: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __add__(self, other: _Number) -> mvec2: ...
    @overload
    def __add__(self, other: vec2) -> vec2: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __iadd__(self, other: _Number) -> mvec2: ...
    @overload
    def __iadd__(self, other: vec2) -> mvec2: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __sub__(self, other: _Number) -> mvec2: ...
    @overload
    def __sub__(self, other: vec2) -> vec2: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __isub__(self, other: _Number) -> mvec2: ...
    @overload
    def __isub__(self, other: vec2) -> mvec2: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __mul__(self, other: _Number) -> mvec2: ...
    @overload
    def __mul__(self, other: mat2x2) -> vec2: ...
    @overload
    def __mul__(self, other: mat3x2) -> vec3: ...
    @overload
    def __mul__(self, other: mat4x2) -> vec4: ...
    @overload
    def __mul__(self, other: vec2) -> vec2: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __imul__(self, other: _Number) -> mvec2: ...
    @overload
    def __imul__(self, other: mat2x2) -> vec2: ...
    @overload
    def __imul__(self, other: mat3x2) -> vec3: ...
    @overload
    def __imul__(self, other: mat4x2) -> vec4: ...
    @overload
    def __imul__(self, other: vec2) -> mvec2: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __mod__(self, other: _Number) -> mvec2: ...
    @overload
    def __mod__(self, other: vec2) -> vec2: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __imod__(self, other: _Number) -> mvec2: ...
    @overload
    def __imod__(self, other: vec2) -> mvec2: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __pow__(self, other: _Number) -> mvec2: ...
    @overload
    def __pow__(self, other: vec2) -> vec2: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __ipow__(self, other: _Number) -> mvec2: ...
    @overload
    def __ipow__(self, other: vec2) -> mvec2: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __floordiv__(self, other: _Number) -> mvec2: ...
    @overload
    def __floordiv__(self, other: vec2) -> vec2: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> mvec2: ...
    @overload
    def __ifloordiv__(self, other: vec2) -> mvec2: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec2: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __truediv__(self, other: _Number) -> mvec2: ...
    @overload
    def __truediv__(self, other: mat2x2) -> vec2: ...
    @overload
    def __truediv__(self, other: vec2) -> vec2: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec2: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __itruediv__(self, other: _Number) -> mvec2: ...
    @overload
    def __itruediv__(self, other: mat2x2) -> vec2: ...
    @overload
    def __itruediv__(self, other: vec2) -> mvec2: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __matmul__(self, other: _Number) -> mvec2: ...
    @overload
    def __matmul__(self, other: mat2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: mat3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: mat4x2) -> vec4: ...
    @overload
    def __matmul__(self, other: vec2) -> vec2: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> mvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __imatmul__(self, other: _Number) -> mvec2: ...
    @overload
    def __imatmul__(self, other: mat2x2) -> mvec2: ...
    @overload
    def __imatmul__(self, other: mat3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: mat4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: vec2) -> mvec2: ...

    def __divmod__(self, other: vec2) -> Tuple[vec2, vec2]: ...


class mvec3:

    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> mvec3: ...
    def __pos__(self) -> mvec3: ...
    def __abs__(self) -> mvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mvec3: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __add__(self, other: _Number) -> mvec3: ...
    @overload
    def __add__(self, other: vec3) -> vec3: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __iadd__(self, other: _Number) -> mvec3: ...
    @overload
    def __iadd__(self, other: vec3) -> mvec3: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __sub__(self, other: _Number) -> mvec3: ...
    @overload
    def __sub__(self, other: vec3) -> vec3: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __isub__(self, other: _Number) -> mvec3: ...
    @overload
    def __isub__(self, other: vec3) -> mvec3: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __mul__(self, other: _Number) -> mvec3: ...
    @overload
    def __mul__(self, other: mat2x3) -> vec2: ...
    @overload
    def __mul__(self, other: mat3x3) -> vec3: ...
    @overload
    def __mul__(self, other: mat4x3) -> vec4: ...
    @overload
    def __mul__(self, other: vec3) -> vec3: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __imul__(self, other: _Number) -> mvec3: ...
    @overload
    def __imul__(self, other: mat2x3) -> vec2: ...
    @overload
    def __imul__(self, other: mat3x3) -> vec3: ...
    @overload
    def __imul__(self, other: mat4x3) -> vec4: ...
    @overload
    def __imul__(self, other: vec3) -> mvec3: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __mod__(self, other: _Number) -> mvec3: ...
    @overload
    def __mod__(self, other: vec3) -> vec3: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __imod__(self, other: _Number) -> mvec3: ...
    @overload
    def __imod__(self, other: vec3) -> mvec3: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __pow__(self, other: _Number) -> mvec3: ...
    @overload
    def __pow__(self, other: vec3) -> vec3: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __ipow__(self, other: _Number) -> mvec3: ...
    @overload
    def __ipow__(self, other: vec3) -> mvec3: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __floordiv__(self, other: _Number) -> mvec3: ...
    @overload
    def __floordiv__(self, other: vec3) -> vec3: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> mvec3: ...
    @overload
    def __ifloordiv__(self, other: vec3) -> mvec3: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __truediv__(self, other: _Number) -> mvec3: ...
    @overload
    def __truediv__(self, other: mat3x3) -> vec3: ...
    @overload
    def __truediv__(self, other: vec3) -> vec3: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __itruediv__(self, other: _Number) -> mvec3: ...
    @overload
    def __itruediv__(self, other: mat3x3) -> vec3: ...
    @overload
    def __itruediv__(self, other: vec3) -> mvec3: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __matmul__(self, other: _Number) -> mvec3: ...
    @overload
    def __matmul__(self, other: mat2x3) -> vec2: ...
    @overload
    def __matmul__(self, other: mat3x3) -> vec3: ...
    @overload
    def __matmul__(self, other: mat4x3) -> vec4: ...
    @overload
    def __matmul__(self, other: vec3) -> vec3: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> mvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __imatmul__(self, other: _Number) -> mvec3: ...
    @overload
    def __imatmul__(self, other: mat2x3) -> vec2: ...
    @overload
    def __imatmul__(self, other: mat3x3) -> mvec3: ...
    @overload
    def __imatmul__(self, other: mat4x3) -> vec4: ...
    @overload
    def __imatmul__(self, other: vec3) -> mvec3: ...

    def __divmod__(self, other: vec3) -> Tuple[vec3, vec3]: ...


class mvec4:

    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> mvec4: ...
    def __pos__(self) -> mvec4: ...
    def __abs__(self) -> mvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mvec4: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __add__(self, other: _Number) -> mvec4: ...
    @overload
    def __add__(self, other: vec4) -> vec4: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __iadd__(self, other: _Number) -> mvec4: ...
    @overload
    def __iadd__(self, other: vec4) -> mvec4: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __sub__(self, other: _Number) -> mvec4: ...
    @overload
    def __sub__(self, other: vec4) -> vec4: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __isub__(self, other: _Number) -> mvec4: ...
    @overload
    def __isub__(self, other: vec4) -> mvec4: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __mul__(self, other: _Number) -> mvec4: ...
    @overload
    def __mul__(self, other: mat2x4) -> vec2: ...
    @overload
    def __mul__(self, other: mat3x4) -> vec3: ...
    @overload
    def __mul__(self, other: mat4x4) -> vec4: ...
    @overload
    def __mul__(self, other: vec4) -> vec4: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __imul__(self, other: _Number) -> mvec4: ...
    @overload
    def __imul__(self, other: mat2x4) -> vec2: ...
    @overload
    def __imul__(self, other: mat3x4) -> vec3: ...
    @overload
    def __imul__(self, other: mat4x4) -> vec4: ...
    @overload
    def __imul__(self, other: vec4) -> mvec4: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __mod__(self, other: _Number) -> mvec4: ...
    @overload
    def __mod__(self, other: vec4) -> vec4: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __imod__(self, other: _Number) -> mvec4: ...
    @overload
    def __imod__(self, other: vec4) -> mvec4: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __pow__(self, other: _Number) -> mvec4: ...
    @overload
    def __pow__(self, other: vec4) -> vec4: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __ipow__(self, other: _Number) -> mvec4: ...
    @overload
    def __ipow__(self, other: vec4) -> mvec4: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __floordiv__(self, other: _Number) -> mvec4: ...
    @overload
    def __floordiv__(self, other: vec4) -> vec4: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> mvec4: ...
    @overload
    def __ifloordiv__(self, other: vec4) -> mvec4: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __truediv__(self, other: _Number) -> mvec4: ...
    @overload
    def __truediv__(self, other: mat4x4) -> vec4: ...
    @overload
    def __truediv__(self, other: vec4) -> vec4: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __itruediv__(self, other: _Number) -> mvec4: ...
    @overload
    def __itruediv__(self, other: mat4x4) -> vec4: ...
    @overload
    def __itruediv__(self, other: vec4) -> mvec4: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __matmul__(self, other: _Number) -> mvec4: ...
    @overload
    def __matmul__(self, other: mat2x4) -> vec2: ...
    @overload
    def __matmul__(self, other: mat3x4) -> vec3: ...
    @overload
    def __matmul__(self, other: mat4x4) -> vec4: ...
    @overload
    def __matmul__(self, other: vec4) -> vec4: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> mvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __imatmul__(self, other: _Number) -> mvec4: ...
    @overload
    def __imatmul__(self, other: mat2x4) -> vec2: ...
    @overload
    def __imatmul__(self, other: mat3x4) -> vec3: ...
    @overload
    def __imatmul__(self, other: mat4x4) -> mvec4: ...
    @overload
    def __imatmul__(self, other: vec4) -> mvec4: ...

    def __divmod__(self, other: vec4) -> Tuple[vec4, vec4]: ...


class quat:

    x: float
    y: float
    w: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, w: _Number, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], dquat, mat3x3, mat4x4, mvec3, quat, vec3]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> quat: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...


    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __mul__(self, other: Union[_Number]) -> quat: ...

    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __imul__(self, other: Union[_Number]) -> quat: ...

    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __matmul__(self, other: Union[_Number]) -> quat: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Union[_Number]) -> quat: ...


class u16vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec1: ...
    def __pos__(self) -> u16vec1: ...
    def __abs__(self) -> u16vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...


class u16vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u16vec3, u16vec4, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec2: ...
    def __pos__(self) -> u16vec2: ...
    def __abs__(self) -> u16vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...


class u16vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u16vec4, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec3: ...
    def __pos__(self) -> u16vec3: ...
    def __abs__(self) -> u16vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...


class u16vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec4: ...
    def __pos__(self) -> u16vec4: ...
    def __abs__(self) -> u16vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...


class u64vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec1: ...
    def __pos__(self) -> u64vec1: ...
    def __abs__(self) -> u64vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...


class u64vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u64vec3, u64vec4, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec2: ...
    def __pos__(self) -> u64vec2: ...
    def __abs__(self) -> u64vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...


class u64vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u64vec4, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec3: ...
    def __pos__(self) -> u64vec3: ...
    def __abs__(self) -> u64vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...


class u64vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec4: ...
    def __pos__(self) -> u64vec4: ...
    def __abs__(self) -> u64vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...


class u8vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, u8vec2, u8vec3, u8vec4, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec1: ...
    def __pos__(self) -> u8vec1: ...
    def __abs__(self) -> u8vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...


class u8vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, u8vec3, u8vec4, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec2: ...
    def __pos__(self) -> u8vec2: ...
    def __abs__(self) -> u8vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...


class u8vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, u8vec4, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec3: ...
    def __pos__(self) -> u8vec3: ...
    def __abs__(self) -> u8vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...


class u8vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec4: ...
    def __pos__(self) -> u8vec4: ...
    def __abs__(self) -> u8vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...


class umat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, imat2x2, mat2x2, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec2, umvec2]) -> None: ...

    def __neg__(self) -> umat2x2: ...
    def __pos__(self) -> umat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat2x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number], uvec1]) -> uvec1: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number], uvec1]) -> uvec1: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number], uvec1]) -> uvec1: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number], uvec1]) -> uvec1: ...


class umat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x3, imat2x3, mat2x3, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec3, umvec3]) -> None: ...

    def __neg__(self) -> umat2x3: ...
    def __pos__(self) -> umat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat2x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat2x3]) -> umat2x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat2x3]) -> umat2x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat2x3]) -> umat2x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat2x3]) -> umat2x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec3: ...


class umat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x4, imat2x4, mat2x4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec4, umvec4]) -> None: ...

    def __neg__(self) -> umat2x4: ...
    def __pos__(self) -> umat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat2x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat2x4]) -> umat2x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat2x4]) -> umat2x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat2x4]) -> umat2x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat2x4]) -> umat2x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec4: ...


class umat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2, imat3x2, mat3x2, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec2, umvec2]) -> None: ...

    def __neg__(self) -> umat3x2: ...
    def __pos__(self) -> umat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat3x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat3x2]) -> umat3x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat3x2]) -> umat3x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat3x2]) -> umat3x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat3x2]) -> umat3x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec2: ...


class umat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x3, imat3x3, mat3x3, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec3, umvec3]) -> None: ...

    def __neg__(self) -> umat3x3: ...
    def __pos__(self) -> umat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat3x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...


class umat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x4, imat3x4, mat3x4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec4, umvec4]) -> None: ...

    def __neg__(self) -> umat3x4: ...
    def __pos__(self) -> umat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat3x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat3x4]) -> umat3x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat3x4]) -> umat3x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat3x4]) -> umat3x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat3x4]) -> umat3x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec4: ...


class umat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2, imat4x2, mat4x2, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec2, umvec2]) -> None: ...

    def __neg__(self) -> umat4x2: ...
    def __pos__(self) -> umat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat4x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat4x2]) -> umat4x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat4x2]) -> umat4x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat4x2]) -> umat4x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat4x2]) -> umat4x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec2: ...


class umat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x3, imat4x3, mat4x3, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec3, umvec3]) -> None: ...

    def __neg__(self) -> umat4x3: ...
    def __pos__(self) -> umat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat4x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat4x3]) -> umat4x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat4x3]) -> umat4x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat4x3]) -> umat4x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat4x3]) -> umat4x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec3: ...


class umat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, _12: _Number, _13: _Number, _14: _Number, _15: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x4, imat4x4, mat4x4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec4, umvec4]) -> None: ...

    def __neg__(self) -> umat4x4: ...
    def __pos__(self) -> umat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat4x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...


class umvec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], uvec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> umvec2: ...
    def __pos__(self) -> umvec2: ...
    def __abs__(self) -> umvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umvec2: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __add__(self, other: _Number) -> umvec2: ...
    @overload
    def __add__(self, other: uvec2) -> uvec2: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number]) -> umvec2: ...
    @overload
    def __iadd__(self, other: _Number) -> umvec2: ...
    @overload
    def __iadd__(self, other: uvec2) -> umvec2: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __sub__(self, other: _Number) -> umvec2: ...
    @overload
    def __sub__(self, other: uvec2) -> uvec2: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number]) -> umvec2: ...
    @overload
    def __isub__(self, other: _Number) -> umvec2: ...
    @overload
    def __isub__(self, other: uvec2) -> umvec2: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __mul__(self, other: _Number) -> umvec2: ...
    @overload
    def __mul__(self, other: umat2x2) -> uvec2: ...
    @overload
    def __mul__(self, other: umat3x2) -> uvec3: ...
    @overload
    def __mul__(self, other: umat4x2) -> uvec4: ...
    @overload
    def __mul__(self, other: uvec2) -> uvec2: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number]) -> umvec2: ...
    @overload
    def __imul__(self, other: _Number) -> umvec2: ...
    @overload
    def __imul__(self, other: umat2x2) -> uvec2: ...
    @overload
    def __imul__(self, other: umat3x2) -> uvec3: ...
    @overload
    def __imul__(self, other: umat4x2) -> uvec4: ...
    @overload
    def __imul__(self, other: uvec2) -> umvec2: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __mod__(self, other: _Number) -> umvec2: ...
    @overload
    def __mod__(self, other: uvec2) -> uvec2: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __imod__(self, other: _Number) -> umvec2: ...
    @overload
    def __imod__(self, other: uvec2) -> uvec2: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __truediv__(self, other: _Number) -> umvec2: ...
    @overload
    def __truediv__(self, other: uvec2) -> uvec2: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number]) -> umvec2: ...
    @overload
    def __itruediv__(self, other: _Number) -> umvec2: ...
    @overload
    def __itruediv__(self, other: uvec2) -> umvec2: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __matmul__(self, other: _Number) -> umvec2: ...
    @overload
    def __matmul__(self, other: umat2x2) -> uvec2: ...
    @overload
    def __matmul__(self, other: umat3x2) -> uvec3: ...
    @overload
    def __matmul__(self, other: umat4x2) -> uvec4: ...
    @overload
    def __matmul__(self, other: uvec2) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> umvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number]) -> umvec2: ...
    @overload
    def __imatmul__(self, other: _Number) -> umvec2: ...
    @overload
    def __imatmul__(self, other: umat2x2) -> umvec2: ...
    @overload
    def __imatmul__(self, other: umat3x2) -> uvec3: ...
    @overload
    def __imatmul__(self, other: umat4x2) -> uvec4: ...
    @overload
    def __imatmul__(self, other: uvec2) -> umvec2: ...


class umvec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], uvec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> umvec3: ...
    def __pos__(self) -> umvec3: ...
    def __abs__(self) -> umvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umvec3: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __add__(self, other: _Number) -> umvec3: ...
    @overload
    def __add__(self, other: uvec3) -> uvec3: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number]) -> umvec3: ...
    @overload
    def __iadd__(self, other: _Number) -> umvec3: ...
    @overload
    def __iadd__(self, other: uvec3) -> umvec3: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __sub__(self, other: _Number) -> umvec3: ...
    @overload
    def __sub__(self, other: uvec3) -> uvec3: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number]) -> umvec3: ...
    @overload
    def __isub__(self, other: _Number) -> umvec3: ...
    @overload
    def __isub__(self, other: uvec3) -> umvec3: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __mul__(self, other: _Number) -> umvec3: ...
    @overload
    def __mul__(self, other: umat2x3) -> uvec2: ...
    @overload
    def __mul__(self, other: umat3x3) -> uvec3: ...
    @overload
    def __mul__(self, other: umat4x3) -> uvec4: ...
    @overload
    def __mul__(self, other: uvec3) -> uvec3: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number]) -> umvec3: ...
    @overload
    def __imul__(self, other: _Number) -> umvec3: ...
    @overload
    def __imul__(self, other: umat2x3) -> uvec2: ...
    @overload
    def __imul__(self, other: umat3x3) -> uvec3: ...
    @overload
    def __imul__(self, other: umat4x3) -> uvec4: ...
    @overload
    def __imul__(self, other: uvec3) -> umvec3: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __mod__(self, other: _Number) -> umvec3: ...
    @overload
    def __mod__(self, other: uvec3) -> uvec3: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __imod__(self, other: _Number) -> umvec3: ...
    @overload
    def __imod__(self, other: uvec3) -> uvec3: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __truediv__(self, other: _Number) -> umvec3: ...
    @overload
    def __truediv__(self, other: uvec3) -> uvec3: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number]) -> umvec3: ...
    @overload
    def __itruediv__(self, other: _Number) -> umvec3: ...
    @overload
    def __itruediv__(self, other: uvec3) -> umvec3: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __matmul__(self, other: _Number) -> umvec3: ...
    @overload
    def __matmul__(self, other: umat2x3) -> uvec2: ...
    @overload
    def __matmul__(self, other: umat3x3) -> uvec3: ...
    @overload
    def __matmul__(self, other: umat4x3) -> uvec4: ...
    @overload
    def __matmul__(self, other: uvec3) -> uvec3: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> umvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number]) -> umvec3: ...
    @overload
    def __imatmul__(self, other: _Number) -> umvec3: ...
    @overload
    def __imatmul__(self, other: umat2x3) -> uvec2: ...
    @overload
    def __imatmul__(self, other: umat3x3) -> umvec3: ...
    @overload
    def __imatmul__(self, other: umat4x3) -> uvec4: ...
    @overload
    def __imatmul__(self, other: uvec3) -> umvec3: ...


class umvec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> umvec4: ...
    def __pos__(self) -> umvec4: ...
    def __abs__(self) -> umvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umvec4: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __add__(self, other: _Number) -> umvec4: ...
    @overload
    def __add__(self, other: uvec4) -> uvec4: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> umvec4: ...
    @overload
    def __iadd__(self, other: _Number) -> umvec4: ...
    @overload
    def __iadd__(self, other: uvec4) -> umvec4: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __sub__(self, other: _Number) -> umvec4: ...
    @overload
    def __sub__(self, other: uvec4) -> uvec4: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> umvec4: ...
    @overload
    def __isub__(self, other: _Number) -> umvec4: ...
    @overload
    def __isub__(self, other: uvec4) -> umvec4: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __mul__(self, other: _Number) -> umvec4: ...
    @overload
    def __mul__(self, other: umat2x4) -> uvec2: ...
    @overload
    def __mul__(self, other: umat3x4) -> uvec3: ...
    @overload
    def __mul__(self, other: umat4x4) -> uvec4: ...
    @overload
    def __mul__(self, other: uvec4) -> uvec4: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> umvec4: ...
    @overload
    def __imul__(self, other: _Number) -> umvec4: ...
    @overload
    def __imul__(self, other: umat2x4) -> uvec2: ...
    @overload
    def __imul__(self, other: umat3x4) -> uvec3: ...
    @overload
    def __imul__(self, other: umat4x4) -> uvec4: ...
    @overload
    def __imul__(self, other: uvec4) -> umvec4: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __mod__(self, other: _Number) -> umvec4: ...
    @overload
    def __mod__(self, other: uvec4) -> uvec4: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __imod__(self, other: _Number) -> umvec4: ...
    @overload
    def __imod__(self, other: uvec4) -> uvec4: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __truediv__(self, other: _Number) -> umvec4: ...
    @overload
    def __truediv__(self, other: uvec4) -> uvec4: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> umvec4: ...
    @overload
    def __itruediv__(self, other: _Number) -> umvec4: ...
    @overload
    def __itruediv__(self, other: uvec4) -> umvec4: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __matmul__(self, other: _Number) -> umvec4: ...
    @overload
    def __matmul__(self, other: umat2x4) -> uvec2: ...
    @overload
    def __matmul__(self, other: umat3x4) -> uvec3: ...
    @overload
    def __matmul__(self, other: umat4x4) -> uvec4: ...
    @overload
    def __matmul__(self, other: uvec4) -> uvec4: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> umvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> umvec4: ...
    @overload
    def __imatmul__(self, other: _Number) -> umvec4: ...
    @overload
    def __imatmul__(self, other: umat2x4) -> uvec2: ...
    @overload
    def __imatmul__(self, other: umat3x4) -> uvec3: ...
    @overload
    def __imatmul__(self, other: umat4x4) -> umvec4: ...
    @overload
    def __imatmul__(self, other: uvec4) -> umvec4: ...


class uvec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec1: ...
    def __pos__(self) -> uvec1: ...
    def __abs__(self) -> uvec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...


class uvec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, umvec3, umvec4, uvec2, uvec3, uvec4, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec2: ...
    def __pos__(self) -> uvec2: ...
    def __abs__(self) -> uvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> uvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> uvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, umat2x2, uvec2]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> uvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> uvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, umat2x2, uvec2]) -> uvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, umat2x2, uvec2]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, umat2x2, uvec2]) -> uvec2: ...


class uvec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, umvec4, uvec3, uvec4, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec3: ...
    def __pos__(self) -> uvec3: ...
    def __abs__(self) -> uvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> uvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, umat3x3, uvec3]) -> uvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> uvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, umat3x3, uvec3]) -> uvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> uvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, umat3x3, uvec3]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, umat3x3, uvec3]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> uvec2: ...


class uvec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec4: ...
    def __pos__(self) -> uvec4: ...
    def __abs__(self) -> uvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, umat4x4, uvec4]) -> uvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> uvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, umat4x4, uvec4]) -> uvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> uvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> uvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, umat4x4, uvec4]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, umat4x4, uvec4]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> uvec2: ...


class vec1:

    x: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, mvec2, mvec3, mvec4, u16vec1, u64vec1, u8vec1, uvec1, vec1, vec2, vec3, vec4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec1: ...
    def __pos__(self) -> vec1: ...
    def __abs__(self) -> vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __pow__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __ipow__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __floordiv__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __divmod__(self, other: Union[vec1]) -> Tuple[vec1, vec1]: ...


class vec2:

    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, mvec3, mvec4, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2, vec3, vec4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec2: ...
    def __pos__(self) -> vec2: ...
    def __abs__(self) -> vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> vec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> vec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> vec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> vec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> vec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> vec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    def __divmod__(self, other: Union[vec2]) -> Tuple[vec2, vec2]: ...


class vec3:

    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, mvec4, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3, vec4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec3: ...
    def __pos__(self) -> vec3: ...
    def __abs__(self) -> vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> vec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> vec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> vec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> vec2: ...

    def __divmod__(self, other: Union[vec3]) -> Tuple[vec3, vec3]: ...


class vec4:

    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec4: ...
    def __pos__(self) -> vec4: ...
    def __abs__(self) -> vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> vec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> vec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> vec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> vec2: ...

    def __divmod__(self, other: Union[vec4]) -> Tuple[vec4, vec4]: ...

bool_ = ctypes.c_bool
c_int16 = ctypes.c_short
int16 = ctypes.c_short
c_int32 = ctypes.c_long
int32 = ctypes.c_long
c_int64 = ctypes.c_longlong
int64 = ctypes.c_longlong
c_int8 = ctypes.c_byte
int8 = ctypes.c_byte
c_uint16 = ctypes.c_ushort
uint16 = ctypes.c_ushort
c_uint32 = ctypes.c_ulong
uint32 = ctypes.c_ulong
c_uint64 = ctypes.c_ulonglong
uint64 = ctypes.c_ulonglong
c_uint8 = ctypes.c_ubyte
uint8 = ctypes.c_ubyte
dmat2 = dmat2x2
f64mat2 = dmat2x2
f64mat2x2 = dmat2x2
dmat3 = dmat3x3
f64mat3 = dmat3x3
f64mat3x3 = dmat3x3
dmat4 = dmat4x4
f64mat4 = dmat4x4
f64mat4x4 = dmat4x4
double = ctypes.c_double
float64 = ctypes.c_double
f32mat2 = mat2x2
f32mat2x2 = mat2x2
fmat2 = mat2x2
fmat2x2 = mat2x2
mat2 = mat2x2
f32mat2x3 = mat2x3
fmat2x3 = mat2x3
f32mat2x4 = mat2x4
fmat2x4 = mat2x4
f32mat3 = mat3x3
f32mat3x3 = mat3x3
fmat3 = mat3x3
fmat3x3 = mat3x3
mat3 = mat3x3
f32mat3x2 = mat3x2
fmat3x2 = mat3x2
f32mat3x4 = mat3x4
fmat3x4 = mat3x4
f32mat4 = mat4x4
f32mat4x4 = mat4x4
fmat4 = mat4x4
fmat4x4 = mat4x4
mat4 = mat4x4
f32mat4x2 = mat4x2
fmat4x2 = mat4x2
f32mat4x3 = mat4x3
fmat4x3 = mat4x3
f32quat = quat
fquat = quat
f32vec1 = vec1
fvec1 = vec1
f32vec2 = vec2
fvec2 = vec2
f32vec3 = vec3
fvec3 = vec3
f32vec4 = vec4
fvec4 = vec4
f64mat2x3 = dmat2x3
f64mat2x4 = dmat2x4
f64mat3x2 = dmat3x2
f64mat3x4 = dmat3x4
f64mat4x2 = dmat4x2
f64mat4x3 = dmat4x3
f64quat = dquat
f64vec1 = dvec1
f64vec2 = dvec2
f64vec3 = dvec3
f64vec4 = dvec4
float32 = ctypes.c_float
float_ = ctypes.c_float
i32mat2 = imat2x2
i32mat2x2 = imat2x2
imat2 = imat2x2
i32mat2x3 = imat2x3
i32mat2x4 = imat2x4
i32mat3 = imat3x3
i32mat3x3 = imat3x3
imat3 = imat3x3
i32mat3x2 = imat3x2
i32mat3x4 = imat3x4
i32mat4 = imat4x4
i32mat4x4 = imat4x4
imat4 = imat4x4
i32mat4x2 = imat4x2
i32mat4x3 = imat4x3
i32vec1 = ivec1
i32vec2 = ivec2
i32vec3 = ivec3
i32vec4 = ivec4
u32mat2 = umat2x2
u32mat2x2 = umat2x2
umat2 = umat2x2
u32mat2x3 = umat2x3
u32mat2x4 = umat2x4
u32mat3 = umat3x3
u32mat3x3 = umat3x3
umat3 = umat3x3
u32mat3x2 = umat3x2
u32mat3x4 = umat3x4
u32mat4 = umat4x4
u32mat4x4 = umat4x4
umat4 = umat4x4
u32mat4x2 = umat4x2
u32mat4x3 = umat4x3
u32vec1 = uvec1
u32vec2 = uvec2
u32vec3 = uvec3
u32vec4 = uvec4
