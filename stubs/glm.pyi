
from typing import Any, Callable, Generator, Generic, List, Literal, NewType, Optional, overload, Iterable, SupportsFloat, SupportsInt, Tuple, Type, TypeVar, Union
import ctypes

_Number = Union[SupportsFloat, SupportsInt]
_GLM_TYPES = Union[bvec1, bvec2, bvec3, bvec4, dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, dmvec2, dmvec3, dmvec4, dquat, dvec1, dvec2, dvec3, dvec4, i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, mvec2, mvec3, mvec4, quat, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4, vec1, vec2, vec3, vec4]
_VECTOR = Union[bvec1, bvec2, bvec3, bvec4, dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, i8vec2, i8vec3, i8vec4, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, mvec2, mvec3, mvec4, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, u8vec2, u8vec3, u8vec4, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4, vec1, vec2, vec3, vec4]
_FLOAT_VECTOR = Union[dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, mvec2, mvec3, mvec4, vec1, vec2, vec3, vec4]
_QUAT = Union[quat, dquat]

T = TypeVar('T')
_VT = TypeVar('_VT', bound=_VECTOR)
_FVT = TypeVar('_FVT', bound=_FLOAT_VECTOR)
_QT = TypeVar('_QT', bound=_QUAT)


@overload
def abs(x: _Number, /) -> float: ...
@overload
def abs(x: _VT, /) -> _VT: ...

@overload
def ceil(x: _Number, /) -> float: ...
@overload
def ceil(x: _VT, /) -> _VT: ...

@overload
def clamp(x: _Number, min: _Number, max: _Number, /) -> _Number: ...
@overload
def clamp(x: _VT, min: _Number, max: _Number, /) -> _VT: ...
@overload
def clamp(x: _VT, min: _VT, max: _VT, /) -> _VT: ...

@overload
def floatBitsToInt(x: float, /) -> int: ...
@overload
def floatBitsToInt(x: dmvec2, /) -> ivec2: ...
@overload
def floatBitsToInt(x: dmvec3, /) -> ivec3: ...
@overload
def floatBitsToInt(x: dmvec4, /) -> ivec4: ...
@overload
def floatBitsToInt(x: dvec1, /) -> ivec1: ...
@overload
def floatBitsToInt(x: dvec2, /) -> ivec2: ...
@overload
def floatBitsToInt(x: dvec3, /) -> ivec3: ...
@overload
def floatBitsToInt(x: dvec4, /) -> ivec4: ...
@overload
def floatBitsToInt(x: mvec2, /) -> ivec2: ...
@overload
def floatBitsToInt(x: mvec3, /) -> ivec3: ...
@overload
def floatBitsToInt(x: mvec4, /) -> ivec4: ...
@overload
def floatBitsToInt(x: vec1, /) -> ivec1: ...
@overload
def floatBitsToInt(x: vec2, /) -> ivec2: ...
@overload
def floatBitsToInt(x: vec3, /) -> ivec3: ...
@overload
def floatBitsToInt(x: vec4, /) -> ivec4: ...

@overload
def floatBitsToUint(x: float, /) -> int: ...
@overload
def floatBitsToUint(x: dmvec2, /) -> uvec2: ...
@overload
def floatBitsToUint(x: dmvec3, /) -> uvec3: ...
@overload
def floatBitsToUint(x: dmvec4, /) -> uvec4: ...
@overload
def floatBitsToUint(x: dvec1, /) -> uvec1: ...
@overload
def floatBitsToUint(x: dvec2, /) -> uvec2: ...
@overload
def floatBitsToUint(x: dvec3, /) -> uvec3: ...
@overload
def floatBitsToUint(x: dvec4, /) -> uvec4: ...
@overload
def floatBitsToUint(x: mvec2, /) -> uvec2: ...
@overload
def floatBitsToUint(x: mvec3, /) -> uvec3: ...
@overload
def floatBitsToUint(x: mvec4, /) -> uvec4: ...
@overload
def floatBitsToUint(x: vec1, /) -> uvec1: ...
@overload
def floatBitsToUint(x: vec2, /) -> uvec2: ...
@overload
def floatBitsToUint(x: vec3, /) -> uvec3: ...
@overload
def floatBitsToUint(x: vec4, /) -> uvec4: ...

@overload
def floor(x: _Number, /) -> float: ...
@overload
def floor(x: _VT, /) -> _VT: ...

def fma(a: _Number, b: _Number, c: _Number, /) -> float: ...

@overload
def fmax(x: _Number, y: _Number, /) -> float: ...
@overload
def fmax(a: _Number, b: _Number, c: _Number, /) -> float: ...
@overload
def fmax(a: _Number, b: _Number, c: _Number, d: _Number, /) -> float: ...
@overload
def fmax(x: _VT, y: _Number, /) -> _VT: ...
@overload
def fmax(x: _VT, y: _VT, /) -> _VT: ...
@overload
def fmax(a: _VT, b: _VT, c: _VT, /) -> _VT: ...
@overload
def fmax(a: _VT, b: _VT, c: _VT, d: _VT, /) -> _VT: ...

@overload
def fmin(x: _Number, y: _Number, /) -> float: ...
@overload
def fmin(a: _Number, b: _Number, c: _Number, /) -> float: ...
@overload
def fmin(a: _Number, b: _Number, c: _Number, d: _Number, /) -> float: ...
@overload
def fmin(x: _VT, y: _Number, /) -> _VT: ...
@overload
def fmin(x: _VT, y: _VT, /) -> _VT: ...
@overload
def fmin(a: _VT, b: _VT, c: _VT, /) -> _VT: ...
@overload
def fmin(a: _VT, b: _VT, c: _VT, d: _VT, /) -> _VT: ...

@overload
def fract(x: _Number, /) -> float: ...
@overload
def fract(x: _VT, /) -> _VT: ...

@overload
def frexp(x: _Number, /) -> Tuple[float, int]: ...
@overload
def frexp(x: dmvec2, exp: ivec2, /) -> dmvec2: ...
@overload
def frexp(x: dmvec3, exp: ivec3, /) -> dmvec3: ...
@overload
def frexp(x: dmvec4, exp: ivec4, /) -> dmvec4: ...
@overload
def frexp(x: dvec1, exp: ivec1, /) -> dvec1: ...
@overload
def frexp(x: dvec2, exp: ivec2, /) -> dvec2: ...
@overload
def frexp(x: dvec3, exp: ivec3, /) -> dvec3: ...
@overload
def frexp(x: dvec4, exp: ivec4, /) -> dvec4: ...
@overload
def frexp(x: mvec2, exp: ivec2, /) -> mvec2: ...
@overload
def frexp(x: mvec3, exp: ivec3, /) -> mvec3: ...
@overload
def frexp(x: mvec4, exp: ivec4, /) -> mvec4: ...
@overload
def frexp(x: vec1, exp: ivec1, /) -> vec1: ...
@overload
def frexp(x: vec2, exp: ivec2, /) -> vec2: ...
@overload
def frexp(x: vec3, exp: ivec3, /) -> vec3: ...
@overload
def frexp(x: vec4, exp: ivec4, /) -> vec4: ...

@overload
def intBitsToFloat(x: int, /) -> float: ...
@overload
def intBitsToFloat(x: imvec2, /) -> vec2: ...
@overload
def intBitsToFloat(x: imvec3, /) -> vec3: ...
@overload
def intBitsToFloat(x: imvec4, /) -> vec4: ...
@overload
def intBitsToFloat(x: ivec1, /) -> vec1: ...
@overload
def intBitsToFloat(x: ivec2, /) -> vec2: ...
@overload
def intBitsToFloat(x: ivec3, /) -> vec3: ...
@overload
def intBitsToFloat(x: ivec4, /) -> vec4: ...

@overload
def isinf(x: _Number, /) -> bool: ...
@overload
def isinf(x: dmvec2, /) -> bvec2: ...
@overload
def isinf(x: dmvec3, /) -> bvec3: ...
@overload
def isinf(x: dmvec4, /) -> bvec4: ...
@overload
def isinf(x: dvec1, /) -> bvec1: ...
@overload
def isinf(x: dvec2, /) -> bvec2: ...
@overload
def isinf(x: dvec3, /) -> bvec3: ...
@overload
def isinf(x: dvec4, /) -> bvec4: ...
@overload
def isinf(x: mvec2, /) -> bvec2: ...
@overload
def isinf(x: mvec3, /) -> bvec3: ...
@overload
def isinf(x: mvec4, /) -> bvec4: ...
@overload
def isinf(x: vec1, /) -> bvec1: ...
@overload
def isinf(x: vec2, /) -> bvec2: ...
@overload
def isinf(x: vec3, /) -> bvec3: ...
@overload
def isinf(x: vec4, /) -> bvec4: ...
@overload
def isinf(x: _QUAT, /) -> bvec4: ...

@overload
def isnan(x: _Number, /) -> bool: ...
@overload
def isnan(x: dmvec2, /) -> bvec2: ...
@overload
def isnan(x: dmvec3, /) -> bvec3: ...
@overload
def isnan(x: dmvec4, /) -> bvec4: ...
@overload
def isnan(x: dvec1, /) -> bvec1: ...
@overload
def isnan(x: dvec2, /) -> bvec2: ...
@overload
def isnan(x: dvec3, /) -> bvec3: ...
@overload
def isnan(x: dvec4, /) -> bvec4: ...
@overload
def isnan(x: mvec2, /) -> bvec2: ...
@overload
def isnan(x: mvec3, /) -> bvec3: ...
@overload
def isnan(x: mvec4, /) -> bvec4: ...
@overload
def isnan(x: vec1, /) -> bvec1: ...
@overload
def isnan(x: vec2, /) -> bvec2: ...
@overload
def isnan(x: vec3, /) -> bvec3: ...
@overload
def isnan(x: vec4, /) -> bvec4: ...
@overload
def isnan(x: _QUAT, /) -> bvec4: ...

@overload
def ldexp(x: _Number, exp: _Number, /) -> float: ...
@overload
def ldexp(x: dmvec2, exp: ivec2, /) -> dmvec2: ...
@overload
def ldexp(x: dmvec3, exp: ivec3, /) -> dmvec3: ...
@overload
def ldexp(x: dmvec4, exp: ivec4, /) -> dmvec4: ...
@overload
def ldexp(x: dvec1, exp: ivec1, /) -> dvec1: ...
@overload
def ldexp(x: dvec2, exp: ivec2, /) -> dvec2: ...
@overload
def ldexp(x: dvec3, exp: ivec3, /) -> dvec3: ...
@overload
def ldexp(x: dvec4, exp: ivec4, /) -> dvec4: ...
@overload
def ldexp(x: mvec2, exp: ivec2, /) -> mvec2: ...
@overload
def ldexp(x: mvec3, exp: ivec3, /) -> mvec3: ...
@overload
def ldexp(x: mvec4, exp: ivec4, /) -> mvec4: ...
@overload
def ldexp(x: vec1, exp: ivec1, /) -> vec1: ...
@overload
def ldexp(x: vec2, exp: ivec2, /) -> vec2: ...
@overload
def ldexp(x: vec3, exp: ivec3, /) -> vec3: ...
@overload
def ldexp(x: vec4, exp: ivec4, /) -> vec4: ...

@overload
def max(x: _Number, y: _Number, /) -> float: ...
@overload
def max(a: _Number, b: _Number, c: _Number, /) -> float: ...
@overload
def max(a: _Number, b: _Number, c: _Number, d: _Number, /) -> float: ...
@overload
def max(x: _VT, y: _Number, /) -> _VT: ...
@overload
def max(x: _VT, y: _VT, /) -> _VT: ...
@overload
def max(a: _VT, b: _VT, c: _VT, /) -> _VT: ...
@overload
def max(a: _VT, b: _VT, c: _VT, d: _VT, /) -> _VT: ...
@overload
def max(_: Iterable[T], /) -> T: ...

@overload
def min(x: _Number, y: _Number, /) -> float: ...
@overload
def min(a: _Number, b: _Number, c: _Number, /) -> float: ...
@overload
def min(a: _Number, b: _Number, c: _Number, d: _Number, /) -> float: ...
@overload
def min(x: _VT, y: _Number, /) -> _VT: ...
@overload
def min(x: _VT, y: _VT, /) -> _VT: ...
@overload
def min(a: _VT, b: _VT, c: _VT, /) -> _VT: ...
@overload
def min(a: _VT, b: _VT, c: _VT, d: _VT, /) -> _VT: ...
@overload
def min(_: Iterable[T], /) -> T: ...

@overload
def mix(x: _Number, y: _Number, a: _Number, /) -> float: ...
@overload
def mix(x: bvec1, y: bvec1, a: Union[vec1, bvec1], /) -> bvec1: ...
@overload
def mix(x: bvec2, y: bvec2, a: Union[vec2, bvec2], /) -> bvec2: ...
@overload
def mix(x: bvec3, y: bvec3, a: Union[vec3, bvec3], /) -> bvec3: ...
@overload
def mix(x: bvec4, y: bvec4, a: Union[vec4, bvec4], /) -> bvec4: ...
@overload
def mix(x: dmvec2, y: dmvec2, a: Union[vec2, bvec2], /) -> dmvec2: ...
@overload
def mix(x: dmvec3, y: dmvec3, a: Union[vec3, bvec3], /) -> dmvec3: ...
@overload
def mix(x: dmvec4, y: dmvec4, a: Union[vec4, bvec4], /) -> dmvec4: ...
@overload
def mix(x: dvec1, y: dvec1, a: Union[vec1, bvec1], /) -> dvec1: ...
@overload
def mix(x: dvec2, y: dvec2, a: Union[vec2, bvec2], /) -> dvec2: ...
@overload
def mix(x: dvec3, y: dvec3, a: Union[vec3, bvec3], /) -> dvec3: ...
@overload
def mix(x: dvec4, y: dvec4, a: Union[vec4, bvec4], /) -> dvec4: ...
@overload
def mix(x: i16vec1, y: i16vec1, a: Union[vec1, bvec1], /) -> i16vec1: ...
@overload
def mix(x: i16vec2, y: i16vec2, a: Union[vec2, bvec2], /) -> i16vec2: ...
@overload
def mix(x: i16vec3, y: i16vec3, a: Union[vec3, bvec3], /) -> i16vec3: ...
@overload
def mix(x: i16vec4, y: i16vec4, a: Union[vec4, bvec4], /) -> i16vec4: ...
@overload
def mix(x: i64vec1, y: i64vec1, a: Union[vec1, bvec1], /) -> i64vec1: ...
@overload
def mix(x: i64vec2, y: i64vec2, a: Union[vec2, bvec2], /) -> i64vec2: ...
@overload
def mix(x: i64vec3, y: i64vec3, a: Union[vec3, bvec3], /) -> i64vec3: ...
@overload
def mix(x: i64vec4, y: i64vec4, a: Union[vec4, bvec4], /) -> i64vec4: ...
@overload
def mix(x: i8vec1, y: i8vec1, a: Union[vec1, bvec1], /) -> i8vec1: ...
@overload
def mix(x: i8vec2, y: i8vec2, a: Union[vec2, bvec2], /) -> i8vec2: ...
@overload
def mix(x: i8vec3, y: i8vec3, a: Union[vec3, bvec3], /) -> i8vec3: ...
@overload
def mix(x: i8vec4, y: i8vec4, a: Union[vec4, bvec4], /) -> i8vec4: ...
@overload
def mix(x: imvec2, y: imvec2, a: Union[vec2, bvec2], /) -> imvec2: ...
@overload
def mix(x: imvec3, y: imvec3, a: Union[vec3, bvec3], /) -> imvec3: ...
@overload
def mix(x: imvec4, y: imvec4, a: Union[vec4, bvec4], /) -> imvec4: ...
@overload
def mix(x: ivec1, y: ivec1, a: Union[vec1, bvec1], /) -> ivec1: ...
@overload
def mix(x: ivec2, y: ivec2, a: Union[vec2, bvec2], /) -> ivec2: ...
@overload
def mix(x: ivec3, y: ivec3, a: Union[vec3, bvec3], /) -> ivec3: ...
@overload
def mix(x: ivec4, y: ivec4, a: Union[vec4, bvec4], /) -> ivec4: ...
@overload
def mix(x: mvec2, y: mvec2, a: Union[vec2, bvec2], /) -> mvec2: ...
@overload
def mix(x: mvec3, y: mvec3, a: Union[vec3, bvec3], /) -> mvec3: ...
@overload
def mix(x: mvec4, y: mvec4, a: Union[vec4, bvec4], /) -> mvec4: ...
@overload
def mix(x: u16vec1, y: u16vec1, a: Union[vec1, bvec1], /) -> u16vec1: ...
@overload
def mix(x: u16vec2, y: u16vec2, a: Union[vec2, bvec2], /) -> u16vec2: ...
@overload
def mix(x: u16vec3, y: u16vec3, a: Union[vec3, bvec3], /) -> u16vec3: ...
@overload
def mix(x: u16vec4, y: u16vec4, a: Union[vec4, bvec4], /) -> u16vec4: ...
@overload
def mix(x: u64vec1, y: u64vec1, a: Union[vec1, bvec1], /) -> u64vec1: ...
@overload
def mix(x: u64vec2, y: u64vec2, a: Union[vec2, bvec2], /) -> u64vec2: ...
@overload
def mix(x: u64vec3, y: u64vec3, a: Union[vec3, bvec3], /) -> u64vec3: ...
@overload
def mix(x: u64vec4, y: u64vec4, a: Union[vec4, bvec4], /) -> u64vec4: ...
@overload
def mix(x: u8vec1, y: u8vec1, a: Union[vec1, bvec1], /) -> u8vec1: ...
@overload
def mix(x: u8vec2, y: u8vec2, a: Union[vec2, bvec2], /) -> u8vec2: ...
@overload
def mix(x: u8vec3, y: u8vec3, a: Union[vec3, bvec3], /) -> u8vec3: ...
@overload
def mix(x: u8vec4, y: u8vec4, a: Union[vec4, bvec4], /) -> u8vec4: ...
@overload
def mix(x: umvec2, y: umvec2, a: Union[vec2, bvec2], /) -> umvec2: ...
@overload
def mix(x: umvec3, y: umvec3, a: Union[vec3, bvec3], /) -> umvec3: ...
@overload
def mix(x: umvec4, y: umvec4, a: Union[vec4, bvec4], /) -> umvec4: ...
@overload
def mix(x: uvec1, y: uvec1, a: Union[vec1, bvec1], /) -> uvec1: ...
@overload
def mix(x: uvec2, y: uvec2, a: Union[vec2, bvec2], /) -> uvec2: ...
@overload
def mix(x: uvec3, y: uvec3, a: Union[vec3, bvec3], /) -> uvec3: ...
@overload
def mix(x: uvec4, y: uvec4, a: Union[vec4, bvec4], /) -> uvec4: ...
@overload
def mix(x: vec1, y: vec1, a: Union[vec1, bvec1], /) -> vec1: ...
@overload
def mix(x: vec2, y: vec2, a: Union[vec2, bvec2], /) -> vec2: ...
@overload
def mix(x: vec3, y: vec3, a: Union[vec3, bvec3], /) -> vec3: ...
@overload
def mix(x: vec4, y: vec4, a: Union[vec4, bvec4], /) -> vec4: ...
@overload
def mix(x: dmat2x2, y: dmat2x2, a: Union[mat2x2, _Number], /) -> dmat2x2: ...
@overload
def mix(x: dmat2x3, y: dmat2x3, a: Union[mat2x3, _Number], /) -> dmat2x3: ...
@overload
def mix(x: dmat2x4, y: dmat2x4, a: Union[mat2x4, _Number], /) -> dmat2x4: ...
@overload
def mix(x: dmat3x2, y: dmat3x2, a: Union[mat3x2, _Number], /) -> dmat3x2: ...
@overload
def mix(x: dmat3x3, y: dmat3x3, a: Union[mat3x3, _Number], /) -> dmat3x3: ...
@overload
def mix(x: dmat3x4, y: dmat3x4, a: Union[mat3x4, _Number], /) -> dmat3x4: ...
@overload
def mix(x: dmat4x2, y: dmat4x2, a: Union[mat4x2, _Number], /) -> dmat4x2: ...
@overload
def mix(x: dmat4x3, y: dmat4x3, a: Union[mat4x3, _Number], /) -> dmat4x3: ...
@overload
def mix(x: dmat4x4, y: dmat4x4, a: Union[mat4x4, _Number], /) -> dmat4x4: ...
@overload
def mix(x: imat2x2, y: imat2x2, a: Union[mat2x2, _Number], /) -> imat2x2: ...
@overload
def mix(x: imat2x3, y: imat2x3, a: Union[mat2x3, _Number], /) -> imat2x3: ...
@overload
def mix(x: imat2x4, y: imat2x4, a: Union[mat2x4, _Number], /) -> imat2x4: ...
@overload
def mix(x: imat3x2, y: imat3x2, a: Union[mat3x2, _Number], /) -> imat3x2: ...
@overload
def mix(x: imat3x3, y: imat3x3, a: Union[mat3x3, _Number], /) -> imat3x3: ...
@overload
def mix(x: imat3x4, y: imat3x4, a: Union[mat3x4, _Number], /) -> imat3x4: ...
@overload
def mix(x: imat4x2, y: imat4x2, a: Union[mat4x2, _Number], /) -> imat4x2: ...
@overload
def mix(x: imat4x3, y: imat4x3, a: Union[mat4x3, _Number], /) -> imat4x3: ...
@overload
def mix(x: imat4x4, y: imat4x4, a: Union[mat4x4, _Number], /) -> imat4x4: ...
@overload
def mix(x: mat2x2, y: mat2x2, a: Union[mat2x2, _Number], /) -> mat2x2: ...
@overload
def mix(x: mat2x3, y: mat2x3, a: Union[mat2x3, _Number], /) -> mat2x3: ...
@overload
def mix(x: mat2x4, y: mat2x4, a: Union[mat2x4, _Number], /) -> mat2x4: ...
@overload
def mix(x: mat3x2, y: mat3x2, a: Union[mat3x2, _Number], /) -> mat3x2: ...
@overload
def mix(x: mat3x3, y: mat3x3, a: Union[mat3x3, _Number], /) -> mat3x3: ...
@overload
def mix(x: mat3x4, y: mat3x4, a: Union[mat3x4, _Number], /) -> mat3x4: ...
@overload
def mix(x: mat4x2, y: mat4x2, a: Union[mat4x2, _Number], /) -> mat4x2: ...
@overload
def mix(x: mat4x3, y: mat4x3, a: Union[mat4x3, _Number], /) -> mat4x3: ...
@overload
def mix(x: mat4x4, y: mat4x4, a: Union[mat4x4, _Number], /) -> mat4x4: ...
@overload
def mix(x: umat2x2, y: umat2x2, a: Union[mat2x2, _Number], /) -> umat2x2: ...
@overload
def mix(x: umat2x3, y: umat2x3, a: Union[mat2x3, _Number], /) -> umat2x3: ...
@overload
def mix(x: umat2x4, y: umat2x4, a: Union[mat2x4, _Number], /) -> umat2x4: ...
@overload
def mix(x: umat3x2, y: umat3x2, a: Union[mat3x2, _Number], /) -> umat3x2: ...
@overload
def mix(x: umat3x3, y: umat3x3, a: Union[mat3x3, _Number], /) -> umat3x3: ...
@overload
def mix(x: umat3x4, y: umat3x4, a: Union[mat3x4, _Number], /) -> umat3x4: ...
@overload
def mix(x: umat4x2, y: umat4x2, a: Union[mat4x2, _Number], /) -> umat4x2: ...
@overload
def mix(x: umat4x3, y: umat4x3, a: Union[mat4x3, _Number], /) -> umat4x3: ...
@overload
def mix(x: umat4x4, y: umat4x4, a: Union[mat4x4, _Number], /) -> umat4x4: ...
@overload
def mix(x: _QT, y: _QT, a: _Number, /) -> _QT: ...

@overload
def modf(x: _Number, /) -> Tuple[float, float]: ...
@overload
def modf(x: _FVT, i: _FVT, /) -> _FVT: ...

@overload
def round(x: _Number, /) -> float: ...
@overload
def round(x: _FVT, i: _FVT, /) -> _FVT: ...

@overload
def roundEven(x: _Number, /) -> float: ...
@overload
def roundEven(x: _FVT, i: _FVT, /) -> _FVT: ...

@overload
def sign(x: _Number, /) -> float: ...
@overload
def sign(x: _FVT, i: _FVT, /) -> _FVT: ...

@overload
def smoothstep(edge0: _Number, edge1: _Number, x: _Number, /) -> float: ...
@overload
def smoothstep(edge0: _Number, edge1: _Number, x: _FVT, /) -> _FVT: ...
@overload
def smoothstep(edge0: _FVT, edge1: _FVT, x: _FVT, /) -> _FVT: ...

@overload
def step(edge: _Number, x: _Number, /) -> float: ...
@overload
def step(edge: _Number, x: _VT, /) -> _VT: ...
@overload
def step(edge: _VT, x: _VT, /) -> _VT: ...

@overload
def trunc(x: _Number, /) -> float: ...
@overload
def trunc(x: _FVT, /) -> _FVT: ...

@overload
def uintBitsToFloat(x: int, /) -> float: ...
@overload
def uintBitsToFloat(x: umvec2, /) -> vec2: ...
@overload
def uintBitsToFloat(x: umvec3, /) -> vec3: ...
@overload
def uintBitsToFloat(x: umvec4, /) -> vec4: ...
@overload
def uintBitsToFloat(x: uvec1, /) -> vec1: ...
@overload
def uintBitsToFloat(x: uvec2, /) -> vec2: ...
@overload
def uintBitsToFloat(x: uvec3, /) -> vec3: ...
@overload
def uintBitsToFloat(x: uvec4, /) -> vec4: ...



_ARRAY_CTYPES = Union[ctypes.c_bool, ctypes.c_byte, ctypes.c_int8, ctypes.c_ubyte, ctypes.c_uint8, ctypes.c_short, ctypes.c_int16, ctypes.c_ushort, ctypes.c_uint16, ctypes.c_int, ctypes.c_int32, ctypes.c_uint, ctypes.c_uint32, ctypes.c_long, ctypes.c_int64, ctypes.c_ulong, ctypes.c_uint64, ctypes.c_longlong, ctypes.c_ulonglong, ctypes.c_size_t, ctypes.c_ssize_t, ctypes.c_float, ctypes.c_double, ctypes.c_longdouble]
_ARRAY_TYPES = Union[_ARRAY_CTYPES, _GLM_TYPES]

_AT = TypeVar('_AT', bound=_ARRAY_TYPES)
_AT2 = TypeVar('_AT2', bound=_ARRAY_TYPES)
_GT = TypeVar('_GT', bound=_GLM_TYPES)
_ACT = TypeVar('_ACT', bound=_ARRAY_CTYPES)
class array(Generic[_AT]):

    nbytes: int
    typecode: str
    element_type: Type[_AT]
    itemsize: int
    dt_size: int
    address: int
    length: int
    readonly: bool
    reference: Union[_ARRAY_TYPES, array]

    @property
    def ptr(self) -> ctypes.c_void_p: ...

    # todo: can make this more precise by overloading on `self: array[...]`
    @property
    def dtype(self) -> str: ...

    # todo: can make this more precise by overloading on `self: array[...]`
    @property
    def ctype(self) -> _ARRAY_CTYPES: ...

    @overload
    def __init__(self, _1: _AT, /, *_: _AT) -> None: ...
    @overload
    def __init__(self, _: array[_AT], /) -> None: ...
    @overload
    def __init__(self, _: Iterable[_AT], /) -> None: ...

    def __len__(self) -> int: ...
    def __contains__(self, value: Any) -> bool: ...

    @overload
    def __iter__(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]]) -> Generator[float, None, None]: ...
    @overload
    def __iter__(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]]) -> Generator[int, None, None]: ...
    @overload
    def __iter__(self: array[_GT]) -> Generator[_GT, None, None]: ...

    @overload
    def __getitem__(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]], index: int) -> float: ...
    @overload
    def __getitem__(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]], index: int) -> int: ...
    @overload
    def __getitem__(self: array[_GT], index: int) -> _GT: ...
    @overload
    def __getitem__(self, index: slice) -> array[_AT]: ...

    @overload
    def __setitem__(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]], index: int, value: float) -> None: ...
    @overload
    def __setitem__(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]], index: int, value: int) -> None: ...
    @overload
    def __setitem__(self: array[_GT], index: int, value: _AT) -> None: ...
    @overload
    def __setitem__(self, index: slice, value: array[_AT]) -> None: ...

    @staticmethod
    def from_bytes(bytes: bytes, type: Type[_AT], /) -> array[_AT]: ...
    @staticmethod
    def from_numbers(type: Type[_ACT], /, *numbers: _Number) -> array[_ACT]: ...
    @staticmethod
    def zeros(type: Type[_AT], length: int, /) -> array[_AT]: ...

    def to_bytes(self) -> bytes: ...

    @overload
    def to_list(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]]) -> List[float]: ...
    @overload
    def to_list(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]]) -> List[int]: ...
    @overload
    def to_list(self: array[_GT]) -> List[_GT]: ...

    @overload
    def to_tuple(self: Union[array[ctypes.c_float], array[ctypes.c_double], array[ctypes.c_longdouble]]) -> Tuple[float]: ...
    @overload
    def to_tuple(self: Union[array[ctypes.c_bool], array[ctypes.c_byte], array[ctypes.c_int8], array[ctypes.c_ubyte], array[ctypes.c_uint8], array[ctypes.c_short], array[ctypes.c_int16], array[ctypes.c_ushort], array[ctypes.c_uint16], array[ctypes.c_int], array[ctypes.c_int32], array[ctypes.c_uint], array[ctypes.c_uint32], array[ctypes.c_long], array[ctypes.c_int64], array[ctypes.c_ulong], array[ctypes.c_uint64], array[ctypes.c_longlong], array[ctypes.c_ulonglong], array[ctypes.c_size_t], array[ctypes.c_ssize_t]]) -> Tuple[int]: ...
    @overload
    def to_tuple(self: array[_GT]) -> Tuple[_GT]: ...

    # todo: can make this more precise by overloading on `self: array[...]`
    def split_components(self) -> Tuple[array[Any]]: ...

    def reduce(self, func: Callable[[_AT, _AT], _AT], init: Optional[_AT] = None, /) -> _AT: ...
    def filter(self, _: Callable[[_AT], Any], /) -> array[_AT]: ...
    def map(self, _: Callable[[_AT], _AT2], /) -> array[_AT2]: ...
    def sort(self, _: Callable[[_AT], SupportsInt], /) -> array[_AT]: ...
    def concat(self, other: array[_AT], /) -> array[_AT]: ...
    def iconcat(self, other: array[_AT], /) -> None: ...
    def repeat(self, count: int, /) -> array[_AT]: ...
    def irepeat(self, count: int, /) -> None: ...

    @overload
    @staticmethod
    def as_reference(array: array[_AT2], /) -> array[_AT2]: ...
    @overload
    @staticmethod
    def as_reference(obj: _GT, /) -> array[_GT]: ...

    def reinterpret_cast(self, type: Type[_AT2], /) -> array[_AT2]: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def __add__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __iadd__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __sub__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __isub__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __mul__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __imul__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __mod__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __imod__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __pow__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ipow__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __lshift__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ilshift__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __rshift__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __irshift__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __and__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __iand__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __xor__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ixor__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __or__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __ior__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __truediv__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...
    def __itruediv__(self, other: Union[_Number, _AT, array[_AT]]) -> array[_AT]: ...

    def __neg__(self) -> array[_AT]: ...
    def __pos__(self) -> array[_AT]: ...
    def __abs__(self) -> array[_AT]: ...
    def __inv__(self) -> array[_AT]: ...


class bvec1:

    x: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, bvec2, bvec3, bvec4, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec1: ...
    def __pos__(self) -> bvec1: ...
    def __abs__(self) -> bvec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, bvec1]) -> bvec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, bvec1]) -> bvec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, bvec1]) -> bvec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, bvec1]) -> bvec1: ...


class bvec2:

    x: bool
    y: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, bvec3, bvec4, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec2: ...
    def __pos__(self) -> bvec2: ...
    def __abs__(self) -> bvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool, bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, bvec2]) -> bvec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, bvec2]) -> bvec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, bvec2]) -> bvec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, bvec2]) -> bvec2: ...


class bvec3:

    x: bool
    y: bool
    z: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, bvec4, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec3: ...
    def __pos__(self) -> bvec3: ...
    def __abs__(self) -> bvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool, bool, bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, bvec3]) -> bvec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, bvec3]) -> bvec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, bvec3]) -> bvec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, bvec3]) -> bvec3: ...


class bvec4:

    x: bool
    y: bool
    z: bool
    w: bool

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[bool, None, None]: ...

    def __neg__(self) -> bvec4: ...
    def __pos__(self) -> bvec4: ...
    def __abs__(self) -> bvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[bool]: ...
    def to_tuple(self) -> Tuple[bool, bool, bool, bool]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> bvec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, bvec4]) -> bvec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, bvec4]) -> bvec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, bvec4]) -> bvec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, bvec4]) -> bvec4: ...


class dmat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat2x2, mat2x2, umat2x2]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec2, dmvec2]) -> None: ...

    def __neg__(self) -> dmat2x2: ...
    def __pos__(self) -> dmat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat2x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number], dvec1]) -> dvec1: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number], dvec1]) -> dvec1: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number], dvec1]) -> dvec1: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number], dvec1]) -> dvec1: ...


class dmat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat2x3, mat2x3, umat2x3]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec3, dmvec3]) -> None: ...

    def __neg__(self) -> dmat2x3: ...
    def __pos__(self) -> dmat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat2x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat2x3]) -> dmat2x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat2x3]) -> dmat2x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat2x3]) -> dmat2x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat2x3]) -> dmat2x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec3: ...


class dmat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat2x4, mat2x4, umat2x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec4, dmvec4]) -> None: ...

    def __neg__(self) -> dmat2x4: ...
    def __pos__(self) -> dmat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat2x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat2x4]) -> dmat2x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat2x4]) -> dmat2x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat2x4]) -> dmat2x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat2x4]) -> dmat2x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dmat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dmat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat2x2]) -> dmat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec4: ...


class dmat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat3x2, mat3x2, umat3x2]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec2, dmvec2]) -> None: ...

    def __neg__(self) -> dmat3x2: ...
    def __pos__(self) -> dmat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat3x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat3x2]) -> dmat3x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat3x2]) -> dmat3x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat3x2]) -> dmat3x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat3x2]) -> dmat3x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec2: ...


class dmat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, dquat, imat3x3, mat3x3, umat3x3]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec3, dmvec3]) -> None: ...

    def __neg__(self) -> dmat3x3: ...
    def __pos__(self) -> dmat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat3x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], dvec2]) -> dvec2: ...


class dmat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat3x4, mat3x4, umat3x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec4, dmvec4]) -> None: ...

    def __neg__(self) -> dmat3x4: ...
    def __pos__(self) -> dmat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat3x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat3x4]) -> dmat3x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat3x4]) -> dmat3x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat3x4]) -> dmat3x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat3x4]) -> dmat3x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dmat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat3x3]) -> dmat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dmat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec4: ...


class dmat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat4x2, mat4x2, umat4x2]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec2, dmvec2]) -> None: ...

    def __neg__(self) -> dmat4x2: ...
    def __pos__(self) -> dmat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat4x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat4x2]) -> dmat4x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat4x2]) -> dmat4x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat4x2]) -> dmat4x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, dmat4x2]) -> dmat4x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec2: ...


class dmat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, imat4x3, mat4x3, umat4x3]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec3, dmvec3]) -> None: ...

    def __neg__(self) -> dmat4x3: ...
    def __pos__(self) -> dmat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat4x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat4x3]) -> dmat4x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat4x3]) -> dmat4x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat4x3]) -> dmat4x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, dmat4x3]) -> dmat4x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec3: ...


class dmat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, _12: _Number, _13: _Number, _14: _Number, _15: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, dmat2x3, dmat2x4, dmat3x2, dmat3x3, dmat3x4, dmat4x2, dmat4x3, dmat4x4, dquat, imat4x4, mat4x4, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[dmvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> dmvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[dvec4, dmvec4]) -> None: ...

    def __neg__(self) -> dmat4x4: ...
    def __pos__(self) -> dmat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmat4x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, dmat4x4]) -> dmat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dmat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dmat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...


class dmvec2:

    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], dvec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dmvec2: ...
    def __pos__(self) -> dmvec2: ...
    def __abs__(self) -> dmvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmvec2: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __add__(self, other: _Number) -> dmvec2: ...
    @overload
    def __add__(self, other: dvec2) -> dvec2: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __iadd__(self, other: _Number) -> dmvec2: ...
    @overload
    def __iadd__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __sub__(self, other: _Number) -> dmvec2: ...
    @overload
    def __sub__(self, other: dvec2) -> dvec2: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __isub__(self, other: _Number) -> dmvec2: ...
    @overload
    def __isub__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __mul__(self, other: _Number) -> dmvec2: ...
    @overload
    def __mul__(self, other: dmat2x2) -> dvec2: ...
    @overload
    def __mul__(self, other: dmat3x2) -> dvec3: ...
    @overload
    def __mul__(self, other: dmat4x2) -> dvec4: ...
    @overload
    def __mul__(self, other: dvec2) -> dvec2: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __imul__(self, other: _Number) -> dmvec2: ...
    @overload
    def __imul__(self, other: dmat2x2) -> dvec2: ...
    @overload
    def __imul__(self, other: dmat3x2) -> dvec3: ...
    @overload
    def __imul__(self, other: dmat4x2) -> dvec4: ...
    @overload
    def __imul__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __mod__(self, other: _Number) -> dmvec2: ...
    @overload
    def __mod__(self, other: dvec2) -> dvec2: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __imod__(self, other: _Number) -> dmvec2: ...
    @overload
    def __imod__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __pow__(self, other: _Number) -> dmvec2: ...
    @overload
    def __pow__(self, other: dvec2) -> dvec2: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __ipow__(self, other: _Number) -> dmvec2: ...
    @overload
    def __ipow__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __floordiv__(self, other: _Number) -> dmvec2: ...
    @overload
    def __floordiv__(self, other: dvec2) -> dvec2: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> dmvec2: ...
    @overload
    def __ifloordiv__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec2: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __truediv__(self, other: _Number) -> dmvec2: ...
    @overload
    def __truediv__(self, other: dmat2x2) -> dvec2: ...
    @overload
    def __truediv__(self, other: dvec2) -> dvec2: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec2: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __itruediv__(self, other: _Number) -> dmvec2: ...
    @overload
    def __itruediv__(self, other: dmat2x2) -> dvec2: ...
    @overload
    def __itruediv__(self, other: dvec2) -> dmvec2: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number]) -> dvec2: ...
    @overload
    def __matmul__(self, other: _Number) -> dmvec2: ...
    @overload
    def __matmul__(self, other: dmat2x2) -> dvec2: ...
    @overload
    def __matmul__(self, other: dmat3x2) -> dvec3: ...
    @overload
    def __matmul__(self, other: dmat4x2) -> dvec4: ...
    @overload
    def __matmul__(self, other: dvec2) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> dmvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number]) -> dmvec2: ...
    @overload
    def __imatmul__(self, other: _Number) -> dmvec2: ...
    @overload
    def __imatmul__(self, other: dmat2x2) -> dmvec2: ...
    @overload
    def __imatmul__(self, other: dmat3x2) -> dvec3: ...
    @overload
    def __imatmul__(self, other: dmat4x2) -> dvec4: ...
    @overload
    def __imatmul__(self, other: dvec2) -> dmvec2: ...

    def __divmod__(self, other: dvec2) -> Tuple[dvec2, dvec2]: ...


class dmvec3:

    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], dvec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dmvec3: ...
    def __pos__(self) -> dmvec3: ...
    def __abs__(self) -> dmvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmvec3: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __add__(self, other: _Number) -> dmvec3: ...
    @overload
    def __add__(self, other: dvec3) -> dvec3: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __iadd__(self, other: _Number) -> dmvec3: ...
    @overload
    def __iadd__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __sub__(self, other: _Number) -> dmvec3: ...
    @overload
    def __sub__(self, other: dvec3) -> dvec3: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __isub__(self, other: _Number) -> dmvec3: ...
    @overload
    def __isub__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __mul__(self, other: _Number) -> dmvec3: ...
    @overload
    def __mul__(self, other: dmat2x3) -> dvec2: ...
    @overload
    def __mul__(self, other: dmat3x3) -> dvec3: ...
    @overload
    def __mul__(self, other: dmat4x3) -> dvec4: ...
    @overload
    def __mul__(self, other: dvec3) -> dvec3: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __imul__(self, other: _Number) -> dmvec3: ...
    @overload
    def __imul__(self, other: dmat2x3) -> dvec2: ...
    @overload
    def __imul__(self, other: dmat3x3) -> dvec3: ...
    @overload
    def __imul__(self, other: dmat4x3) -> dvec4: ...
    @overload
    def __imul__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __mod__(self, other: _Number) -> dmvec3: ...
    @overload
    def __mod__(self, other: dvec3) -> dvec3: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __imod__(self, other: _Number) -> dmvec3: ...
    @overload
    def __imod__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __pow__(self, other: _Number) -> dmvec3: ...
    @overload
    def __pow__(self, other: dvec3) -> dvec3: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __ipow__(self, other: _Number) -> dmvec3: ...
    @overload
    def __ipow__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __floordiv__(self, other: _Number) -> dmvec3: ...
    @overload
    def __floordiv__(self, other: dvec3) -> dvec3: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> dmvec3: ...
    @overload
    def __ifloordiv__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __truediv__(self, other: _Number) -> dmvec3: ...
    @overload
    def __truediv__(self, other: dmat3x3) -> dvec3: ...
    @overload
    def __truediv__(self, other: dvec3) -> dvec3: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __itruediv__(self, other: _Number) -> dmvec3: ...
    @overload
    def __itruediv__(self, other: dmat3x3) -> dvec3: ...
    @overload
    def __itruediv__(self, other: dvec3) -> dmvec3: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number]) -> dvec3: ...
    @overload
    def __matmul__(self, other: _Number) -> dmvec3: ...
    @overload
    def __matmul__(self, other: dmat2x3) -> dvec2: ...
    @overload
    def __matmul__(self, other: dmat3x3) -> dvec3: ...
    @overload
    def __matmul__(self, other: dmat4x3) -> dvec4: ...
    @overload
    def __matmul__(self, other: dvec3) -> dvec3: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dmvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number]) -> dmvec3: ...
    @overload
    def __imatmul__(self, other: _Number) -> dmvec3: ...
    @overload
    def __imatmul__(self, other: dmat2x3) -> dvec2: ...
    @overload
    def __imatmul__(self, other: dmat3x3) -> dmvec3: ...
    @overload
    def __imatmul__(self, other: dmat4x3) -> dvec4: ...
    @overload
    def __imatmul__(self, other: dvec3) -> dmvec3: ...

    def __divmod__(self, other: dvec3) -> Tuple[dvec3, dvec3]: ...


class dmvec4:

    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dmvec4: ...
    def __pos__(self) -> dmvec4: ...
    def __abs__(self) -> dmvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dmvec4: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __add__(self, other: _Number) -> dmvec4: ...
    @overload
    def __add__(self, other: dvec4) -> dvec4: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __iadd__(self, other: _Number) -> dmvec4: ...
    @overload
    def __iadd__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __sub__(self, other: _Number) -> dmvec4: ...
    @overload
    def __sub__(self, other: dvec4) -> dvec4: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __isub__(self, other: _Number) -> dmvec4: ...
    @overload
    def __isub__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __mul__(self, other: _Number) -> dmvec4: ...
    @overload
    def __mul__(self, other: dmat2x4) -> dvec2: ...
    @overload
    def __mul__(self, other: dmat3x4) -> dvec3: ...
    @overload
    def __mul__(self, other: dmat4x4) -> dvec4: ...
    @overload
    def __mul__(self, other: dvec4) -> dvec4: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __imul__(self, other: _Number) -> dmvec4: ...
    @overload
    def __imul__(self, other: dmat2x4) -> dvec2: ...
    @overload
    def __imul__(self, other: dmat3x4) -> dvec3: ...
    @overload
    def __imul__(self, other: dmat4x4) -> dvec4: ...
    @overload
    def __imul__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __mod__(self, other: _Number) -> dmvec4: ...
    @overload
    def __mod__(self, other: dvec4) -> dvec4: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __imod__(self, other: _Number) -> dmvec4: ...
    @overload
    def __imod__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __pow__(self, other: _Number) -> dmvec4: ...
    @overload
    def __pow__(self, other: dvec4) -> dvec4: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __ipow__(self, other: _Number) -> dmvec4: ...
    @overload
    def __ipow__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __floordiv__(self, other: _Number) -> dmvec4: ...
    @overload
    def __floordiv__(self, other: dvec4) -> dvec4: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> dmvec4: ...
    @overload
    def __ifloordiv__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __truediv__(self, other: _Number) -> dmvec4: ...
    @overload
    def __truediv__(self, other: dmat4x4) -> dvec4: ...
    @overload
    def __truediv__(self, other: dvec4) -> dvec4: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __itruediv__(self, other: _Number) -> dmvec4: ...
    @overload
    def __itruediv__(self, other: dmat4x4) -> dvec4: ...
    @overload
    def __itruediv__(self, other: dvec4) -> dmvec4: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dvec4: ...
    @overload
    def __matmul__(self, other: _Number) -> dmvec4: ...
    @overload
    def __matmul__(self, other: dmat2x4) -> dvec2: ...
    @overload
    def __matmul__(self, other: dmat3x4) -> dvec3: ...
    @overload
    def __matmul__(self, other: dmat4x4) -> dvec4: ...
    @overload
    def __matmul__(self, other: dvec4) -> dvec4: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dmvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> dvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> dmvec4: ...
    @overload
    def __imatmul__(self, other: _Number) -> dmvec4: ...
    @overload
    def __imatmul__(self, other: dmat2x4) -> dvec2: ...
    @overload
    def __imatmul__(self, other: dmat3x4) -> dvec3: ...
    @overload
    def __imatmul__(self, other: dmat4x4) -> dmvec4: ...
    @overload
    def __imatmul__(self, other: dvec4) -> dmvec4: ...

    def __divmod__(self, other: dvec4) -> Tuple[dvec4, dvec4]: ...


class dquat:

    x: float
    y: float
    w: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, w: _Number, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], dmat3x3, dmat4x4, dmvec3, dquat, dvec3, quat]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dquat: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...


    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __mul__(self, other: Union[_Number]) -> dquat: ...

    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __imul__(self, other: Union[_Number]) -> dquat: ...

    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Union[_Number]) -> dquat: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], dvec4]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], dvec3]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Union[_Number]) -> dquat: ...


class dvec1:

    x: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dmvec2, dmvec3, dmvec4, dvec1, dvec2, dvec3, dvec4, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec1: ...
    def __pos__(self) -> dvec1: ...
    def __abs__(self) -> dvec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __pow__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __ipow__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __floordiv__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, dvec1]) -> dvec1: ...

    def __divmod__(self, other: Union[dvec1]) -> Tuple[dvec1, dvec1]: ...


class dvec2:

    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dmvec3, dmvec4, dvec2, dvec3, dvec4, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec2: ...
    def __pos__(self) -> dvec2: ...
    def __abs__(self) -> dvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number], _Number, dvec2]) -> dvec2: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, dmat2x2, dvec2]) -> dvec2: ...

    def __divmod__(self, other: Union[dvec2]) -> Tuple[dvec2, dvec2]: ...


class dvec3:

    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dmvec4, dvec3, dvec4, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec3: ...
    def __pos__(self) -> dvec3: ...
    def __abs__(self) -> dvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, dvec3]) -> dvec3: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat4x3]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, dmat3x3, dvec3]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], dmat2x3]) -> dvec2: ...

    def __divmod__(self, other: Union[dvec3]) -> Tuple[dvec3, dvec3]: ...


class dvec4:

    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> dvec4: ...
    def __pos__(self) -> dvec4: ...
    def __abs__(self) -> dvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> dvec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, dvec4]) -> dvec4: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, dmat4x4, dvec4]) -> dvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat3x4]) -> dvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], dmat2x4]) -> dvec2: ...

    def __divmod__(self, other: Union[dvec4]) -> Tuple[dvec4, dvec4]: ...


class i16vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i16vec2, i16vec3, i16vec4, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec1: ...
    def __pos__(self) -> i16vec1: ...
    def __abs__(self) -> i16vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, i16vec1]) -> i16vec1: ...


class i16vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i16vec3, i16vec4, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec2: ...
    def __pos__(self) -> i16vec2: ...
    def __abs__(self) -> i16vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, i16vec2]) -> i16vec2: ...


class i16vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i16vec4, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec3: ...
    def __pos__(self) -> i16vec3: ...
    def __abs__(self) -> i16vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i16vec3]) -> i16vec3: ...


class i16vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i16vec4: ...
    def __pos__(self) -> i16vec4: ...
    def __abs__(self) -> i16vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i16vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i16vec4]) -> i16vec4: ...


class i64vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i64vec2, i64vec3, i64vec4, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec1: ...
    def __pos__(self) -> i64vec1: ...
    def __abs__(self) -> i64vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, i64vec1]) -> i64vec1: ...


class i64vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i64vec3, i64vec4, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec2: ...
    def __pos__(self) -> i64vec2: ...
    def __abs__(self) -> i64vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, i64vec2]) -> i64vec2: ...


class i64vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i64vec4, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec3: ...
    def __pos__(self) -> i64vec3: ...
    def __abs__(self) -> i64vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i64vec3]) -> i64vec3: ...


class i64vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i64vec4: ...
    def __pos__(self) -> i64vec4: ...
    def __abs__(self) -> i64vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i64vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i64vec4]) -> i64vec4: ...


class i8vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, i8vec2, i8vec3, i8vec4, ivec1, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec1: ...
    def __pos__(self) -> i8vec1: ...
    def __abs__(self) -> i8vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, i8vec1]) -> i8vec1: ...


class i8vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, i8vec3, i8vec4, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec2: ...
    def __pos__(self) -> i8vec2: ...
    def __abs__(self) -> i8vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, i8vec2]) -> i8vec2: ...


class i8vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, i8vec4, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec3: ...
    def __pos__(self) -> i8vec3: ...
    def __abs__(self) -> i8vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, i8vec3]) -> i8vec3: ...


class i8vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> i8vec4: ...
    def __pos__(self) -> i8vec4: ...
    def __abs__(self) -> i8vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> i8vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, i8vec4]) -> i8vec4: ...


class imat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat2x2, umat2x2]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec2, imvec2]) -> None: ...

    def __neg__(self) -> imat2x2: ...
    def __pos__(self) -> imat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat2x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number], ivec1]) -> ivec1: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number], ivec1]) -> ivec1: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number], ivec1]) -> ivec1: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number], ivec1]) -> ivec1: ...


class imat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x3, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat2x3, umat2x3]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec3, imvec3]) -> None: ...

    def __neg__(self) -> imat2x3: ...
    def __pos__(self) -> imat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat2x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat2x3]) -> imat2x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat2x3]) -> imat2x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat2x3]) -> imat2x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat2x3]) -> imat2x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec3: ...


class imat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat2x4, umat2x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec4, imvec4]) -> None: ...

    def __neg__(self) -> imat2x4: ...
    def __pos__(self) -> imat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat2x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat2x4]) -> imat2x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat2x4]) -> imat2x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat2x4]) -> imat2x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat2x4]) -> imat2x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> imat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> imat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat2x2]) -> imat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec4: ...


class imat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat3x2, umat3x2]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec2, imvec2]) -> None: ...

    def __neg__(self) -> imat3x2: ...
    def __pos__(self) -> imat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat3x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat3x2]) -> imat3x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat3x2]) -> imat3x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat3x2]) -> imat3x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat3x2]) -> imat3x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec2: ...


class imat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x3, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat3x3, umat3x3]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec3, imvec3]) -> None: ...

    def __neg__(self) -> imat3x3: ...
    def __pos__(self) -> imat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat3x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], ivec2]) -> ivec2: ...


class imat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat3x4, umat3x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec4, imvec4]) -> None: ...

    def __neg__(self) -> imat3x4: ...
    def __pos__(self) -> imat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat3x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat3x4]) -> imat3x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat3x4]) -> imat3x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat3x4]) -> imat3x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat3x4]) -> imat3x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> imat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat3x3]) -> imat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> imat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec4: ...


class imat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat4x2, umat4x2]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec2, imvec2]) -> None: ...

    def __neg__(self) -> imat4x2: ...
    def __pos__(self) -> imat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat4x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat4x2]) -> imat4x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat4x2]) -> imat4x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat4x2]) -> imat4x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, imat4x2]) -> imat4x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec2: ...


class imat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x3, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat4x3, umat4x3]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec3, imvec3]) -> None: ...

    def __neg__(self) -> imat4x3: ...
    def __pos__(self) -> imat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat4x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat4x3]) -> imat4x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat4x3]) -> imat4x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat4x3]) -> imat4x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, imat4x3]) -> imat4x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec3: ...


class imat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, _12: _Number, _13: _Number, _14: _Number, _15: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x4, imat2x2, imat2x3, imat2x4, imat3x2, imat3x3, imat3x4, imat4x2, imat4x3, imat4x4, mat4x4, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[imvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> imvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[ivec4, imvec4]) -> None: ...

    def __neg__(self) -> imat4x4: ...
    def __pos__(self) -> imat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imat4x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, imat4x4]) -> imat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> imat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> imat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], ivec3]) -> ivec3: ...


class imvec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], ivec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> imvec2: ...
    def __pos__(self) -> imvec2: ...
    def __abs__(self) -> imvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imvec2: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __add__(self, other: _Number) -> imvec2: ...
    @overload
    def __add__(self, other: ivec2) -> ivec2: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number]) -> imvec2: ...
    @overload
    def __iadd__(self, other: _Number) -> imvec2: ...
    @overload
    def __iadd__(self, other: ivec2) -> imvec2: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __sub__(self, other: _Number) -> imvec2: ...
    @overload
    def __sub__(self, other: ivec2) -> ivec2: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number]) -> imvec2: ...
    @overload
    def __isub__(self, other: _Number) -> imvec2: ...
    @overload
    def __isub__(self, other: ivec2) -> imvec2: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __mul__(self, other: _Number) -> imvec2: ...
    @overload
    def __mul__(self, other: imat2x2) -> ivec2: ...
    @overload
    def __mul__(self, other: imat3x2) -> ivec3: ...
    @overload
    def __mul__(self, other: imat4x2) -> ivec4: ...
    @overload
    def __mul__(self, other: ivec2) -> ivec2: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number]) -> imvec2: ...
    @overload
    def __imul__(self, other: _Number) -> imvec2: ...
    @overload
    def __imul__(self, other: imat2x2) -> ivec2: ...
    @overload
    def __imul__(self, other: imat3x2) -> ivec3: ...
    @overload
    def __imul__(self, other: imat4x2) -> ivec4: ...
    @overload
    def __imul__(self, other: ivec2) -> imvec2: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __mod__(self, other: _Number) -> imvec2: ...
    @overload
    def __mod__(self, other: ivec2) -> ivec2: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __imod__(self, other: _Number) -> imvec2: ...
    @overload
    def __imod__(self, other: ivec2) -> ivec2: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __truediv__(self, other: _Number) -> imvec2: ...
    @overload
    def __truediv__(self, other: ivec2) -> ivec2: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number]) -> imvec2: ...
    @overload
    def __itruediv__(self, other: _Number) -> imvec2: ...
    @overload
    def __itruediv__(self, other: ivec2) -> imvec2: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number]) -> ivec2: ...
    @overload
    def __matmul__(self, other: _Number) -> imvec2: ...
    @overload
    def __matmul__(self, other: imat2x2) -> ivec2: ...
    @overload
    def __matmul__(self, other: imat3x2) -> ivec3: ...
    @overload
    def __matmul__(self, other: imat4x2) -> ivec4: ...
    @overload
    def __matmul__(self, other: ivec2) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> imvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number]) -> imvec2: ...
    @overload
    def __imatmul__(self, other: _Number) -> imvec2: ...
    @overload
    def __imatmul__(self, other: imat2x2) -> imvec2: ...
    @overload
    def __imatmul__(self, other: imat3x2) -> ivec3: ...
    @overload
    def __imatmul__(self, other: imat4x2) -> ivec4: ...
    @overload
    def __imatmul__(self, other: ivec2) -> imvec2: ...


class imvec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], ivec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> imvec3: ...
    def __pos__(self) -> imvec3: ...
    def __abs__(self) -> imvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imvec3: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __add__(self, other: _Number) -> imvec3: ...
    @overload
    def __add__(self, other: ivec3) -> ivec3: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number]) -> imvec3: ...
    @overload
    def __iadd__(self, other: _Number) -> imvec3: ...
    @overload
    def __iadd__(self, other: ivec3) -> imvec3: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __sub__(self, other: _Number) -> imvec3: ...
    @overload
    def __sub__(self, other: ivec3) -> ivec3: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number]) -> imvec3: ...
    @overload
    def __isub__(self, other: _Number) -> imvec3: ...
    @overload
    def __isub__(self, other: ivec3) -> imvec3: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __mul__(self, other: _Number) -> imvec3: ...
    @overload
    def __mul__(self, other: imat2x3) -> ivec2: ...
    @overload
    def __mul__(self, other: imat3x3) -> ivec3: ...
    @overload
    def __mul__(self, other: imat4x3) -> ivec4: ...
    @overload
    def __mul__(self, other: ivec3) -> ivec3: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number]) -> imvec3: ...
    @overload
    def __imul__(self, other: _Number) -> imvec3: ...
    @overload
    def __imul__(self, other: imat2x3) -> ivec2: ...
    @overload
    def __imul__(self, other: imat3x3) -> ivec3: ...
    @overload
    def __imul__(self, other: imat4x3) -> ivec4: ...
    @overload
    def __imul__(self, other: ivec3) -> imvec3: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __mod__(self, other: _Number) -> imvec3: ...
    @overload
    def __mod__(self, other: ivec3) -> ivec3: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __imod__(self, other: _Number) -> imvec3: ...
    @overload
    def __imod__(self, other: ivec3) -> ivec3: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __truediv__(self, other: _Number) -> imvec3: ...
    @overload
    def __truediv__(self, other: ivec3) -> ivec3: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number]) -> imvec3: ...
    @overload
    def __itruediv__(self, other: _Number) -> imvec3: ...
    @overload
    def __itruediv__(self, other: ivec3) -> imvec3: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number]) -> ivec3: ...
    @overload
    def __matmul__(self, other: _Number) -> imvec3: ...
    @overload
    def __matmul__(self, other: imat2x3) -> ivec2: ...
    @overload
    def __matmul__(self, other: imat3x3) -> ivec3: ...
    @overload
    def __matmul__(self, other: imat4x3) -> ivec4: ...
    @overload
    def __matmul__(self, other: ivec3) -> ivec3: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> imvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number]) -> imvec3: ...
    @overload
    def __imatmul__(self, other: _Number) -> imvec3: ...
    @overload
    def __imatmul__(self, other: imat2x3) -> ivec2: ...
    @overload
    def __imatmul__(self, other: imat3x3) -> imvec3: ...
    @overload
    def __imatmul__(self, other: imat4x3) -> ivec4: ...
    @overload
    def __imatmul__(self, other: ivec3) -> imvec3: ...


class imvec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], ivec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> imvec4: ...
    def __pos__(self) -> imvec4: ...
    def __abs__(self) -> imvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> imvec4: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __add__(self, other: _Number) -> imvec4: ...
    @overload
    def __add__(self, other: ivec4) -> ivec4: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> imvec4: ...
    @overload
    def __iadd__(self, other: _Number) -> imvec4: ...
    @overload
    def __iadd__(self, other: ivec4) -> imvec4: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __sub__(self, other: _Number) -> imvec4: ...
    @overload
    def __sub__(self, other: ivec4) -> ivec4: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> imvec4: ...
    @overload
    def __isub__(self, other: _Number) -> imvec4: ...
    @overload
    def __isub__(self, other: ivec4) -> imvec4: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __mul__(self, other: _Number) -> imvec4: ...
    @overload
    def __mul__(self, other: imat2x4) -> ivec2: ...
    @overload
    def __mul__(self, other: imat3x4) -> ivec3: ...
    @overload
    def __mul__(self, other: imat4x4) -> ivec4: ...
    @overload
    def __mul__(self, other: ivec4) -> ivec4: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> imvec4: ...
    @overload
    def __imul__(self, other: _Number) -> imvec4: ...
    @overload
    def __imul__(self, other: imat2x4) -> ivec2: ...
    @overload
    def __imul__(self, other: imat3x4) -> ivec3: ...
    @overload
    def __imul__(self, other: imat4x4) -> ivec4: ...
    @overload
    def __imul__(self, other: ivec4) -> imvec4: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __mod__(self, other: _Number) -> imvec4: ...
    @overload
    def __mod__(self, other: ivec4) -> ivec4: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __imod__(self, other: _Number) -> imvec4: ...
    @overload
    def __imod__(self, other: ivec4) -> ivec4: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __truediv__(self, other: _Number) -> imvec4: ...
    @overload
    def __truediv__(self, other: ivec4) -> ivec4: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> imvec4: ...
    @overload
    def __itruediv__(self, other: _Number) -> imvec4: ...
    @overload
    def __itruediv__(self, other: ivec4) -> imvec4: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> ivec4: ...
    @overload
    def __matmul__(self, other: _Number) -> imvec4: ...
    @overload
    def __matmul__(self, other: imat2x4) -> ivec2: ...
    @overload
    def __matmul__(self, other: imat3x4) -> ivec3: ...
    @overload
    def __matmul__(self, other: imat4x4) -> ivec4: ...
    @overload
    def __matmul__(self, other: ivec4) -> ivec4: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> imvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> ivec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> imvec4: ...
    @overload
    def __imatmul__(self, other: _Number) -> imvec4: ...
    @overload
    def __imatmul__(self, other: imat2x4) -> ivec2: ...
    @overload
    def __imatmul__(self, other: imat3x4) -> ivec3: ...
    @overload
    def __imatmul__(self, other: imat4x4) -> imvec4: ...
    @overload
    def __imatmul__(self, other: ivec4) -> imvec4: ...


class ivec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, imvec2, imvec3, imvec4, ivec1, ivec2, ivec3, ivec4, u16vec1, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec1: ...
    def __pos__(self) -> ivec1: ...
    def __abs__(self) -> ivec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, ivec1]) -> ivec1: ...


class ivec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, imvec3, imvec4, ivec2, ivec3, ivec4, mvec2, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec2: ...
    def __pos__(self) -> ivec2: ...
    def __abs__(self) -> ivec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> ivec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> ivec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, imat2x2, ivec2]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> ivec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> ivec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, imat2x2, ivec2]) -> ivec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, ivec2]) -> ivec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, imat2x2, ivec2]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat4x2]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], imat3x2]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, imat2x2, ivec2]) -> ivec2: ...


class ivec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, imvec4, ivec3, ivec4, mvec3, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec3: ...
    def __pos__(self) -> ivec3: ...
    def __abs__(self) -> ivec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> ivec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, imat3x3, ivec3]) -> ivec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> ivec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, imat3x3, ivec3]) -> ivec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> ivec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, ivec3]) -> ivec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, imat3x3, ivec3]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat4x3]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, imat3x3, ivec3]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], imat2x3]) -> ivec2: ...


class ivec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> ivec4: ...
    def __pos__(self) -> ivec4: ...
    def __abs__(self) -> ivec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> ivec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, imat4x4, ivec4]) -> ivec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> ivec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> ivec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, imat4x4, ivec4]) -> ivec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> ivec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> ivec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, ivec4]) -> ivec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, imat4x4, ivec4]) -> ivec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> ivec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> ivec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, imat4x4, ivec4]) -> ivec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat3x4]) -> ivec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], imat2x4]) -> ivec2: ...


class mat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, imat2x2, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat2x2]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec2, mvec2]) -> None: ...

    def __neg__(self) -> mat2x2: ...
    def __pos__(self) -> mat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat2x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number], vec1]) -> vec1: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number], vec1]) -> vec1: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number], vec1]) -> vec1: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number], vec1]) -> vec1: ...


class mat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x3, imat2x3, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat2x3]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec3, mvec3]) -> None: ...

    def __neg__(self) -> mat2x3: ...
    def __pos__(self) -> mat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat2x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat2x3]) -> mat2x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat2x3]) -> mat2x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat2x3]) -> mat2x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat2x3]) -> mat2x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec3: ...


class mat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x4, imat2x4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat2x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec4, mvec4]) -> None: ...

    def __neg__(self) -> mat2x4: ...
    def __pos__(self) -> mat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat2x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat2x4]) -> mat2x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat2x4]) -> mat2x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat2x4]) -> mat2x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat2x4]) -> mat2x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> mat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> mat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat2x2]) -> mat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec4: ...


class mat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2, imat3x2, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat3x2]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec2, mvec2]) -> None: ...

    def __neg__(self) -> mat3x2: ...
    def __pos__(self) -> mat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat3x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat3x2]) -> mat3x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat3x2]) -> mat3x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat3x2]) -> mat3x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat3x2]) -> mat3x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec2: ...


class mat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x3, imat3x3, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, quat, umat3x3]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec3, mvec3]) -> None: ...

    def __neg__(self) -> mat3x3: ...
    def __pos__(self) -> mat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat3x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], vec2]) -> vec2: ...


class mat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x4, imat3x4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat3x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec4, mvec4]) -> None: ...

    def __neg__(self) -> mat3x4: ...
    def __pos__(self) -> mat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat3x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat3x4]) -> mat3x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat3x4]) -> mat3x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat3x4]) -> mat3x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat3x4]) -> mat3x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> mat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat3x3]) -> mat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> mat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec4: ...


class mat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2, imat4x2, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat4x2]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec2, mvec2]) -> None: ...

    def __neg__(self) -> mat4x2: ...
    def __pos__(self) -> mat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float], Tuple[float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat4x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat4x2]) -> mat4x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat4x2]) -> mat4x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat4x2]) -> mat4x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, mat4x2]) -> mat4x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec2: ...


class mat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x3, imat4x3, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, umat4x3]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec3, mvec3]) -> None: ...

    def __neg__(self) -> mat4x3: ...
    def __pos__(self) -> mat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float], Tuple[float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat4x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat4x3]) -> mat4x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat4x3]) -> mat4x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat4x3]) -> mat4x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, mat4x3]) -> mat4x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec3: ...


class mat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, _12: _Number, _13: _Number, _14: _Number, _15: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x4, imat4x4, mat2x2, mat2x3, mat2x4, mat3x2, mat3x3, mat3x4, mat4x2, mat4x3, mat4x4, quat, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[mvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> float: ...
    @overload
    def __getitem__(self, index: int) -> mvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[vec4, mvec4]) -> None: ...

    def __neg__(self) -> mat4x4: ...
    def __pos__(self) -> mat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[float]]: ...
    def to_tuple(self) -> Tuple[Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float], Tuple[float, float, float, float]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mat4x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...

    @overload
    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...

    @overload
    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, mat4x4]) -> mat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> mat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> mat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...


class mvec2:

    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> mvec2: ...
    def __pos__(self) -> mvec2: ...
    def __abs__(self) -> mvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mvec2: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __add__(self, other: _Number) -> mvec2: ...
    @overload
    def __add__(self, other: vec2) -> vec2: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __iadd__(self, other: _Number) -> mvec2: ...
    @overload
    def __iadd__(self, other: vec2) -> mvec2: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __sub__(self, other: _Number) -> mvec2: ...
    @overload
    def __sub__(self, other: vec2) -> vec2: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __isub__(self, other: _Number) -> mvec2: ...
    @overload
    def __isub__(self, other: vec2) -> mvec2: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __mul__(self, other: _Number) -> mvec2: ...
    @overload
    def __mul__(self, other: mat2x2) -> vec2: ...
    @overload
    def __mul__(self, other: mat3x2) -> vec3: ...
    @overload
    def __mul__(self, other: mat4x2) -> vec4: ...
    @overload
    def __mul__(self, other: vec2) -> vec2: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __imul__(self, other: _Number) -> mvec2: ...
    @overload
    def __imul__(self, other: mat2x2) -> vec2: ...
    @overload
    def __imul__(self, other: mat3x2) -> vec3: ...
    @overload
    def __imul__(self, other: mat4x2) -> vec4: ...
    @overload
    def __imul__(self, other: vec2) -> mvec2: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __mod__(self, other: _Number) -> mvec2: ...
    @overload
    def __mod__(self, other: vec2) -> vec2: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __imod__(self, other: _Number) -> mvec2: ...
    @overload
    def __imod__(self, other: vec2) -> mvec2: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __pow__(self, other: _Number) -> mvec2: ...
    @overload
    def __pow__(self, other: vec2) -> vec2: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __ipow__(self, other: _Number) -> mvec2: ...
    @overload
    def __ipow__(self, other: vec2) -> mvec2: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __floordiv__(self, other: _Number) -> mvec2: ...
    @overload
    def __floordiv__(self, other: vec2) -> vec2: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> mvec2: ...
    @overload
    def __ifloordiv__(self, other: vec2) -> mvec2: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec2: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __truediv__(self, other: _Number) -> mvec2: ...
    @overload
    def __truediv__(self, other: mat2x2) -> vec2: ...
    @overload
    def __truediv__(self, other: vec2) -> vec2: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec2: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __itruediv__(self, other: _Number) -> mvec2: ...
    @overload
    def __itruediv__(self, other: mat2x2) -> vec2: ...
    @overload
    def __itruediv__(self, other: vec2) -> mvec2: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number]) -> vec2: ...
    @overload
    def __matmul__(self, other: _Number) -> mvec2: ...
    @overload
    def __matmul__(self, other: mat2x2) -> vec2: ...
    @overload
    def __matmul__(self, other: mat3x2) -> vec3: ...
    @overload
    def __matmul__(self, other: mat4x2) -> vec4: ...
    @overload
    def __matmul__(self, other: vec2) -> vec2: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> mvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number]) -> mvec2: ...
    @overload
    def __imatmul__(self, other: _Number) -> mvec2: ...
    @overload
    def __imatmul__(self, other: mat2x2) -> mvec2: ...
    @overload
    def __imatmul__(self, other: mat3x2) -> vec3: ...
    @overload
    def __imatmul__(self, other: mat4x2) -> vec4: ...
    @overload
    def __imatmul__(self, other: vec2) -> mvec2: ...

    def __divmod__(self, other: vec2) -> Tuple[vec2, vec2]: ...


class mvec3:

    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> mvec3: ...
    def __pos__(self) -> mvec3: ...
    def __abs__(self) -> mvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mvec3: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __add__(self, other: _Number) -> mvec3: ...
    @overload
    def __add__(self, other: vec3) -> vec3: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __iadd__(self, other: _Number) -> mvec3: ...
    @overload
    def __iadd__(self, other: vec3) -> mvec3: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __sub__(self, other: _Number) -> mvec3: ...
    @overload
    def __sub__(self, other: vec3) -> vec3: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __isub__(self, other: _Number) -> mvec3: ...
    @overload
    def __isub__(self, other: vec3) -> mvec3: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __mul__(self, other: _Number) -> mvec3: ...
    @overload
    def __mul__(self, other: mat2x3) -> vec2: ...
    @overload
    def __mul__(self, other: mat3x3) -> vec3: ...
    @overload
    def __mul__(self, other: mat4x3) -> vec4: ...
    @overload
    def __mul__(self, other: vec3) -> vec3: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __imul__(self, other: _Number) -> mvec3: ...
    @overload
    def __imul__(self, other: mat2x3) -> vec2: ...
    @overload
    def __imul__(self, other: mat3x3) -> vec3: ...
    @overload
    def __imul__(self, other: mat4x3) -> vec4: ...
    @overload
    def __imul__(self, other: vec3) -> mvec3: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __mod__(self, other: _Number) -> mvec3: ...
    @overload
    def __mod__(self, other: vec3) -> vec3: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __imod__(self, other: _Number) -> mvec3: ...
    @overload
    def __imod__(self, other: vec3) -> mvec3: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __pow__(self, other: _Number) -> mvec3: ...
    @overload
    def __pow__(self, other: vec3) -> vec3: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __ipow__(self, other: _Number) -> mvec3: ...
    @overload
    def __ipow__(self, other: vec3) -> mvec3: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __floordiv__(self, other: _Number) -> mvec3: ...
    @overload
    def __floordiv__(self, other: vec3) -> vec3: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> mvec3: ...
    @overload
    def __ifloordiv__(self, other: vec3) -> mvec3: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __truediv__(self, other: _Number) -> mvec3: ...
    @overload
    def __truediv__(self, other: mat3x3) -> vec3: ...
    @overload
    def __truediv__(self, other: vec3) -> vec3: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __itruediv__(self, other: _Number) -> mvec3: ...
    @overload
    def __itruediv__(self, other: mat3x3) -> vec3: ...
    @overload
    def __itruediv__(self, other: vec3) -> mvec3: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number]) -> vec3: ...
    @overload
    def __matmul__(self, other: _Number) -> mvec3: ...
    @overload
    def __matmul__(self, other: mat2x3) -> vec2: ...
    @overload
    def __matmul__(self, other: mat3x3) -> vec3: ...
    @overload
    def __matmul__(self, other: mat4x3) -> vec4: ...
    @overload
    def __matmul__(self, other: vec3) -> vec3: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> mvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number]) -> mvec3: ...
    @overload
    def __imatmul__(self, other: _Number) -> mvec3: ...
    @overload
    def __imatmul__(self, other: mat2x3) -> vec2: ...
    @overload
    def __imatmul__(self, other: mat3x3) -> mvec3: ...
    @overload
    def __imatmul__(self, other: mat4x3) -> vec4: ...
    @overload
    def __imatmul__(self, other: vec3) -> mvec3: ...

    def __divmod__(self, other: vec3) -> Tuple[vec3, vec3]: ...


class mvec4:

    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> mvec4: ...
    def __pos__(self) -> mvec4: ...
    def __abs__(self) -> mvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> mvec4: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __add__(self, other: _Number) -> mvec4: ...
    @overload
    def __add__(self, other: vec4) -> vec4: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __iadd__(self, other: _Number) -> mvec4: ...
    @overload
    def __iadd__(self, other: vec4) -> mvec4: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __sub__(self, other: _Number) -> mvec4: ...
    @overload
    def __sub__(self, other: vec4) -> vec4: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __isub__(self, other: _Number) -> mvec4: ...
    @overload
    def __isub__(self, other: vec4) -> mvec4: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __mul__(self, other: _Number) -> mvec4: ...
    @overload
    def __mul__(self, other: mat2x4) -> vec2: ...
    @overload
    def __mul__(self, other: mat3x4) -> vec3: ...
    @overload
    def __mul__(self, other: mat4x4) -> vec4: ...
    @overload
    def __mul__(self, other: vec4) -> vec4: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __imul__(self, other: _Number) -> mvec4: ...
    @overload
    def __imul__(self, other: mat2x4) -> vec2: ...
    @overload
    def __imul__(self, other: mat3x4) -> vec3: ...
    @overload
    def __imul__(self, other: mat4x4) -> vec4: ...
    @overload
    def __imul__(self, other: vec4) -> mvec4: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __mod__(self, other: _Number) -> mvec4: ...
    @overload
    def __mod__(self, other: vec4) -> vec4: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __imod__(self, other: _Number) -> mvec4: ...
    @overload
    def __imod__(self, other: vec4) -> mvec4: ...

    @overload
    def __pow__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __pow__(self, other: _Number) -> mvec4: ...
    @overload
    def __pow__(self, other: vec4) -> vec4: ...

    @overload
    def __ipow__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __ipow__(self, other: _Number) -> mvec4: ...
    @overload
    def __ipow__(self, other: vec4) -> mvec4: ...

    @overload
    def __floordiv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __floordiv__(self, other: _Number) -> mvec4: ...
    @overload
    def __floordiv__(self, other: vec4) -> vec4: ...

    @overload
    def __ifloordiv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __ifloordiv__(self, other: _Number) -> mvec4: ...
    @overload
    def __ifloordiv__(self, other: vec4) -> mvec4: ...

    @overload
    def __truediv__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __truediv__(self, other: _Number) -> mvec4: ...
    @overload
    def __truediv__(self, other: mat4x4) -> vec4: ...
    @overload
    def __truediv__(self, other: vec4) -> vec4: ...

    @overload
    def __itruediv__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __itruediv__(self, other: _Number) -> mvec4: ...
    @overload
    def __itruediv__(self, other: mat4x4) -> vec4: ...
    @overload
    def __itruediv__(self, other: vec4) -> mvec4: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> vec4: ...
    @overload
    def __matmul__(self, other: _Number) -> mvec4: ...
    @overload
    def __matmul__(self, other: mat2x4) -> vec2: ...
    @overload
    def __matmul__(self, other: mat3x4) -> vec3: ...
    @overload
    def __matmul__(self, other: mat4x4) -> vec4: ...
    @overload
    def __matmul__(self, other: vec4) -> vec4: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> mvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> vec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> mvec4: ...
    @overload
    def __imatmul__(self, other: _Number) -> mvec4: ...
    @overload
    def __imatmul__(self, other: mat2x4) -> vec2: ...
    @overload
    def __imatmul__(self, other: mat3x4) -> vec3: ...
    @overload
    def __imatmul__(self, other: mat4x4) -> mvec4: ...
    @overload
    def __imatmul__(self, other: vec4) -> mvec4: ...

    def __divmod__(self, other: vec4) -> Tuple[vec4, vec4]: ...


class quat:

    x: float
    y: float
    w: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, w: _Number, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], dquat, mat3x3, mat4x4, mvec3, quat, vec3]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> quat: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...


    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __mul__(self, other: Union[_Number]) -> quat: ...

    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __imul__(self, other: Union[_Number]) -> quat: ...

    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __matmul__(self, other: Union[_Number]) -> quat: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], vec4]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], vec3]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Union[_Number]) -> quat: ...


class u16vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u16vec2, u16vec3, u16vec4, u64vec1, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec1: ...
    def __pos__(self) -> u16vec1: ...
    def __abs__(self) -> u16vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, u16vec1]) -> u16vec1: ...


class u16vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u16vec3, u16vec4, u64vec2, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec2: ...
    def __pos__(self) -> u16vec2: ...
    def __abs__(self) -> u16vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, u16vec2]) -> u16vec2: ...


class u16vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u16vec4, u64vec3, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec3: ...
    def __pos__(self) -> u16vec3: ...
    def __abs__(self) -> u16vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u16vec3]) -> u16vec3: ...


class u16vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u16vec4: ...
    def __pos__(self) -> u16vec4: ...
    def __abs__(self) -> u16vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u16vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u16vec4]) -> u16vec4: ...


class u64vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u64vec2, u64vec3, u64vec4, u8vec1, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec1: ...
    def __pos__(self) -> u64vec1: ...
    def __abs__(self) -> u64vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, u64vec1]) -> u64vec1: ...


class u64vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u64vec3, u64vec4, u8vec2, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec2: ...
    def __pos__(self) -> u64vec2: ...
    def __abs__(self) -> u64vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, u64vec2]) -> u64vec2: ...


class u64vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u64vec4, u8vec3, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec3: ...
    def __pos__(self) -> u64vec3: ...
    def __abs__(self) -> u64vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u64vec3]) -> u64vec3: ...


class u64vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u64vec4: ...
    def __pos__(self) -> u64vec4: ...
    def __abs__(self) -> u64vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u64vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u64vec4]) -> u64vec4: ...


class u8vec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, u8vec2, u8vec3, u8vec4, uvec1, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec1: ...
    def __pos__(self) -> u8vec1: ...
    def __abs__(self) -> u8vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, u8vec1]) -> u8vec1: ...


class u8vec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, u8vec3, u8vec4, umvec2, uvec2, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec2: ...
    def __pos__(self) -> u8vec2: ...
    def __abs__(self) -> u8vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number], _Number, u8vec2]) -> u8vec2: ...


class u8vec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, u8vec4, umvec3, uvec3, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec3: ...
    def __pos__(self) -> u8vec3: ...
    def __abs__(self) -> u8vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, u8vec3]) -> u8vec3: ...


class u8vec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> u8vec4: ...
    def __pos__(self) -> u8vec4: ...
    def __abs__(self) -> u8vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> u8vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...

    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, u8vec4]) -> u8vec4: ...


class umat2x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x2, imat2x2, mat2x2, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec2, umvec2]) -> None: ...

    def __neg__(self) -> umat2x2: ...
    def __pos__(self) -> umat2x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat2x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number], uvec1]) -> uvec1: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number], uvec1]) -> uvec1: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number], uvec1]) -> uvec1: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number], uvec1]) -> uvec1: ...


class umat2x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x3, imat2x3, mat2x3, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec3, umvec3]) -> None: ...

    def __neg__(self) -> umat2x3: ...
    def __pos__(self) -> umat2x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat2x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat2x3]) -> umat2x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat2x3]) -> umat2x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat2x3]) -> umat2x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat2x3]) -> umat2x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec3: ...


class umat2x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat2x4, imat2x4, mat2x4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[2]: ...
    def __len__(self) -> Literal[2]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec4, umvec4]) -> None: ...

    def __neg__(self) -> umat2x4: ...
    def __pos__(self) -> umat2x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat2x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat2x4]) -> umat2x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat2x4]) -> umat2x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat2x4]) -> umat2x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat2x4]) -> umat2x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> umat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> umat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat2x2]) -> umat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec4: ...


class umat3x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x2, imat3x2, mat3x2, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec2, umvec2]) -> None: ...

    def __neg__(self) -> umat3x2: ...
    def __pos__(self) -> umat3x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat3x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat3x2]) -> umat3x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat3x2]) -> umat3x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat3x2]) -> umat3x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat3x2]) -> umat3x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec2: ...


class umat3x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x3, imat3x3, mat3x3, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec3, umvec3]) -> None: ...

    def __neg__(self) -> umat3x3: ...
    def __pos__(self) -> umat3x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat3x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number], uvec2]) -> uvec2: ...


class umat3x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat3x4, imat3x4, mat3x4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[3]: ...
    def __len__(self) -> Literal[3]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec4, umvec4]) -> None: ...

    def __neg__(self) -> umat3x4: ...
    def __pos__(self) -> umat3x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat3x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat3x4]) -> umat3x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat3x4]) -> umat3x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat3x4]) -> umat3x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat3x4]) -> umat3x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec4: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec4: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> umat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat3x3]) -> umat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> umat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec4: ...


class umat4x2:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x2, imat4x2, mat4x2, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec2, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec2: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec2, umvec2]) -> None: ...

    def __neg__(self) -> umat4x2: ...
    def __pos__(self) -> umat4x2: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int], Tuple[int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat4x2: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat4x2]) -> umat4x2: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat4x2]) -> umat4x2: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat4x2]) -> umat4x2: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], _Number, umat4x2]) -> umat4x2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x2: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x2: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x2: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x2: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec2: ...


class umat4x3:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x3, imat4x3, mat4x3, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec3, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec3: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec3, umvec3]) -> None: ...

    def __neg__(self) -> umat4x3: ...
    def __pos__(self) -> umat4x3: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int], Tuple[int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat4x3: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat4x3]) -> umat4x3: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat4x3]) -> umat4x3: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat4x3]) -> umat4x3: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], _Number, umat4x3]) -> umat4x3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x3: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x3: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec3: ...


class umat4x4:

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: _Number, /) -> None: ...
    @overload
    def __init__(self, _0: _Number, _1: _Number, _2: _Number, _3: _Number, _4: _Number, _5: _Number, _6: _Number, _7: _Number, _8: _Number, _9: _Number, _10: _Number, _11: _Number, _12: _Number, _13: _Number, _14: _Number, _15: _Number, /) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], dmat4x4, imat4x4, mat4x4, umat2x2, umat2x3, umat2x4, umat3x2, umat3x3, umat3x4, umat4x2, umat4x3, umat4x4]) -> None: ...

    def length(self) -> Literal[4]: ...
    def __len__(self) -> Literal[4]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[umvec4, None, None]: ...

    @overload
    def __getitem__(self, index: Tuple[int, int]) -> int: ...
    @overload
    def __getitem__(self, index: int) -> umvec4: ...

    @overload
    def __setitem__(self, index: Tuple[int, int], value: _Number) -> None: ...
    @overload
    def __setitem__(self, index: int, value: Union[uvec4, umvec4]) -> None: ...

    def __neg__(self) -> umat4x4: ...
    def __pos__(self) -> umat4x4: ...

    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    def to_list(self) -> List[List[int]]: ...
    def to_tuple(self) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int], Tuple[int, int, int, int]]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umat4x4: ...

    def __add__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...

    def __iadd__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...

    def __sub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...

    def __isub__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], _Number, umat4x4]) -> umat4x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> umat3x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> umat2x4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[_Number, _Number, _Number], uvec3]) -> uvec3: ...


class umvec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], uvec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> umvec2: ...
    def __pos__(self) -> umvec2: ...
    def __abs__(self) -> umvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umvec2: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __add__(self, other: _Number) -> umvec2: ...
    @overload
    def __add__(self, other: uvec2) -> uvec2: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number]) -> umvec2: ...
    @overload
    def __iadd__(self, other: _Number) -> umvec2: ...
    @overload
    def __iadd__(self, other: uvec2) -> umvec2: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __sub__(self, other: _Number) -> umvec2: ...
    @overload
    def __sub__(self, other: uvec2) -> uvec2: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number]) -> umvec2: ...
    @overload
    def __isub__(self, other: _Number) -> umvec2: ...
    @overload
    def __isub__(self, other: uvec2) -> umvec2: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __mul__(self, other: _Number) -> umvec2: ...
    @overload
    def __mul__(self, other: umat2x2) -> uvec2: ...
    @overload
    def __mul__(self, other: umat3x2) -> uvec3: ...
    @overload
    def __mul__(self, other: umat4x2) -> uvec4: ...
    @overload
    def __mul__(self, other: uvec2) -> uvec2: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number]) -> umvec2: ...
    @overload
    def __imul__(self, other: _Number) -> umvec2: ...
    @overload
    def __imul__(self, other: umat2x2) -> uvec2: ...
    @overload
    def __imul__(self, other: umat3x2) -> uvec3: ...
    @overload
    def __imul__(self, other: umat4x2) -> uvec4: ...
    @overload
    def __imul__(self, other: uvec2) -> umvec2: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __mod__(self, other: _Number) -> umvec2: ...
    @overload
    def __mod__(self, other: uvec2) -> uvec2: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __imod__(self, other: _Number) -> umvec2: ...
    @overload
    def __imod__(self, other: uvec2) -> uvec2: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __truediv__(self, other: _Number) -> umvec2: ...
    @overload
    def __truediv__(self, other: uvec2) -> uvec2: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number]) -> umvec2: ...
    @overload
    def __itruediv__(self, other: _Number) -> umvec2: ...
    @overload
    def __itruediv__(self, other: uvec2) -> umvec2: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number]) -> uvec2: ...
    @overload
    def __matmul__(self, other: _Number) -> umvec2: ...
    @overload
    def __matmul__(self, other: umat2x2) -> uvec2: ...
    @overload
    def __matmul__(self, other: umat3x2) -> uvec3: ...
    @overload
    def __matmul__(self, other: umat4x2) -> uvec4: ...
    @overload
    def __matmul__(self, other: uvec2) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]]) -> umvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number]) -> umvec2: ...
    @overload
    def __imatmul__(self, other: _Number) -> umvec2: ...
    @overload
    def __imatmul__(self, other: umat2x2) -> umvec2: ...
    @overload
    def __imatmul__(self, other: umat3x2) -> uvec3: ...
    @overload
    def __imatmul__(self, other: umat4x2) -> uvec4: ...
    @overload
    def __imatmul__(self, other: uvec2) -> umvec2: ...


class umvec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], uvec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> umvec3: ...
    def __pos__(self) -> umvec3: ...
    def __abs__(self) -> umvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umvec3: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __add__(self, other: _Number) -> umvec3: ...
    @overload
    def __add__(self, other: uvec3) -> uvec3: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number]) -> umvec3: ...
    @overload
    def __iadd__(self, other: _Number) -> umvec3: ...
    @overload
    def __iadd__(self, other: uvec3) -> umvec3: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __sub__(self, other: _Number) -> umvec3: ...
    @overload
    def __sub__(self, other: uvec3) -> uvec3: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number]) -> umvec3: ...
    @overload
    def __isub__(self, other: _Number) -> umvec3: ...
    @overload
    def __isub__(self, other: uvec3) -> umvec3: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __mul__(self, other: _Number) -> umvec3: ...
    @overload
    def __mul__(self, other: umat2x3) -> uvec2: ...
    @overload
    def __mul__(self, other: umat3x3) -> uvec3: ...
    @overload
    def __mul__(self, other: umat4x3) -> uvec4: ...
    @overload
    def __mul__(self, other: uvec3) -> uvec3: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number]) -> umvec3: ...
    @overload
    def __imul__(self, other: _Number) -> umvec3: ...
    @overload
    def __imul__(self, other: umat2x3) -> uvec2: ...
    @overload
    def __imul__(self, other: umat3x3) -> uvec3: ...
    @overload
    def __imul__(self, other: umat4x3) -> uvec4: ...
    @overload
    def __imul__(self, other: uvec3) -> umvec3: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __mod__(self, other: _Number) -> umvec3: ...
    @overload
    def __mod__(self, other: uvec3) -> uvec3: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __imod__(self, other: _Number) -> umvec3: ...
    @overload
    def __imod__(self, other: uvec3) -> uvec3: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __truediv__(self, other: _Number) -> umvec3: ...
    @overload
    def __truediv__(self, other: uvec3) -> uvec3: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number]) -> umvec3: ...
    @overload
    def __itruediv__(self, other: _Number) -> umvec3: ...
    @overload
    def __itruediv__(self, other: uvec3) -> umvec3: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number]) -> uvec3: ...
    @overload
    def __matmul__(self, other: _Number) -> umvec3: ...
    @overload
    def __matmul__(self, other: umat2x3) -> uvec2: ...
    @overload
    def __matmul__(self, other: umat3x3) -> uvec3: ...
    @overload
    def __matmul__(self, other: umat4x3) -> uvec4: ...
    @overload
    def __matmul__(self, other: uvec3) -> uvec3: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> umvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number]) -> umvec3: ...
    @overload
    def __imatmul__(self, other: _Number) -> umvec3: ...
    @overload
    def __imatmul__(self, other: umat2x3) -> uvec2: ...
    @overload
    def __imatmul__(self, other: umat3x3) -> umvec3: ...
    @overload
    def __imatmul__(self, other: umat4x3) -> uvec4: ...
    @overload
    def __imatmul__(self, other: uvec3) -> umvec3: ...


class umvec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], uvec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> umvec4: ...
    def __pos__(self) -> umvec4: ...
    def __abs__(self) -> umvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> umvec4: ...

    @overload
    def __add__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __add__(self, other: _Number) -> umvec4: ...
    @overload
    def __add__(self, other: uvec4) -> uvec4: ...

    @overload
    def __iadd__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> umvec4: ...
    @overload
    def __iadd__(self, other: _Number) -> umvec4: ...
    @overload
    def __iadd__(self, other: uvec4) -> umvec4: ...

    @overload
    def __sub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __sub__(self, other: _Number) -> umvec4: ...
    @overload
    def __sub__(self, other: uvec4) -> uvec4: ...

    @overload
    def __isub__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> umvec4: ...
    @overload
    def __isub__(self, other: _Number) -> umvec4: ...
    @overload
    def __isub__(self, other: uvec4) -> umvec4: ...

    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __mul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __mul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __mul__(self, other: _Number) -> umvec4: ...
    @overload
    def __mul__(self, other: umat2x4) -> uvec2: ...
    @overload
    def __mul__(self, other: umat3x4) -> uvec3: ...
    @overload
    def __mul__(self, other: umat4x4) -> uvec4: ...
    @overload
    def __mul__(self, other: uvec4) -> uvec4: ...

    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __imul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __imul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> umvec4: ...
    @overload
    def __imul__(self, other: _Number) -> umvec4: ...
    @overload
    def __imul__(self, other: umat2x4) -> uvec2: ...
    @overload
    def __imul__(self, other: umat3x4) -> uvec3: ...
    @overload
    def __imul__(self, other: umat4x4) -> uvec4: ...
    @overload
    def __imul__(self, other: uvec4) -> umvec4: ...

    @overload
    def __mod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __mod__(self, other: _Number) -> umvec4: ...
    @overload
    def __mod__(self, other: uvec4) -> uvec4: ...

    @overload
    def __imod__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __imod__(self, other: _Number) -> umvec4: ...
    @overload
    def __imod__(self, other: uvec4) -> uvec4: ...

    @overload
    def __truediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __truediv__(self, other: _Number) -> umvec4: ...
    @overload
    def __truediv__(self, other: uvec4) -> uvec4: ...

    @overload
    def __itruediv__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> umvec4: ...
    @overload
    def __itruediv__(self, other: _Number) -> umvec4: ...
    @overload
    def __itruediv__(self, other: uvec4) -> umvec4: ...

    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __matmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> uvec4: ...
    @overload
    def __matmul__(self, other: _Number) -> umvec4: ...
    @overload
    def __matmul__(self, other: umat2x4) -> uvec2: ...
    @overload
    def __matmul__(self, other: umat3x4) -> uvec3: ...
    @overload
    def __matmul__(self, other: umat4x4) -> uvec4: ...
    @overload
    def __matmul__(self, other: uvec4) -> uvec4: ...

    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> umvec4: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]]) -> uvec2: ...
    @overload
    def __imatmul__(self, other: Tuple[_Number, _Number, _Number, _Number]) -> umvec4: ...
    @overload
    def __imatmul__(self, other: _Number) -> umvec4: ...
    @overload
    def __imatmul__(self, other: umat2x4) -> uvec2: ...
    @overload
    def __imatmul__(self, other: umat3x4) -> uvec3: ...
    @overload
    def __imatmul__(self, other: umat4x4) -> umvec4: ...
    @overload
    def __imatmul__(self, other: uvec4) -> umvec4: ...


class uvec1:

    x: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, u16vec1, u64vec1, u8vec1, umvec2, umvec3, umvec4, uvec1, uvec2, uvec3, uvec4, vec1]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec1: ...
    def __pos__(self) -> uvec1: ...
    def __abs__(self) -> uvec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, uvec1]) -> uvec1: ...


class uvec2:

    x: int
    y: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, u16vec2, u64vec2, u8vec2, umvec2, umvec3, umvec4, uvec2, uvec3, uvec4, vec2]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec2: ...
    def __pos__(self) -> uvec2: ...
    def __abs__(self) -> uvec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> uvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> uvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, umat2x2, uvec2]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> uvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> uvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, umat2x2, uvec2]) -> uvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number], _Number, uvec2]) -> uvec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, umat2x2, uvec2]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat4x2]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], umat3x2]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, umat2x2, uvec2]) -> uvec2: ...


class uvec3:

    x: int
    y: int
    z: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, u16vec3, u64vec3, u8vec3, umvec3, umvec4, uvec3, uvec4, vec3]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec3: ...
    def __pos__(self) -> uvec3: ...
    def __abs__(self) -> uvec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> uvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, umat3x3, uvec3]) -> uvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> uvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, umat3x3, uvec3]) -> uvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> uvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, uvec3]) -> uvec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, umat3x3, uvec3]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat4x3]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, umat3x3, uvec3]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], umat2x3]) -> uvec2: ...


class uvec4:

    x: int
    y: int
    z: int
    w: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> int: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[int, None, None]: ...

    def __neg__(self) -> uvec4: ...
    def __pos__(self) -> uvec4: ...
    def __abs__(self) -> uvec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[int]: ...
    def to_tuple(self) -> Tuple[int, int, int, int]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> uvec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, umat4x4, uvec4]) -> uvec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> uvec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> uvec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, umat4x4, uvec4]) -> uvec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> uvec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> uvec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __truediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    def __itruediv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, uvec4]) -> uvec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, umat4x4, uvec4]) -> uvec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> uvec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> uvec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, umat4x4, uvec4]) -> uvec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat3x4]) -> uvec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], umat2x4]) -> uvec2: ...


class vec1:

    x: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], Tuple[_Number], bvec1, dvec1, i16vec1, i64vec1, i8vec1, ivec1, mvec2, mvec3, mvec4, u16vec1, u64vec1, u8vec1, uvec1, vec1, vec2, vec3, vec4]) -> None: ...

    def __len__(self) -> Literal[1]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec1: ...
    def __pos__(self) -> vec1: ...
    def __abs__(self) -> vec1: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec1: ...

    def __add__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __iadd__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __sub__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __isub__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __mul__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __imul__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __mod__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __imod__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __pow__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __ipow__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __floordiv__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __truediv__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __itruediv__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __matmul__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __imatmul__(self, other: Union[Tuple[_Number], _Number, vec1]) -> vec1: ...

    def __divmod__(self, other: Union[vec1]) -> Tuple[vec1, vec1]: ...


class vec2:

    x: float
    y: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number], bvec2, dmvec2, dvec2, i16vec2, i64vec2, i8vec2, imvec2, ivec2, mvec2, mvec3, mvec4, u16vec2, u64vec2, u8vec2, umvec2, uvec2, vec2, vec3, vec4]) -> None: ...

    def __len__(self) -> Literal[2]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec2: ...
    def __pos__(self) -> vec2: ...
    def __abs__(self) -> vec2: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec2: ...

    def __add__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> vec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> vec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> vec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> vec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number], _Number, vec2]) -> vec2: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> vec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> vec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat4x2]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number], Tuple[_Number, _Number]], mat3x2]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number], Tuple[_Number, _Number]], Tuple[_Number, _Number], _Number, mat2x2, vec2]) -> vec2: ...

    def __divmod__(self, other: Union[vec2]) -> Tuple[vec2, vec2]: ...


class vec3:

    x: float
    y: float
    z: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number], bvec3, dmvec3, dvec3, i16vec3, i64vec3, i8vec3, imvec3, ivec3, mvec3, mvec4, u16vec3, u64vec3, u8vec3, umvec3, uvec3, vec3, vec4]) -> None: ...

    def __len__(self) -> Literal[3]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec3: ...
    def __pos__(self) -> vec3: ...
    def __abs__(self) -> vec3: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec3: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> vec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> vec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number, _Number], _Number, vec3]) -> vec3: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> vec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat4x3]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], Tuple[_Number, _Number, _Number], _Number, mat3x3, vec3]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number], Tuple[_Number, _Number, _Number]], mat2x3]) -> vec2: ...

    def __divmod__(self, other: Union[vec3]) -> Tuple[vec3, vec3]: ...


class vec4:

    x: float
    y: float
    z: float
    w: float

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: _Number) -> None: ...
    @overload
    def __init__(self, x: _Number, y: _Number, z: _Number, w: _Number) -> None: ...
    @overload
    def __init__(self, x: Union[Tuple[_Number, _Number, _Number, _Number], bvec4, dmvec4, dvec4, i16vec4, i64vec4, i8vec4, imvec4, ivec4, mvec4, u16vec4, u64vec4, u8vec4, umvec4, uvec4, vec4]) -> None: ...

    def __len__(self) -> Literal[4]: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: _Number) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[float, None, None]: ...

    def __neg__(self) -> vec4: ...
    def __pos__(self) -> vec4: ...
    def __abs__(self) -> vec4: ...

    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...

    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, float, float, float]: ...
    def to_bytes(self) -> bytes: ...

    @staticmethod
    def from_bytes(bytes: bytes, /) -> vec4: ...

    def __add__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __iadd__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __sub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __isub__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> vec3: ...
    @overload
    def __mul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> vec2: ...

    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> vec3: ...
    @overload
    def __imul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> vec2: ...

    def __mod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __imod__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __pow__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __ipow__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __floordiv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __ifloordiv__(self, other: Union[Tuple[_Number, _Number, _Number, _Number], _Number, vec4]) -> vec4: ...

    def __truediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...

    def __itruediv__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...

    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> vec3: ...
    @overload
    def __matmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> vec2: ...

    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], Tuple[_Number, _Number, _Number, _Number], _Number, mat4x4, vec4]) -> vec4: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat3x4]) -> vec3: ...
    @overload
    def __imatmul__(self, other: Union[Tuple[Tuple[_Number, _Number, _Number, _Number], Tuple[_Number, _Number, _Number, _Number]], mat2x4]) -> vec2: ...

    def __divmod__(self, other: Union[vec4]) -> Tuple[vec4, vec4]: ...

bool_ = ctypes.c_bool
c_int16 = int16 = ctypes.c_short
c_int32 = int32 = ctypes.c_long
c_int64 = int64 = ctypes.c_longlong
c_int8 = int8 = ctypes.c_byte
c_uint16 = uint16 = ctypes.c_ushort
c_uint32 = uint32 = ctypes.c_ulong
c_uint64 = uint64 = ctypes.c_ulonglong
c_uint8 = uint8 = ctypes.c_ubyte
dmat2 = f64mat2 = f64mat2x2 = dmat2x2
dmat3 = f64mat3 = f64mat3x3 = dmat3x3
dmat4 = f64mat4 = f64mat4x4 = dmat4x4
double = float64 = ctypes.c_double
f32mat2 = f32mat2x2 = fmat2 = fmat2x2 = mat2 = mat2x2
f32mat2x3 = fmat2x3 = mat2x3
f32mat2x4 = fmat2x4 = mat2x4
f32mat3 = f32mat3x3 = fmat3 = fmat3x3 = mat3 = mat3x3
f32mat3x2 = fmat3x2 = mat3x2
f32mat3x4 = fmat3x4 = mat3x4
f32mat4 = f32mat4x4 = fmat4 = fmat4x4 = mat4 = mat4x4
f32mat4x2 = fmat4x2 = mat4x2
f32mat4x3 = fmat4x3 = mat4x3
f32quat = fquat = quat
f32vec1 = fvec1 = vec1
f32vec2 = fvec2 = vec2
f32vec3 = fvec3 = vec3
f32vec4 = fvec4 = vec4
f64mat2x3 = dmat2x3
f64mat2x4 = dmat2x4
f64mat3x2 = dmat3x2
f64mat3x4 = dmat3x4
f64mat4x2 = dmat4x2
f64mat4x3 = dmat4x3
f64quat = dquat
f64vec1 = dvec1
f64vec2 = dvec2
f64vec3 = dvec3
f64vec4 = dvec4
float32 = float_ = ctypes.c_float
i32mat2 = i32mat2x2 = imat2 = imat2x2
i32mat2x3 = imat2x3
i32mat2x4 = imat2x4
i32mat3 = i32mat3x3 = imat3 = imat3x3
i32mat3x2 = imat3x2
i32mat3x4 = imat3x4
i32mat4 = i32mat4x4 = imat4 = imat4x4
i32mat4x2 = imat4x2
i32mat4x3 = imat4x3
i32vec1 = ivec1
i32vec2 = ivec2
i32vec3 = ivec3
i32vec4 = ivec4
u32mat2 = u32mat2x2 = umat2 = umat2x2
u32mat2x3 = umat2x3
u32mat2x4 = umat2x4
u32mat3 = u32mat3x3 = umat3 = umat3x3
u32mat3x2 = umat3x2
u32mat3x4 = umat3x4
u32mat4 = u32mat4x4 = umat4 = umat4x4
u32mat4x2 = umat4x2
u32mat4x3 = umat4x3
u32vec1 = uvec1
u32vec2 = uvec2
u32vec3 = uvec3
u32vec4 = uvec4
