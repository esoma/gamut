
from __future__ import annotations

# python
import ctypes
from typing import (Any, Final, Generator, Generic, List, overload, Tuple,
                    Type, TypeVar, Union)


S = TypeVar('S')
T = TypeVar('T')
C = TypeVar('C')
M = TypeVar('M')
V1 = TypeVar('V1')
V2 = TypeVar('V2')


class _Mat2x2(Generic[
    T,  # python return type
    C,  # internal c type for each component, as a ctypes type
    M,  # mvec type to use for rows
    V1, # vec1 return type for multiplication
    V2  # vec2 return type for multiplication
]):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: T, /) -> None: ...
    @overload
    def __init__(self, _1: T, _2: T, /) -> None: ...
    @overload
    def __init__(self, _1: T, _2: T, _3: T, _4: T, /) -> None: ...
    
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> M: ...
    def __setitem__(self, index: int, value: _Vec2[T, C]) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[M, None, None]: ...
    
    def __add__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    def __sub__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    
    @overload
    def __mul__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    @overload
    def __mul__(self, other: _Vec1[T, C]) -> V1: ...
    @overload
    def __mul__(self, other: _Vec2[T, C]) -> V2: ...
    
    def __neg__(self: S) -> S: ...
    def __pos__(self: S) -> S: ...
    
    def __iadd__(self, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> None: ...
    def __isub__(self, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> None: ...
    
    @overload
    def __imul__(self, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> None: ...
    @overload
    def __imul__(self, other: _Vec1[T, C]) -> None: ...
    @overload
    def __imul__(self, other: _Vec2[T, C]) -> None: ...
    
    @overload
    def __div__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    @overload
    def __div__(self, other: _Vec2[T, C]) -> V2: ...
    
    @overload
    def __truediv__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    @overload
    def __truediv__(self, other: _Vec2[T, C]) -> V2: ...
    
    @overload
    def __matmul__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    @overload
    def __matmul__(self, other: _Vec1[T, C]) -> V1: ...
    @overload
    def __matmul__(self, other: _Vec2[T, C]) -> V2: ...
    
    @overload
    def __imatmul__(self, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> None: ...
    @overload
    def __imatmul__(self, other: _Vec1[T, C]) -> None: ...
    @overload
    def __imatmul__(self, other: _Vec2[T, C]) -> None: ...
    
    def length(self) -> int: ...
    def to_list(self) -> List[List[T]]: ...
    def to_tuple(self) -> Tuple[Tuple[T, T], Tuple[T, T]]: ...
    def to_bytes(self) -> bytes: ...
    
    @classmethod
    def from_bytes(cls: Type[S], bytes: bytes, /) -> S: ...
    
    
class _Mat2x3(Generic[
    T,  # python return type
    C,  # internal c type for each component, as a ctypes type
    M,  # mvec type to use for rows
    V1, # vec1 return type for multiplication
    V2  # vec2 return type for multiplication
]):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _: T, /) -> None: ...
    @overload
    def __init__(self, _1: T, _2: T, /) -> None: ...
    @overload
    def __init__(self, _1: T, _2: T, _3: T, _4: T, /) -> None: ...
    
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> M: ...
    def __setitem__(self, index: int, value: _Vec2[T, C]) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[M, None, None]: ...
    
    def __add__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    def __sub__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    
    @overload
    def __mul__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    @overload
    def __mul__(self, other: _Vec1[T, C]) -> V1: ...
    @overload
    def __mul__(self, other: _Vec2[T, C]) -> V2: ...
    
    def __neg__(self: S) -> S: ...
    def __pos__(self: S) -> S: ...
    
    def __iadd__(self, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> None: ...
    def __isub__(self, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> None: ...
    
    @overload
    def __imul__(self, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> None: ...
    @overload
    def __imul__(self, other: _Vec1[T, C]) -> None: ...
    @overload
    def __imul__(self, other: _Vec2[T, C]) -> None: ...
    
    @overload
    def __div__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    @overload
    def __div__(self, other: _Vec2[T, C]) -> V2: ...
    
    @overload
    def __truediv__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    @overload
    def __truediv__(self, other: _Vec2[T, C]) -> V2: ...
    
    @overload
    def __matmul__(self: S, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> S: ...
    @overload
    def __matmul__(self, other: _Vec1[T, C]) -> V1: ...
    @overload
    def __matmul__(self, other: _Vec2[T, C]) -> V2: ...
    
    @overload
    def __imatmul__(self, other: Union[float, _Mat2x2[T, C, M, V1, V2]]) -> None: ...
    @overload
    def __imatmul__(self, other: _Vec1[T, C]) -> None: ...
    @overload
    def __imatmul__(self, other: _Vec2[T, C]) -> None: ...
    
    def length(self) -> int: ...
    def to_list(self) -> List[List[T]]: ...
    def to_tuple(self) -> Tuple[Tuple[T, T], Tuple[T, T]]: ...
    def to_bytes(self) -> bytes: ...
    
    @classmethod
    def from_bytes(cls: Type[S], bytes: bytes, /) -> S: ...


class _Vec1(Generic[T, C]):

    x: T

    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, x: Union[T, _Vec1[Any, Any], _Vec2[T, C], _Vec3[T, C], _Vec4[T, C]]) -> None: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> T: ...
    def __setitem__(self, index: int, value: T) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[T, None, None]: ...

    def __add__(self: S, other: Union[float, _Vec1[T, C]]) -> S: ...
    def __sub__(self: S, other: Union[float, _Vec1[T, C]]) -> S: ...
    def __mul__(self: S, other: Union[float, _Vec1[T, C]]) -> S: ...
    def __mod__(self: S, other: Union[float, _Vec1[T, C]]) -> S: ...
    def __divmod__(self: S, other: Union[float, _Vec1[T, C]]) -> S: ...
    def __pow__(self: S, other: Union[float, _Vec1[T, C]]) -> S: ...

    def __neg__(self: S) -> S: ...
    def __pos__(self: S) -> S: ...
    def __abs__(self: S) -> S: ...

    def __iadd__(self, other: Union[float, _Vec1[T, C]]) -> None: ...
    def __isub__(self, other: Union[float, _Vec1[T, C]]) -> None: ...
    def __imul__(self, other: Union[float, _Vec1[T, C]]) -> None: ...
    def __imod__(self, other: Union[float, _Vec1[T, C]]) -> None: ...
    def __ipow__(self, other: Union[float, _Vec1[T, C]]) -> None: ...

    def __floordiv__(self: S, other: Union[float, _Vec1[T, C]]) -> S: ...
    def __div__(self: S, other: Union[float, _Vec1[T, C]]) -> S: ...
    def __truediv__(self: S, other: Union[float, _Vec1[T, C]]) -> S: ...
    def __ifloordiv__(self, other: Union[float, _Vec1[T, C]]) -> None: ...
    def __idiv__(self, other: Union[float, _Vec1[T, C]]) -> None: ...
    def __itruediv__(self, other: Union[float, _Vec1[T, C]]) -> None: ...

    def __matmul__(self: S, other: Union[float, _Vec1[T, C]]) -> S: ...
    def __imatmul__(self, other: Union[float, _Vec1[T, C]]) -> None: ...

    def to_list(self) -> List[T]: ...
    def to_tuple(self) -> Tuple[T]: ...
    def to_bytes(self) -> bytes: ...

    @classmethod
    def from_bytes(cls: Type[S], bytes: bytes, /) -> S: ...


class _Vec2(Generic[T, C]):

    x: T
    y: T

    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, x: Union[T, _Vec2[Any, Any], _Vec3[T, C], _Vec4[T, C]]) -> None: ...

    @overload
    def __init__(self, x: T, y: T) -> None: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> T: ...
    def __setitem__(self, index: int, value: T) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[T, None, None]: ...

    def __add__(self: S, other: Union[float, _Vec2[T, C]]) -> S: ...
    def __sub__(self: S, other: Union[float, _Vec2[T, C]]) -> S: ...
    def __mul__(self: S, other: Union[float, _Vec2[T, C], _Mat2x2[T, C, Any, Any, Any]]) -> S: ...
    def __mod__(self: S, other: Union[float, _Vec2[T, C]]) -> S: ...
    def __divmod__(self: S, other: Union[float, _Vec2[T, C]]) -> S: ...
    def __pow__(self: S, other: Union[float, _Vec2[T, C]]) -> S: ...

    def __neg__(self: S) -> S: ...
    def __pos__(self: S) -> S: ...
    def __abs__(self: S) -> S: ...

    def __iadd__(self, other: Union[float, _Vec2[T, C]]) -> None: ...
    def __isub__(self, other: Union[float, _Vec2[T, C]]) -> None: ...
    def __imul__(self, other: Union[float, _Vec2[T, C], _Mat2x2[T, C, Any, Any, Any]]) -> None: ...
    def __imod__(self, other: Union[float, _Vec2[T, C]]) -> None: ...
    def __ipow__(self, other: Union[float, _Vec2[T, C]]) -> None: ...

    def __floordiv__(self: S, other: Union[float, _Vec2[T, C]]) -> S: ...
    def __div__(self: S, other: Union[float, _Vec2[T, C], _Mat2x2[T, C, Any, Any, Any]]) -> S: ...
    def __truediv__(self: S, other: Union[float, _Vec2[T, C], _Mat2x2[T, C, Any, Any, Any]]) -> S: ...
    def __ifloordiv__(self, other: Union[float, _Vec2[T, C]]) -> None: ...
    def __idiv__(self, other: Union[float, _Vec2[T, C]]) -> None: ...
    def __itruediv__(self, other: Union[float, _Vec2[T, C]]) -> None: ...

    def __matmul__(self: S, other: Union[float, _Vec2[T, C], _Mat2x2[T, C, Any, Any, Any]]) -> S: ...
    def __imatmul__(self, other: Union[float, _Vec2[T, C], _Mat2x2[T, C, Any, Any, Any]]) -> None: ...

    def to_list(self) -> List[T]: ...
    def to_tuple(self) -> Tuple[T, T]: ...
    def to_bytes(self) -> bytes: ...

    @classmethod
    def from_bytes(cls: Type[S], bytes: bytes, /) -> S: ...


class _Vec3(Generic[T, C]):

    x: T
    y: T
    z: T

    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, x: Union[T, _Vec3[Any, Any], _Vec4[T, C]]) -> None: ...

    @overload
    def __init__(self, x: T, y: T, z: T) -> None: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> T: ...
    def __setitem__(self, index: int, value: T) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[T, None, None]: ...

    def __add__(self: S, other: Union[float, _Vec3[T, C]]) -> S: ...
    def __sub__(self: S, other: Union[float, _Vec3[T, C]]) -> S: ...
    def __mul__(self: S, other: Union[float, _Vec3[T, C]]) -> S: ...
    def __mod__(self: S, other: Union[float, _Vec3[T, C]]) -> S: ...
    def __divmod__(self: S, other: Union[float, _Vec3[T, C]]) -> S: ...
    def __pow__(self: S, other: Union[float, _Vec3[T, C]]) -> S: ...

    def __neg__(self: S) -> S: ...
    def __pos__(self: S) -> S: ...
    def __abs__(self: S) -> S: ...

    def __iadd__(self, other: Union[float, _Vec3[T, C]]) -> None: ...
    def __isub__(self, other: Union[float, _Vec3[T, C]]) -> None: ...
    def __imul__(self, other: Union[float, _Vec3[T, C]]) -> None: ...
    def __imod__(self, other: Union[float, _Vec3[T, C]]) -> None: ...
    def __ipow__(self, other: Union[float, _Vec3[T, C]]) -> None: ...

    def __floordiv__(self: S, other: Union[float, _Vec3[T, C]]) -> S: ...
    def __div__(self: S, other: Union[float, _Vec3[T, C]]) -> S: ...
    def __ifloordiv__(self, other: Union[float, _Vec3[T, C]]) -> None: ...
    def __idiv__(self, other: Union[float, _Vec3[T, C]]) -> None: ...

    def __matmul__(self: S, other: Union[float, _Vec3[T, C]]) -> S: ...
    def __imatmul__(self, other: Union[float, _Vec3[T, C]]) -> None: ...

    def to_list(self) -> List[T]: ...
    def to_tuple(self) -> Tuple[T, T, T]: ...
    def to_bytes(self) -> bytes: ...

    @classmethod
    def from_bytes(cls: Type[S], bytes: bytes, /) -> S: ...


class _Vec4(Generic[T, C]):

    x: T
    y: T
    z: T
    w: T

    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, x: Union[T, _Vec4[Any, Any]]) -> None: ...

    @overload
    def __init__(self, x: T, y: T, z: T, w: T) -> None: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> T: ...
    def __setitem__(self, index: int, value: T) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __iter__(self) -> Generator[T, None, None]: ...

    def __add__(self: S, other: Union[float, _Vec4[T, C]]) -> S: ...
    def __sub__(self: S, other: Union[float, _Vec4[T, C]]) -> S: ...
    def __mul__(self: S, other: Union[float, _Vec4[T, C]]) -> S: ...
    def __mod__(self: S, other: Union[float, _Vec4[T, C]]) -> S: ...
    def __divmod__(self: S, other: Union[float, _Vec4[T, C]]) -> S: ...
    def __pow__(self: S, other: Union[float, _Vec4[T, C]]) -> S: ...

    def __neg__(self: S) -> S: ...
    def __pos__(self: S) -> S: ...
    def __abs__(self: S) -> S: ...

    def __iadd__(self, other: Union[float, _Vec4[T, C]]) -> None: ...
    def __isub__(self, other: Union[float, _Vec4[T, C]]) -> None: ...
    def __imul__(self, other: Union[float, _Vec4[T, C]]) -> None: ...
    def __imod__(self, other: Union[float, _Vec4[T, C]]) -> None: ...
    def __ipow__(self, other: Union[float, _Vec4[T, C]]) -> None: ...

    def __floordiv__(self: S, other: Union[float, _Vec4[T, C]]) -> S: ...
    def __div__(self: S, other: Union[float, _Vec4[T, C]]) -> S: ...
    def __ifloordiv__(self, other: Union[float, _Vec4[T, C]]) -> None: ...
    def __idiv__(self, other: Union[float, _Vec4[T, C]]) -> None: ...

    def __matmul__(self: S, other: Union[float, _Vec4[T, C]]) -> S: ...
    def __imatmul__(self, other: Union[float, _Vec4[T, C]]) -> None: ...

    def to_list(self) -> List[T]: ...
    def to_tuple(self) -> Tuple[T, T, T, T]: ...
    def to_bytes(self) -> bytes: ...

    @classmethod
    def from_bytes(cls: Type[S], bytes: bytes, /) -> S: ...
    
    
def silence(id: int, /) -> None: ...


# float
c_float = ctypes.c_float
float_ = ctypes.c_float
float32 = ctypes.c_float

# double
c_double = ctypes.c_double
double = ctypes.c_double
float64 = ctypes.c_double

# int64
c_int64 = ctypes.c_int64
int64 = ctypes.c_int64

# int32
c_int32 = ctypes.c_int32
int32 = ctypes.c_int32

# int16
c_int16 = ctypes.c_int16
int16 = ctypes.c_int16

# int8
c_int8 = ctypes.c_int8
int8 = ctypes.c_int8

# uint64
c_uint64 = ctypes.c_uint64
uint64 = ctypes.c_uint64

# uint32
c_uint32 = ctypes.c_uint32
uint32 = ctypes.c_uint32

# uint16
c_uint16 = ctypes.c_uint16
uint16 = ctypes.c_uint16

# uint8
c_uint8 = ctypes.c_uint8
uint8 = ctypes.c_uint8

c_bool = ctypes.c_bool
bool_ = ctypes.c_bool

class vec1(_Vec1[float, ctypes.c_float]): ...
class vec2(_Vec2[float, ctypes.c_float]): ...
class vec3(_Vec3[float, ctypes.c_float]): ...
class vec4(_Vec4[float, ctypes.c_float]): ...

fvec1 = f32vec1 = vec1
fvec2 = f32vec2 = vec2
fvec3 = f32vec3 = vec3
fvec4 = f32vec4 = vec4

class dvec1(_Vec1[float, c_double]): ...
class dvec2(_Vec2[float, c_double]): ...
class dvec3(_Vec3[float, c_double]): ...
class dvec4(_Vec4[float, c_double]): ...

f64vec1 = dvec1
f64vec2 = dvec2
f64vec3 = dvec3
f64vec4 = dvec4

class i8vec1(_Vec1[int, c_int8]): ...
class i8vec2(_Vec2[int, c_int8]): ...
class i8vec3(_Vec3[int, c_int8]): ...
class i8vec4(_Vec4[int, c_int8]): ...

class i16vec1(_Vec1[int, c_int16]): ...
class i16vec2(_Vec2[int, c_int16]): ...
class i16vec3(_Vec3[int, c_int16]): ...
class i16vec4(_Vec4[int, c_int16]): ...

class ivec1(_Vec1[int, c_int32]): ...
class ivec2(_Vec2[int, c_int32]): ...
class ivec3(_Vec3[int, c_int32]): ...
class ivec4(_Vec4[int, c_int32]): ...

i32vec1 = ivec1
i32vec2 = ivec2
i32vec3 = ivec3
i32vec4 = ivec4

class i64vec1(_Vec1[int, c_int64]): ...
class i64vec2(_Vec2[int, c_int64]): ...
class i64vec3(_Vec3[int, c_int64]): ...
class i64vec4(_Vec4[int, c_int64]): ...

class u8vec1(_Vec1[int, c_uint8]): ...
class u8vec2(_Vec2[int, c_uint8]): ...
class u8vec3(_Vec3[int, c_uint8]): ...
class u8vec4(_Vec4[int, c_uint8]): ...

class u16vec1(_Vec1[int, c_uint16]): ...
class u16vec2(_Vec2[int, c_uint16]): ...
class u16vec3(_Vec3[int, c_uint16]): ...
class u16vec4(_Vec4[int, c_uint16]): ...

class uvec1(_Vec1[int, c_uint32]): ...
class uvec2(_Vec2[int, c_uint32]): ...
class uvec3(_Vec3[int, c_uint32]): ...
class uvec4(_Vec4[int, c_uint32]): ...

u32vec1 = uvec1
u32vec2 = uvec2
u32vec3 = uvec3
u32vec4 = uvec4

class u64vec1(_Vec1[int, c_uint64]): ...
class u64vec2(_Vec2[int, c_uint64]): ...
class u64vec3(_Vec3[int, c_uint64]): ...
class u64vec4(_Vec4[int, c_uint64]): ...

class bvec1(_Vec1[bool, c_bool]): ...
class bvec2(_Vec2[bool, c_bool]): ...
class bvec3(_Vec3[bool, c_bool]): ...
class bvec4(_Vec4[bool, c_bool]): ...

class mvec1(_Vec1[float, c_float]): ...
class mvec2(_Vec2[float, c_float]): ...
class mvec3(_Vec3[float, c_float]): ...
class mvec4(_Vec4[float, c_float]): ...

class dmvec1(_Vec1[float, c_double]): ...
class dmvec2(_Vec2[float, c_double]): ...
class dmvec3(_Vec3[float, c_double]): ...
class dmvec4(_Vec4[float, c_double]): ...

class imvec1(_Vec1[float, c_int32]): ...
class imvec2(_Vec2[float, c_int32]): ...
class imvec3(_Vec3[float, c_int32]): ...
class imvec4(_Vec4[float, c_int32]): ...

class umvec1(_Vec1[float, c_uint32]): ...
class umvec2(_Vec2[float, c_uint32]): ...
class umvec3(_Vec3[float, c_uint32]): ...
class umvec4(_Vec4[float, c_uint32]): ...

class mat2x2(_Mat2x2[float, c_float, mvec2, vec1, vec2]): ...

version: Final[str]
license: Final[str]
